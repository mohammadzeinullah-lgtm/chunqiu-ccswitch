This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/components/providers/**, src/hooks/useProviderActions.ts, src/config/*ProviderPresets.ts, src/App.tsx, src/i18n/locales/*.json, src/components/ui/**, src/types.ts, src/lib/api/**, src/lib/query/**, src/utils/**
- Files matching these patterns are excluded: node_modules/**, dist/**, coverage/**, *.lock
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/App.tsx
src/components/providers/AddProviderDialog.tsx
src/components/providers/EditProviderDialog.tsx
src/components/providers/FailoverPriorityBadge.tsx
src/components/providers/forms/ApiKeyInput.tsx
src/components/providers/forms/BasicFormFields.tsx
src/components/providers/forms/ClaudeFormFields.tsx
src/components/providers/forms/CodexCommonConfigModal.tsx
src/components/providers/forms/CodexConfigEditor.tsx
src/components/providers/forms/CodexConfigSections.tsx
src/components/providers/forms/CodexFormFields.tsx
src/components/providers/forms/CommonConfigEditor.tsx
src/components/providers/forms/EndpointSpeedTest.tsx
src/components/providers/forms/GeminiCommonConfigModal.tsx
src/components/providers/forms/GeminiConfigEditor.tsx
src/components/providers/forms/GeminiConfigSections.tsx
src/components/providers/forms/GeminiFormFields.tsx
src/components/providers/forms/hooks/index.ts
src/components/providers/forms/hooks/useApiKeyLink.ts
src/components/providers/forms/hooks/useApiKeyState.ts
src/components/providers/forms/hooks/useBaseUrlState.ts
src/components/providers/forms/hooks/useCodexCommonConfig.ts
src/components/providers/forms/hooks/useCodexConfigState.ts
src/components/providers/forms/hooks/useCodexTomlValidation.ts
src/components/providers/forms/hooks/useCommonConfigSnippet.ts
src/components/providers/forms/hooks/useCustomEndpoints.ts
src/components/providers/forms/hooks/useGeminiCommonConfig.ts
src/components/providers/forms/hooks/useGeminiConfigState.ts
src/components/providers/forms/hooks/useModelState.ts
src/components/providers/forms/hooks/useProviderCategory.ts
src/components/providers/forms/hooks/useSpeedTestEndpoints.ts
src/components/providers/forms/hooks/useTemplateValues.ts
src/components/providers/forms/ProviderForm.tsx
src/components/providers/forms/ProviderPresetSelector.tsx
src/components/providers/forms/shared/ApiKeySection.tsx
src/components/providers/forms/shared/EndpointField.tsx
src/components/providers/forms/shared/index.ts
src/components/providers/HealthStatusIndicator.tsx
src/components/providers/ProviderActions.tsx
src/components/providers/ProviderCard.tsx
src/components/providers/ProviderEmptyState.tsx
src/components/providers/ProviderHealthBadge.tsx
src/components/providers/ProviderList.tsx
src/components/ui/accordion.tsx
src/components/ui/alert.tsx
src/components/ui/badge.tsx
src/components/ui/button.tsx
src/components/ui/card.tsx
src/components/ui/checkbox.tsx
src/components/ui/dialog.tsx
src/components/ui/dropdown-menu.tsx
src/components/ui/form.tsx
src/components/ui/input.tsx
src/components/ui/label.tsx
src/components/ui/select.tsx
src/components/ui/sonner.tsx
src/components/ui/switch.tsx
src/components/ui/table.tsx
src/components/ui/tabs.tsx
src/components/ui/textarea.tsx
src/config/claudeProviderPresets.ts
src/config/codexProviderPresets.ts
src/config/geminiProviderPresets.ts
src/hooks/useProviderActions.ts
src/i18n/locales/en.json
src/i18n/locales/ja.json
src/i18n/locales/zh.json
src/lib/api/config.ts
src/lib/api/deeplink.ts
src/lib/api/env.ts
src/lib/api/failover.ts
src/lib/api/index.ts
src/lib/api/mcp.ts
src/lib/api/model-test.ts
src/lib/api/prompts.ts
src/lib/api/providers.ts
src/lib/api/settings.ts
src/lib/api/skills.ts
src/lib/api/types.ts
src/lib/api/usage.ts
src/lib/api/vscode.ts
src/lib/query/failover.ts
src/lib/query/index.ts
src/lib/query/mutations.ts
src/lib/query/queries.ts
src/lib/query/queryClient.ts
src/lib/query/usage.ts
src/types.ts
src/utils/errorUtils.ts
src/utils/formatters.ts
src/utils/postChangeSync.ts
src/utils/providerConfigUtils.ts
src/utils/providerMetaUtils.ts
src/utils/textNormalization.ts
src/utils/tomlUtils.ts
src/utils/uuid.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/components/providers/AddProviderDialog.tsx">
import { useCallback } from "react";
import { useTranslation } from "react-i18next";
import { Plus } from "lucide-react";
import { Button } from "@/components/ui/button";
import { FullScreenPanel } from "@/components/common/FullScreenPanel";
import type { Provider, CustomEndpoint } from "@/types";
import type { AppId } from "@/lib/api";
import {
  ProviderForm,
  type ProviderFormValues,
} from "@/components/providers/forms/ProviderForm";
import { providerPresets } from "@/config/claudeProviderPresets";
import { codexProviderPresets } from "@/config/codexProviderPresets";
import { geminiProviderPresets } from "@/config/geminiProviderPresets";

interface AddProviderDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  appId: AppId;
  onSubmit: (provider: Omit<Provider, "id">) => Promise<void> | void;
}

export function AddProviderDialog({
  open,
  onOpenChange,
  appId,
  onSubmit,
}: AddProviderDialogProps) {
  const { t } = useTranslation();

  const handleSubmit = useCallback(
    async (values: ProviderFormValues) => {
      const parsedConfig = JSON.parse(values.settingsConfig) as Record<
        string,
        unknown
      >;

      // 构造基础提交数据
      const providerData: Omit<Provider, "id"> = {
        name: values.name.trim(),
        notes: values.notes?.trim() || undefined,
        websiteUrl: values.websiteUrl?.trim() || undefined,
        settingsConfig: parsedConfig,
        icon: values.icon?.trim() || undefined,
        iconColor: values.iconColor?.trim() || undefined,
        ...(values.presetCategory ? { category: values.presetCategory } : {}),
        ...(values.meta ? { meta: values.meta } : {}),
      };

      const hasCustomEndpoints =
        providerData.meta?.custom_endpoints &&
        Object.keys(providerData.meta.custom_endpoints).length > 0;

      if (!hasCustomEndpoints) {
        // 收集端点候选（仅在缺少自定义端点时兜底）
        const urlSet = new Set<string>();

        const addUrl = (rawUrl?: string) => {
          const url = (rawUrl || "").trim().replace(/\/+$/, "");
          if (url && url.startsWith("http")) {
            urlSet.add(url);
          }
        };

        if (values.presetId) {
          if (appId === "claude") {
            const presets = providerPresets;
            const presetIndex = parseInt(
              values.presetId.replace("claude-", ""),
            );
            if (
              !isNaN(presetIndex) &&
              presetIndex >= 0 &&
              presetIndex < presets.length
            ) {
              const preset = presets[presetIndex];
              if (preset?.endpointCandidates) {
                preset.endpointCandidates.forEach(addUrl);
              }
            }
          } else if (appId === "codex") {
            const presets = codexProviderPresets;
            const presetIndex = parseInt(values.presetId.replace("codex-", ""));
            if (
              !isNaN(presetIndex) &&
              presetIndex >= 0 &&
              presetIndex < presets.length
            ) {
              const preset = presets[presetIndex];
              if (Array.isArray(preset.endpointCandidates)) {
                preset.endpointCandidates.forEach(addUrl);
              }
            }
          } else if (appId === "gemini") {
            const presets = geminiProviderPresets;
            const presetIndex = parseInt(
              values.presetId.replace("gemini-", ""),
            );
            if (
              !isNaN(presetIndex) &&
              presetIndex >= 0 &&
              presetIndex < presets.length
            ) {
              const preset = presets[presetIndex];
              if (Array.isArray(preset.endpointCandidates)) {
                preset.endpointCandidates.forEach(addUrl);
              }
            }
          }
        }

        if (appId === "claude") {
          const env = parsedConfig.env as Record<string, any> | undefined;
          if (env?.ANTHROPIC_BASE_URL) {
            addUrl(env.ANTHROPIC_BASE_URL);
          }
        } else if (appId === "codex") {
          const config = parsedConfig.config as string | undefined;
          if (config) {
            const baseUrlMatch = config.match(
              /base_url\s*=\s*["']([^"']+)["']/,
            );
            if (baseUrlMatch?.[1]) {
              addUrl(baseUrlMatch[1]);
            }
          }
        } else if (appId === "gemini") {
          const env = parsedConfig.env as Record<string, any> | undefined;
          if (env?.GOOGLE_GEMINI_BASE_URL) {
            addUrl(env.GOOGLE_GEMINI_BASE_URL);
          }
        }

        const urls = Array.from(urlSet);
        if (urls.length > 0) {
          const now = Date.now();
          const customEndpoints: Record<string, CustomEndpoint> = {};
          urls.forEach((url) => {
            customEndpoints[url] = {
              url,
              addedAt: now,
              lastUsed: undefined,
            };
          });

          providerData.meta = {
            ...(providerData.meta ?? {}),
            custom_endpoints: customEndpoints,
          };
        }
      }

      await onSubmit(providerData);
      onOpenChange(false);
    },
    [appId, onSubmit, onOpenChange],
  );

  const submitLabel =
    appId === "claude"
      ? t("provider.addClaudeProvider")
      : appId === "codex"
        ? t("provider.addCodexProvider")
        : t("provider.addGeminiProvider");

  const footer = (
    <>
      <Button
        variant="outline"
        onClick={() => onOpenChange(false)}
        className="border-border/20 hover:bg-accent hover:text-accent-foreground"
      >
        {t("common.cancel")}
      </Button>
      <Button
        type="submit"
        form="provider-form"
        className="bg-primary text-primary-foreground hover:bg-primary/90"
      >
        <Plus className="h-4 w-4 mr-2" />
        {t("common.add")}
      </Button>
    </>
  );

  return (
    <FullScreenPanel
      isOpen={open}
      title={submitLabel}
      onClose={() => onOpenChange(false)}
      footer={footer}
    >
      <ProviderForm
        appId={appId}
        submitLabel={t("common.add")}
        onSubmit={handleSubmit}
        onCancel={() => onOpenChange(false)}
        showButtons={false}
      />
    </FullScreenPanel>
  );
}
</file>

<file path="src/components/providers/forms/ClaudeFormFields.tsx">
import { useTranslation } from "react-i18next";
import { FormLabel } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import EndpointSpeedTest from "./EndpointSpeedTest";
import { ApiKeySection, EndpointField } from "./shared";
import type { ProviderCategory } from "@/types";
import type { TemplateValueConfig } from "@/config/claudeProviderPresets";

interface EndpointCandidate {
  url: string;
}

interface ClaudeFormFieldsProps {
  providerId?: string;
  // API Key
  shouldShowApiKey: boolean;
  apiKey: string;
  onApiKeyChange: (key: string) => void;
  category?: ProviderCategory;
  shouldShowApiKeyLink: boolean;
  websiteUrl: string;
  isPartner?: boolean;
  partnerPromotionKey?: string;

  // Template Values
  templateValueEntries: Array<[string, TemplateValueConfig]>;
  templateValues: Record<string, TemplateValueConfig>;
  templatePresetName: string;
  onTemplateValueChange: (key: string, value: string) => void;

  // Base URL
  shouldShowSpeedTest: boolean;
  baseUrl: string;
  onBaseUrlChange: (url: string) => void;
  isEndpointModalOpen: boolean;
  onEndpointModalToggle: (open: boolean) => void;
  onCustomEndpointsChange?: (endpoints: string[]) => void;

  // Model Selector
  shouldShowModelSelector: boolean;
  claudeModel: string;
  defaultHaikuModel: string;
  defaultSonnetModel: string;
  defaultOpusModel: string;
  onModelChange: (
    field:
      | "ANTHROPIC_MODEL"
      | "ANTHROPIC_DEFAULT_HAIKU_MODEL"
      | "ANTHROPIC_DEFAULT_SONNET_MODEL"
      | "ANTHROPIC_DEFAULT_OPUS_MODEL",
    value: string,
  ) => void;

  // Speed Test Endpoints
  speedTestEndpoints: EndpointCandidate[];
}

export function ClaudeFormFields({
  providerId,
  shouldShowApiKey,
  apiKey,
  onApiKeyChange,
  category,
  shouldShowApiKeyLink,
  websiteUrl,
  isPartner,
  partnerPromotionKey,
  templateValueEntries,
  templateValues,
  templatePresetName,
  onTemplateValueChange,
  shouldShowSpeedTest,
  baseUrl,
  onBaseUrlChange,
  isEndpointModalOpen,
  onEndpointModalToggle,
  onCustomEndpointsChange,
  shouldShowModelSelector,
  claudeModel,
  defaultHaikuModel,
  defaultSonnetModel,
  defaultOpusModel,
  onModelChange,
  speedTestEndpoints,
}: ClaudeFormFieldsProps) {
  const { t } = useTranslation();

  return (
    <>
      {/* API Key 输入框 */}
      {shouldShowApiKey && (
        <ApiKeySection
          value={apiKey}
          onChange={onApiKeyChange}
          category={category}
          shouldShowLink={shouldShowApiKeyLink}
          websiteUrl={websiteUrl}
          isPartner={isPartner}
          partnerPromotionKey={partnerPromotionKey}
        />
      )}

      {/* 模板变量输入 */}
      {templateValueEntries.length > 0 && (
        <div className="space-y-3">
          <FormLabel>
            {t("providerForm.parameterConfig", {
              name: templatePresetName,
              defaultValue: `${templatePresetName} 参数配置`,
            })}
          </FormLabel>
          <div className="space-y-4">
            {templateValueEntries.map(([key, config]) => (
              <div key={key} className="space-y-2">
                <FormLabel htmlFor={`template-${key}`}>
                  {config.label}
                </FormLabel>
                <Input
                  id={`template-${key}`}
                  type="text"
                  required
                  value={
                    templateValues[key]?.editorValue ??
                    config.editorValue ??
                    config.defaultValue ??
                    ""
                  }
                  onChange={(e) => onTemplateValueChange(key, e.target.value)}
                  placeholder={config.placeholder || config.label}
                  autoComplete="off"
                />
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Base URL 输入框 */}
      {shouldShowSpeedTest && (
        <EndpointField
          id="baseUrl"
          label={t("providerForm.apiEndpoint")}
          value={baseUrl}
          onChange={onBaseUrlChange}
          placeholder={t("providerForm.apiEndpointPlaceholder")}
          hint={t("providerForm.apiHint")}
          onManageClick={() => onEndpointModalToggle(true)}
        />
      )}

      {/* 端点测速弹窗 */}
      {shouldShowSpeedTest && isEndpointModalOpen && (
        <EndpointSpeedTest
          appId="claude"
          providerId={providerId}
          value={baseUrl}
          onChange={onBaseUrlChange}
          initialEndpoints={speedTestEndpoints}
          visible={isEndpointModalOpen}
          onClose={() => onEndpointModalToggle(false)}
          onCustomEndpointsChange={onCustomEndpointsChange}
        />
      )}

      {/* 模型选择器 */}
      {shouldShowModelSelector && (
        <div className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {/* 主模型 */}
            <div className="space-y-2">
              <FormLabel htmlFor="claudeModel">
                {t("providerForm.anthropicModel", { defaultValue: "主模型" })}
              </FormLabel>
              <Input
                id="claudeModel"
                type="text"
                value={claudeModel}
                onChange={(e) =>
                  onModelChange("ANTHROPIC_MODEL", e.target.value)
                }
                placeholder={t("providerForm.modelPlaceholder", {
                  defaultValue: "",
                })}
                autoComplete="off"
              />
            </div>

            {/* 默认 Haiku */}
            <div className="space-y-2">
              <FormLabel htmlFor="claudeDefaultHaikuModel">
                {t("providerForm.anthropicDefaultHaikuModel", {
                  defaultValue: "Haiku 默认模型",
                })}
              </FormLabel>
              <Input
                id="claudeDefaultHaikuModel"
                type="text"
                value={defaultHaikuModel}
                onChange={(e) =>
                  onModelChange("ANTHROPIC_DEFAULT_HAIKU_MODEL", e.target.value)
                }
                placeholder={t("providerForm.haikuModelPlaceholder", {
                  defaultValue: "",
                })}
                autoComplete="off"
              />
            </div>

            {/* 默认 Sonnet */}
            <div className="space-y-2">
              <FormLabel htmlFor="claudeDefaultSonnetModel">
                {t("providerForm.anthropicDefaultSonnetModel", {
                  defaultValue: "Sonnet 默认模型",
                })}
              </FormLabel>
              <Input
                id="claudeDefaultSonnetModel"
                type="text"
                value={defaultSonnetModel}
                onChange={(e) =>
                  onModelChange(
                    "ANTHROPIC_DEFAULT_SONNET_MODEL",
                    e.target.value,
                  )
                }
                placeholder={t("providerForm.modelPlaceholder", {
                  defaultValue: "",
                })}
                autoComplete="off"
              />
            </div>

            {/* 默认 Opus */}
            <div className="space-y-2">
              <FormLabel htmlFor="claudeDefaultOpusModel">
                {t("providerForm.anthropicDefaultOpusModel", {
                  defaultValue: "Opus 默认模型",
                })}
              </FormLabel>
              <Input
                id="claudeDefaultOpusModel"
                type="text"
                value={defaultOpusModel}
                onChange={(e) =>
                  onModelChange("ANTHROPIC_DEFAULT_OPUS_MODEL", e.target.value)
                }
                placeholder={t("providerForm.modelPlaceholder", {
                  defaultValue: "",
                })}
                autoComplete="off"
              />
            </div>
          </div>
          <p className="text-xs text-muted-foreground">
            {t("providerForm.modelHelper", {
              defaultValue:
                "可选：指定默认使用的 Claude 模型，留空则使用系统默认。",
            })}
          </p>
        </div>
      )}
    </>
  );
}
</file>

<file path="src/components/providers/forms/CodexCommonConfigModal.tsx">
import React, { useEffect, useState } from "react";
import { Save } from "lucide-react";
import { useTranslation } from "react-i18next";
import { FullScreenPanel } from "@/components/common/FullScreenPanel";
import { Button } from "@/components/ui/button";
import JsonEditor from "@/components/JsonEditor";

interface CodexCommonConfigModalProps {
  isOpen: boolean;
  onClose: () => void;
  value: string;
  onChange: (value: string) => void;
  error?: string;
}

/**
 * CodexCommonConfigModal - Common Codex configuration editor modal
 * Allows editing of common TOML configuration shared across providers
 */
export const CodexCommonConfigModal: React.FC<CodexCommonConfigModalProps> = ({
  isOpen,
  onClose,
  value,
  onChange,
  error,
}) => {
  const { t } = useTranslation();
  const [isDarkMode, setIsDarkMode] = useState(false);

  useEffect(() => {
    setIsDarkMode(document.documentElement.classList.contains("dark"));

    const observer = new MutationObserver(() => {
      setIsDarkMode(document.documentElement.classList.contains("dark"));
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });

    return () => observer.disconnect();
  }, []);

  return (
    <FullScreenPanel
      isOpen={isOpen}
      title={t("codexConfig.editCommonConfigTitle")}
      onClose={onClose}
      footer={
        <>
          <Button type="button" variant="outline" onClick={onClose}>
            {t("common.cancel")}
          </Button>
          <Button type="button" onClick={onClose} className="gap-2">
            <Save className="w-4 h-4" />
            {t("common.save")}
          </Button>
        </>
      }
    >
      <div className="space-y-4">
        <p className="text-sm text-muted-foreground">
          {t("codexConfig.commonConfigHint")}
        </p>

        <JsonEditor
          value={value}
          onChange={onChange}
          placeholder={`# Common Codex config

# Add your common TOML configuration here`}
          darkMode={isDarkMode}
          rows={16}
          showValidation={false}
          language="javascript"
        />

        {error && (
          <p className="text-sm text-red-500 dark:text-red-400">{error}</p>
        )}
      </div>
    </FullScreenPanel>
  );
};
</file>

<file path="src/components/providers/forms/CodexConfigEditor.tsx">
import React, { useState, useEffect } from "react";
import { CodexAuthSection, CodexConfigSection } from "./CodexConfigSections";
import { CodexCommonConfigModal } from "./CodexCommonConfigModal";

interface CodexConfigEditorProps {
  authValue: string;

  configValue: string;

  onAuthChange: (value: string) => void;

  onConfigChange: (value: string) => void;

  onAuthBlur?: () => void;

  useCommonConfig: boolean;

  onCommonConfigToggle: (checked: boolean) => void;

  commonConfigSnippet: string;

  onCommonConfigSnippetChange: (value: string) => void;

  commonConfigError: string;

  authError: string;

  configError: string; // config.toml 错误提示
}

const CodexConfigEditor: React.FC<CodexConfigEditorProps> = ({
  authValue,
  configValue,
  onAuthChange,
  onConfigChange,
  onAuthBlur,
  useCommonConfig,
  onCommonConfigToggle,
  commonConfigSnippet,
  onCommonConfigSnippetChange,
  commonConfigError,
  authError,
  configError,
}) => {
  const [isCommonConfigModalOpen, setIsCommonConfigModalOpen] = useState(false);

  // Auto-open common config modal if there's an error
  useEffect(() => {
    if (commonConfigError && !isCommonConfigModalOpen) {
      setIsCommonConfigModalOpen(true);
    }
  }, [commonConfigError, isCommonConfigModalOpen]);

  return (
    <div className="space-y-6">
      {/* Auth JSON Section */}
      <CodexAuthSection
        value={authValue}
        onChange={onAuthChange}
        onBlur={onAuthBlur}
        error={authError}
      />

      {/* Config TOML Section */}
      <CodexConfigSection
        value={configValue}
        onChange={onConfigChange}
        useCommonConfig={useCommonConfig}
        onCommonConfigToggle={onCommonConfigToggle}
        onEditCommonConfig={() => setIsCommonConfigModalOpen(true)}
        commonConfigError={commonConfigError}
        configError={configError}
      />

      {/* Common Config Modal */}
      <CodexCommonConfigModal
        isOpen={isCommonConfigModalOpen}
        onClose={() => setIsCommonConfigModalOpen(false)}
        value={commonConfigSnippet}
        onChange={onCommonConfigSnippetChange}
        error={commonConfigError}
      />
    </div>
  );
};

export default CodexConfigEditor;
</file>

<file path="src/components/providers/forms/CodexConfigSections.tsx">
import React, { useEffect, useState } from "react";
import { useTranslation } from "react-i18next";
import JsonEditor from "@/components/JsonEditor";

interface CodexAuthSectionProps {
  value: string;
  onChange: (value: string) => void;
  onBlur?: () => void;
  error?: string;
}

/**
 * CodexAuthSection - Auth JSON editor section
 */
export const CodexAuthSection: React.FC<CodexAuthSectionProps> = ({
  value,
  onChange,
  onBlur,
  error,
}) => {
  const { t } = useTranslation();
  const [isDarkMode, setIsDarkMode] = useState(false);

  useEffect(() => {
    setIsDarkMode(document.documentElement.classList.contains("dark"));

    const observer = new MutationObserver(() => {
      setIsDarkMode(document.documentElement.classList.contains("dark"));
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });

    return () => observer.disconnect();
  }, []);

  const handleChange = (newValue: string) => {
    onChange(newValue);
    if (onBlur) {
      onBlur();
    }
  };

  return (
    <div className="space-y-2">
      <label
        htmlFor="codexAuth"
        className="block text-sm font-medium text-gray-900 dark:text-gray-100"
      >
        {t("codexConfig.authJson")}
      </label>

      <JsonEditor
        value={value}
        onChange={handleChange}
        placeholder={t("codexConfig.authJsonPlaceholder")}
        darkMode={isDarkMode}
        rows={6}
        showValidation={true}
        language="json"
      />

      {error && (
        <p className="text-xs text-red-500 dark:text-red-400">{error}</p>
      )}

      {!error && (
        <p className="text-xs text-gray-500 dark:text-gray-400">
          {t("codexConfig.authJsonHint")}
        </p>
      )}
    </div>
  );
};

interface CodexConfigSectionProps {
  value: string;
  onChange: (value: string) => void;
  useCommonConfig: boolean;
  onCommonConfigToggle: (checked: boolean) => void;
  onEditCommonConfig: () => void;
  commonConfigError?: string;
  configError?: string;
}

/**
 * CodexConfigSection - Config TOML editor section
 */
export const CodexConfigSection: React.FC<CodexConfigSectionProps> = ({
  value,
  onChange,
  useCommonConfig,
  onCommonConfigToggle,
  onEditCommonConfig,
  commonConfigError,
  configError,
}) => {
  const { t } = useTranslation();
  const [isDarkMode, setIsDarkMode] = useState(false);

  useEffect(() => {
    setIsDarkMode(document.documentElement.classList.contains("dark"));

    const observer = new MutationObserver(() => {
      setIsDarkMode(document.documentElement.classList.contains("dark"));
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });

    return () => observer.disconnect();
  }, []);

  return (
    <div className="space-y-2">
      <div className="flex items-center justify-between">
        <label
          htmlFor="codexConfig"
          className="block text-sm font-medium text-gray-900 dark:text-gray-100"
        >
          {t("codexConfig.configToml")}
        </label>

        <label className="inline-flex items-center gap-2 text-sm text-gray-500 dark:text-gray-400 cursor-pointer">
          <input
            type="checkbox"
            checked={useCommonConfig}
            onChange={(e) => onCommonConfigToggle(e.target.checked)}
            className="w-4 h-4 text-blue-500 bg-white dark:bg-gray-800 border-border-default  rounded focus:ring-blue-500 dark:focus:ring-blue-400 focus:ring-2"
          />
          {t("codexConfig.writeCommonConfig")}
        </label>
      </div>

      <div className="flex items-center justify-end">
        <button
          type="button"
          onClick={onEditCommonConfig}
          className="text-xs text-blue-500 dark:text-blue-400 hover:underline"
        >
          {t("codexConfig.editCommonConfig")}
        </button>
      </div>

      {commonConfigError && (
        <p className="text-xs text-red-500 dark:text-red-400 text-right">
          {commonConfigError}
        </p>
      )}

      <JsonEditor
        value={value}
        onChange={onChange}
        placeholder=""
        darkMode={isDarkMode}
        rows={8}
        showValidation={false}
        language="javascript"
      />

      {configError && (
        <p className="text-xs text-red-500 dark:text-red-400">{configError}</p>
      )}

      {!configError && (
        <p className="text-xs text-gray-500 dark:text-gray-400">
          {t("codexConfig.configTomlHint")}
        </p>
      )}
    </div>
  );
};
</file>

<file path="src/components/providers/forms/CodexFormFields.tsx">
import { useTranslation } from "react-i18next";
import EndpointSpeedTest from "./EndpointSpeedTest";
import { ApiKeySection, EndpointField } from "./shared";
import type { ProviderCategory } from "@/types";

interface EndpointCandidate {
  url: string;
}

interface CodexFormFieldsProps {
  providerId?: string;
  // API Key
  codexApiKey: string;
  onApiKeyChange: (key: string) => void;
  category?: ProviderCategory;
  shouldShowApiKeyLink: boolean;
  websiteUrl: string;
  isPartner?: boolean;
  partnerPromotionKey?: string;

  // Base URL
  shouldShowSpeedTest: boolean;
  codexBaseUrl: string;
  onBaseUrlChange: (url: string) => void;
  isEndpointModalOpen: boolean;
  onEndpointModalToggle: (open: boolean) => void;
  onCustomEndpointsChange?: (endpoints: string[]) => void;

  // Model Name
  shouldShowModelField?: boolean;
  modelName?: string;
  onModelNameChange?: (model: string) => void;

  // Speed Test Endpoints
  speedTestEndpoints: EndpointCandidate[];
}

export function CodexFormFields({
  providerId,
  codexApiKey,
  onApiKeyChange,
  category,
  shouldShowApiKeyLink,
  websiteUrl,
  isPartner,
  partnerPromotionKey,
  shouldShowSpeedTest,
  codexBaseUrl,
  onBaseUrlChange,
  isEndpointModalOpen,
  onEndpointModalToggle,
  onCustomEndpointsChange,
  shouldShowModelField = true,
  modelName = "",
  onModelNameChange,
  speedTestEndpoints,
}: CodexFormFieldsProps) {
  const { t } = useTranslation();

  return (
    <>
      {/* Codex API Key 输入框 */}
      <ApiKeySection
        id="codexApiKey"
        label="API Key"
        value={codexApiKey}
        onChange={onApiKeyChange}
        category={category}
        shouldShowLink={shouldShowApiKeyLink}
        websiteUrl={websiteUrl}
        isPartner={isPartner}
        partnerPromotionKey={partnerPromotionKey}
        placeholder={{
          official: t("providerForm.codexOfficialNoApiKey", {
            defaultValue: "官方供应商无需 API Key",
          }),
          thirdParty: t("providerForm.codexApiKeyAutoFill", {
            defaultValue: "输入 API Key，将自动填充到配置",
          }),
        }}
      />

      {/* Codex Base URL 输入框 */}
      {shouldShowSpeedTest && (
        <EndpointField
          id="codexBaseUrl"
          label={t("codexConfig.apiUrlLabel")}
          value={codexBaseUrl}
          onChange={onBaseUrlChange}
          placeholder={t("providerForm.codexApiEndpointPlaceholder")}
          hint={t("providerForm.codexApiHint")}
          onManageClick={() => onEndpointModalToggle(true)}
        />
      )}

      {/* Codex Model Name 输入框 */}
      {shouldShowModelField && onModelNameChange && (
        <div className="space-y-2">
          <label
            htmlFor="codexModelName"
            className="block text-sm font-medium text-gray-900 dark:text-gray-100"
          >
            {t("codexConfig.modelName", { defaultValue: "模型名称" })}
          </label>
          <input
            id="codexModelName"
            type="text"
            value={modelName}
            onChange={(e) => onModelNameChange(e.target.value)}
            placeholder={t("codexConfig.modelNamePlaceholder", {
              defaultValue: "例如: gpt-5-codex",
            })}
            className="w-full px-3 py-2 border border-border-default dark:bg-gray-800 dark:text-gray-100 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500/20 dark:focus:ring-blue-400/20 transition-colors"
          />
          <p className="text-xs text-gray-500 dark:text-gray-400">
            {t("codexConfig.modelNameHint", {
              defaultValue: "指定使用的模型，将自动更新到 config.toml 中",
            })}
          </p>
        </div>
      )}

      {/* 端点测速弹窗 - Codex */}
      {shouldShowSpeedTest && isEndpointModalOpen && (
        <EndpointSpeedTest
          appId="codex"
          providerId={providerId}
          value={codexBaseUrl}
          onChange={onBaseUrlChange}
          initialEndpoints={speedTestEndpoints}
          visible={isEndpointModalOpen}
          onClose={() => onEndpointModalToggle(false)}
          onCustomEndpointsChange={onCustomEndpointsChange}
        />
      )}
    </>
  );
}
</file>

<file path="src/components/providers/forms/CommonConfigEditor.tsx">
import { useTranslation } from "react-i18next";
import { useEffect, useState } from "react";
import { FullScreenPanel } from "@/components/common/FullScreenPanel";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Save } from "lucide-react";
import JsonEditor from "@/components/JsonEditor";

interface CommonConfigEditorProps {
  value: string;
  onChange: (value: string) => void;
  useCommonConfig: boolean;
  onCommonConfigToggle: (checked: boolean) => void;
  commonConfigSnippet: string;
  onCommonConfigSnippetChange: (value: string) => void;
  commonConfigError: string;
  onEditClick: () => void;
  isModalOpen: boolean;
  onModalClose: () => void;
}

export function CommonConfigEditor({
  value,
  onChange,
  useCommonConfig,
  onCommonConfigToggle,
  commonConfigSnippet,
  onCommonConfigSnippetChange,
  commonConfigError,
  onEditClick,
  isModalOpen,
  onModalClose,
}: CommonConfigEditorProps) {
  const { t } = useTranslation();
  const [isDarkMode, setIsDarkMode] = useState(false);

  useEffect(() => {
    setIsDarkMode(document.documentElement.classList.contains("dark"));

    const observer = new MutationObserver(() => {
      setIsDarkMode(document.documentElement.classList.contains("dark"));
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });

    return () => observer.disconnect();
  }, []);

  return (
    <>
      <div className="space-y-2">
        <div className="flex items-center justify-between">
          <Label htmlFor="settingsConfig">{t("provider.configJson")}</Label>
          <div className="flex items-center gap-2">
            <label className="inline-flex items-center gap-2 text-sm text-muted-foreground cursor-pointer">
              <input
                type="checkbox"
                id="useCommonConfig"
                checked={useCommonConfig}
                onChange={(e) => onCommonConfigToggle(e.target.checked)}
                className="w-4 h-4 text-blue-500 bg-white dark:bg-gray-800 border-border-default rounded focus:ring-blue-500 dark:focus:ring-blue-400 focus:ring-2"
              />
              <span>
                {t("claudeConfig.writeCommonConfig", {
                  defaultValue: "写入通用配置",
                })}
              </span>
            </label>
          </div>
        </div>
        <div className="flex items-center justify-end">
          <button
            type="button"
            onClick={onEditClick}
            className="text-xs text-blue-400 dark:text-blue-500 hover:text-blue-500 dark:hover:text-blue-400 transition-colors"
          >
            {t("claudeConfig.editCommonConfig", {
              defaultValue: "编辑通用配置",
            })}
          </button>
        </div>
        {commonConfigError && !isModalOpen && (
          <p className="text-xs text-red-500 dark:text-red-400 text-right">
            {commonConfigError}
          </p>
        )}
        <JsonEditor
          value={value}
          onChange={onChange}
          placeholder={`{
  "env": {
    "ANTHROPIC_BASE_URL": "https://your-api-endpoint.com",
    "ANTHROPIC_AUTH_TOKEN": "your-api-key-here"
  }
}`}
          darkMode={isDarkMode}
          rows={14}
          showValidation={true}
          language="json"
        />
      </div>

      <FullScreenPanel
        isOpen={isModalOpen}
        title={t("claudeConfig.editCommonConfigTitle", {
          defaultValue: "编辑通用配置片段",
        })}
        onClose={onModalClose}
        footer={
          <>
            <Button type="button" variant="outline" onClick={onModalClose}>
              {t("common.cancel")}
            </Button>
            <Button type="button" onClick={onModalClose} className="gap-2">
              <Save className="w-4 h-4" />
              {t("common.save")}
            </Button>
          </>
        }
      >
        <div className="space-y-4">
          <p className="text-sm text-muted-foreground">
            {t("claudeConfig.commonConfigHint", {
              defaultValue: "通用配置片段将合并到所有启用它的供应商配置中",
            })}
          </p>
          <JsonEditor
            value={commonConfigSnippet}
            onChange={onCommonConfigSnippetChange}
            placeholder={`{
  "env": {
    "ANTHROPIC_BASE_URL": "https://your-api-endpoint.com"
  }
}`}
            darkMode={isDarkMode}
            rows={16}
            showValidation={true}
            language="json"
          />
          {commonConfigError && (
            <p className="text-sm text-red-500 dark:text-red-400">
              {commonConfigError}
            </p>
          )}
        </div>
      </FullScreenPanel>
    </>
  );
}
</file>

<file path="src/components/providers/forms/GeminiCommonConfigModal.tsx">
import React, { useEffect, useState } from "react";
import { Save } from "lucide-react";
import { useTranslation } from "react-i18next";
import { FullScreenPanel } from "@/components/common/FullScreenPanel";
import { Button } from "@/components/ui/button";
import JsonEditor from "@/components/JsonEditor";

interface GeminiCommonConfigModalProps {
  isOpen: boolean;
  onClose: () => void;
  value: string;
  onChange: (value: string) => void;
  error?: string;
}

/**
 * GeminiCommonConfigModal - Common Gemini configuration editor modal
 * Allows editing of common JSON configuration shared across Gemini providers
 */
export const GeminiCommonConfigModal: React.FC<
  GeminiCommonConfigModalProps
> = ({ isOpen, onClose, value, onChange, error }) => {
  const { t } = useTranslation();
  const [isDarkMode, setIsDarkMode] = useState(false);

  useEffect(() => {
    setIsDarkMode(document.documentElement.classList.contains("dark"));

    const observer = new MutationObserver(() => {
      setIsDarkMode(document.documentElement.classList.contains("dark"));
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });

    return () => observer.disconnect();
  }, []);

  return (
    <FullScreenPanel
      isOpen={isOpen}
      title={t("geminiConfig.editCommonConfigTitle", {
        defaultValue: "编辑 Gemini 通用配置片段",
      })}
      onClose={onClose}
      footer={
        <>
          <Button type="button" variant="outline" onClick={onClose}>
            {t("common.cancel")}
          </Button>
          <Button type="button" onClick={onClose} className="gap-2">
            <Save className="w-4 h-4" />
            {t("common.save")}
          </Button>
        </>
      }
    >
      <div className="space-y-4">
        <p className="text-sm text-muted-foreground">
          {t("geminiConfig.commonConfigHint", {
            defaultValue:
              "通用配置片段将合并到所有启用它的 Gemini 供应商配置中",
          })}
        </p>

        <JsonEditor
          value={value}
          onChange={onChange}
          placeholder={`{
  "timeout": 30000,
  "maxRetries": 3,
  "customField": "value"
}`}
          darkMode={isDarkMode}
          rows={16}
          showValidation={true}
          language="json"
        />

        {error && (
          <p className="text-sm text-red-500 dark:text-red-400">{error}</p>
        )}
      </div>
    </FullScreenPanel>
  );
};
</file>

<file path="src/components/providers/forms/GeminiConfigEditor.tsx">
import React, { useState, useEffect } from "react";
import { GeminiEnvSection, GeminiConfigSection } from "./GeminiConfigSections";
import { GeminiCommonConfigModal } from "./GeminiCommonConfigModal";

interface GeminiConfigEditorProps {
  envValue: string;
  configValue: string;
  onEnvChange: (value: string) => void;
  onConfigChange: (value: string) => void;
  onEnvBlur?: () => void;
  useCommonConfig: boolean;
  onCommonConfigToggle: (checked: boolean) => void;
  commonConfigSnippet: string;
  onCommonConfigSnippetChange: (value: string) => void;
  commonConfigError: string;
  envError: string;
  configError: string;
}

const GeminiConfigEditor: React.FC<GeminiConfigEditorProps> = ({
  envValue,
  configValue,
  onEnvChange,
  onConfigChange,
  onEnvBlur,
  useCommonConfig,
  onCommonConfigToggle,
  commonConfigSnippet,
  onCommonConfigSnippetChange,
  commonConfigError,
  envError,
  configError,
}) => {
  const [isCommonConfigModalOpen, setIsCommonConfigModalOpen] = useState(false);

  // Auto-open common config modal if there's an error
  useEffect(() => {
    if (commonConfigError && !isCommonConfigModalOpen) {
      setIsCommonConfigModalOpen(true);
    }
  }, [commonConfigError, isCommonConfigModalOpen]);

  return (
    <div className="space-y-6">
      {/* Env Section */}
      <GeminiEnvSection
        value={envValue}
        onChange={onEnvChange}
        onBlur={onEnvBlur}
        error={envError}
      />

      {/* Config JSON Section */}
      <GeminiConfigSection
        value={configValue}
        onChange={onConfigChange}
        useCommonConfig={useCommonConfig}
        onCommonConfigToggle={onCommonConfigToggle}
        onEditCommonConfig={() => setIsCommonConfigModalOpen(true)}
        commonConfigError={commonConfigError}
        configError={configError}
      />

      {/* Common Config Modal */}
      <GeminiCommonConfigModal
        isOpen={isCommonConfigModalOpen}
        onClose={() => setIsCommonConfigModalOpen(false)}
        value={commonConfigSnippet}
        onChange={onCommonConfigSnippetChange}
        error={commonConfigError}
      />
    </div>
  );
};

export default GeminiConfigEditor;
</file>

<file path="src/components/providers/forms/GeminiConfigSections.tsx">
import React, { useEffect, useState } from "react";
import { useTranslation } from "react-i18next";
import JsonEditor from "@/components/JsonEditor";

interface GeminiEnvSectionProps {
  value: string;
  onChange: (value: string) => void;
  onBlur?: () => void;
  error?: string;
}

/**
 * GeminiEnvSection - .env editor section for Gemini environment variables
 */
export const GeminiEnvSection: React.FC<GeminiEnvSectionProps> = ({
  value,
  onChange,
  onBlur,
  error,
}) => {
  const { t } = useTranslation();
  const [isDarkMode, setIsDarkMode] = useState(false);

  useEffect(() => {
    setIsDarkMode(document.documentElement.classList.contains("dark"));

    const observer = new MutationObserver(() => {
      setIsDarkMode(document.documentElement.classList.contains("dark"));
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });

    return () => observer.disconnect();
  }, []);

  const handleChange = (newValue: string) => {
    onChange(newValue);
    if (onBlur) {
      onBlur();
    }
  };

  return (
    <div className="space-y-2">
      <label
        htmlFor="geminiEnv"
        className="block text-sm font-medium text-gray-900 dark:text-gray-100"
      >
        {t("geminiConfig.envFile", { defaultValue: "环境变量 (.env)" })}
      </label>

      <JsonEditor
        value={value}
        onChange={handleChange}
        placeholder={`GOOGLE_GEMINI_BASE_URL=https://your-api-endpoint.com/
GEMINI_API_KEY=sk-your-api-key-here
GEMINI_MODEL=gemini-3-pro-preview`}
        darkMode={isDarkMode}
        rows={6}
        showValidation={false}
        language="javascript"
      />

      {error && (
        <p className="text-xs text-red-500 dark:text-red-400">{error}</p>
      )}

      {!error && (
        <p className="text-xs text-gray-500 dark:text-gray-400">
          {t("geminiConfig.envFileHint", {
            defaultValue: "使用 .env 格式配置 Gemini 环境变量",
          })}
        </p>
      )}
    </div>
  );
};

interface GeminiConfigSectionProps {
  value: string;
  onChange: (value: string) => void;
  useCommonConfig: boolean;
  onCommonConfigToggle: (checked: boolean) => void;
  onEditCommonConfig: () => void;
  commonConfigError?: string;
  configError?: string;
}

/**
 * GeminiConfigSection - Config JSON editor section with common config support
 */
export const GeminiConfigSection: React.FC<GeminiConfigSectionProps> = ({
  value,
  onChange,
  useCommonConfig,
  onCommonConfigToggle,
  onEditCommonConfig,
  commonConfigError,
  configError,
}) => {
  const { t } = useTranslation();
  const [isDarkMode, setIsDarkMode] = useState(false);

  useEffect(() => {
    setIsDarkMode(document.documentElement.classList.contains("dark"));

    const observer = new MutationObserver(() => {
      setIsDarkMode(document.documentElement.classList.contains("dark"));
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });

    return () => observer.disconnect();
  }, []);

  return (
    <div className="space-y-2">
      <div className="flex items-center justify-between">
        <label
          htmlFor="geminiConfig"
          className="block text-sm font-medium text-gray-900 dark:text-gray-100"
        >
          {t("geminiConfig.configJson", {
            defaultValue: "配置文件 (config.json)",
          })}
        </label>

        <label className="inline-flex items-center gap-2 text-sm text-gray-500 dark:text-gray-400 cursor-pointer">
          <input
            type="checkbox"
            checked={useCommonConfig}
            onChange={(e) => onCommonConfigToggle(e.target.checked)}
            className="w-4 h-4 text-blue-500 bg-white dark:bg-gray-800 border-border-default rounded focus:ring-blue-500 dark:focus:ring-blue-400 focus:ring-2"
          />
          {t("geminiConfig.writeCommonConfig", {
            defaultValue: "写入通用配置",
          })}
        </label>
      </div>

      <div className="flex items-center justify-end">
        <button
          type="button"
          onClick={onEditCommonConfig}
          className="text-xs text-blue-500 dark:text-blue-400 hover:underline"
        >
          {t("geminiConfig.editCommonConfig", {
            defaultValue: "编辑通用配置",
          })}
        </button>
      </div>

      {commonConfigError && (
        <p className="text-xs text-red-500 dark:text-red-400 text-right">
          {commonConfigError}
        </p>
      )}

      <JsonEditor
        value={value}
        onChange={onChange}
        placeholder={`{
  "timeout": 30000,
  "maxRetries": 3
}`}
        darkMode={isDarkMode}
        rows={8}
        showValidation={true}
        language="json"
      />

      {configError && (
        <p className="text-xs text-red-500 dark:text-red-400">{configError}</p>
      )}

      {!configError && (
        <p className="text-xs text-gray-500 dark:text-gray-400">
          {t("geminiConfig.configJsonHint", {
            defaultValue: "使用 JSON 格式配置 Gemini 扩展参数（可选）",
          })}
        </p>
      )}
    </div>
  );
};
</file>

<file path="src/components/providers/forms/GeminiFormFields.tsx">
import { useTranslation } from "react-i18next";
import { FormLabel } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Info } from "lucide-react";
import EndpointSpeedTest from "./EndpointSpeedTest";
import { ApiKeySection, EndpointField } from "./shared";
import type { ProviderCategory } from "@/types";

interface EndpointCandidate {
  url: string;
}

interface GeminiFormFieldsProps {
  providerId?: string;
  // API Key
  shouldShowApiKey: boolean;
  apiKey: string;
  onApiKeyChange: (key: string) => void;
  category?: ProviderCategory;
  shouldShowApiKeyLink: boolean;
  websiteUrl: string;
  isPartner?: boolean;
  partnerPromotionKey?: string;

  // Base URL
  shouldShowSpeedTest: boolean;
  baseUrl: string;
  onBaseUrlChange: (url: string) => void;
  isEndpointModalOpen: boolean;
  onEndpointModalToggle: (open: boolean) => void;
  onCustomEndpointsChange: (endpoints: string[]) => void;

  // Model
  shouldShowModelField: boolean;
  model: string;
  onModelChange: (value: string) => void;

  // Speed Test Endpoints
  speedTestEndpoints: EndpointCandidate[];
}

export function GeminiFormFields({
  providerId,
  shouldShowApiKey,
  apiKey,
  onApiKeyChange,
  category,
  shouldShowApiKeyLink,
  websiteUrl,
  isPartner,
  partnerPromotionKey,
  shouldShowSpeedTest,
  baseUrl,
  onBaseUrlChange,
  isEndpointModalOpen,
  onEndpointModalToggle,
  onCustomEndpointsChange,
  shouldShowModelField,
  model,
  onModelChange,
  speedTestEndpoints,
}: GeminiFormFieldsProps) {
  const { t } = useTranslation();

  // 检测是否为 Google 官方（使用 OAuth）
  const isGoogleOfficial =
    partnerPromotionKey?.toLowerCase() === "google-official";

  return (
    <>
      {/* Google OAuth 提示 */}
      {isGoogleOfficial && (
        <div className="rounded-lg border border-blue-200 bg-blue-50 p-4 dark:border-blue-800 dark:bg-blue-950">
          <div className="flex gap-3">
            <Info className="h-5 w-5 flex-shrink-0 text-blue-600 dark:text-blue-400" />
            <div className="space-y-1">
              <p className="text-sm font-medium text-blue-900 dark:text-blue-100">
                {t("provider.form.gemini.oauthTitle", {
                  defaultValue: "OAuth 认证模式",
                })}
              </p>
              <p className="text-sm text-blue-700 dark:text-blue-300">
                {t("provider.form.gemini.oauthHint", {
                  defaultValue:
                    "Google 官方使用 OAuth 个人认证，无需填写 API Key。首次使用时会自动打开浏览器进行登录。",
                })}
              </p>
            </div>
          </div>
        </div>
      )}

      {/* API Key 输入框 */}
      {shouldShowApiKey && !isGoogleOfficial && (
        <ApiKeySection
          value={apiKey}
          onChange={onApiKeyChange}
          category={category}
          shouldShowLink={shouldShowApiKeyLink}
          websiteUrl={websiteUrl}
          isPartner={isPartner}
          partnerPromotionKey={partnerPromotionKey}
        />
      )}

      {/* Base URL 输入框（统一使用与 Codex 相同的样式与交互） */}
      {shouldShowSpeedTest && (
        <EndpointField
          id="baseUrl"
          label={t("providerForm.apiEndpoint", { defaultValue: "API 端点" })}
          value={baseUrl}
          onChange={onBaseUrlChange}
          placeholder={t("providerForm.apiEndpointPlaceholder", {
            defaultValue: "https://your-api-endpoint.com/",
          })}
          onManageClick={() => onEndpointModalToggle(true)}
        />
      )}

      {/* Model 输入框 */}
      {shouldShowModelField && (
        <div>
          <FormLabel htmlFor="gemini-model">
            {t("provider.form.gemini.model", { defaultValue: "模型" })}
          </FormLabel>
          <Input
            id="gemini-model"
            value={model}
            onChange={(e) => onModelChange(e.target.value)}
            placeholder="gemini-3-pro-preview"
          />
        </div>
      )}

      {/* 端点测速弹窗 */}
      {shouldShowSpeedTest && isEndpointModalOpen && (
        <EndpointSpeedTest
          appId="gemini"
          providerId={providerId}
          value={baseUrl}
          onChange={onBaseUrlChange}
          initialEndpoints={speedTestEndpoints}
          visible={isEndpointModalOpen}
          onClose={() => onEndpointModalToggle(false)}
          onCustomEndpointsChange={onCustomEndpointsChange}
        />
      )}
    </>
  );
}
</file>

<file path="src/components/providers/forms/hooks/index.ts">
export { useProviderCategory } from "./useProviderCategory";
export { useApiKeyState } from "./useApiKeyState";
export { useBaseUrlState } from "./useBaseUrlState";
export { useModelState } from "./useModelState";
export { useCodexConfigState } from "./useCodexConfigState";
export { useApiKeyLink } from "./useApiKeyLink";
export { useCustomEndpoints } from "./useCustomEndpoints";
export { useTemplateValues } from "./useTemplateValues";
export { useCommonConfigSnippet } from "./useCommonConfigSnippet";
export { useCodexCommonConfig } from "./useCodexCommonConfig";
export { useSpeedTestEndpoints } from "./useSpeedTestEndpoints";
export { useCodexTomlValidation } from "./useCodexTomlValidation";
export { useGeminiConfigState } from "./useGeminiConfigState";
export { useGeminiCommonConfig } from "./useGeminiCommonConfig";
</file>

<file path="src/components/providers/forms/hooks/useApiKeyLink.ts">
import { useMemo } from "react";
import type { AppId } from "@/lib/api";
import type { ProviderCategory } from "@/types";
import type { ProviderPreset } from "@/config/claudeProviderPresets";
import type { CodexProviderPreset } from "@/config/codexProviderPresets";
import type { GeminiProviderPreset } from "@/config/geminiProviderPresets";

type PresetEntry = {
  id: string;
  preset: ProviderPreset | CodexProviderPreset | GeminiProviderPreset;
};

interface UseApiKeyLinkProps {
  appId: AppId;
  category?: ProviderCategory;
  selectedPresetId: string | null;
  presetEntries: PresetEntry[];
  formWebsiteUrl: string;
}

/**
 * 管理 API Key 获取链接的显示和 URL
 */
export function useApiKeyLink({
  appId,
  category,
  selectedPresetId,
  presetEntries,
  formWebsiteUrl,
}: UseApiKeyLinkProps) {
  // 判断是否显示 API Key 获取链接
  const shouldShowApiKeyLink = useMemo(() => {
    return (
      category !== "official" &&
      (category === "cn_official" ||
        category === "aggregator" ||
        category === "third_party")
    );
  }, [category]);

  // 获取当前预设条目
  const currentPresetEntry = useMemo(() => {
    if (selectedPresetId && selectedPresetId !== "custom") {
      return presetEntries.find((item) => item.id === selectedPresetId);
    }
    return undefined;
  }, [selectedPresetId, presetEntries]);

  // 获取当前供应商的网址（用于 API Key 链接）
  const getWebsiteUrl = useMemo(() => {
    if (currentPresetEntry) {
      const preset = currentPresetEntry.preset;
      // 对于 cn_official、aggregator、third_party，优先使用 apiKeyUrl（可能包含推广参数）
      if (
        preset.category === "cn_official" ||
        preset.category === "aggregator" ||
        preset.category === "third_party"
      ) {
        return preset.apiKeyUrl || preset.websiteUrl || "";
      }
      return preset.websiteUrl || "";
    }
    return formWebsiteUrl || "";
  }, [currentPresetEntry, formWebsiteUrl]);

  // 提取合作伙伴信息
  const isPartner = useMemo(() => {
    return currentPresetEntry?.preset.isPartner ?? false;
  }, [currentPresetEntry]);

  const partnerPromotionKey = useMemo(() => {
    return currentPresetEntry?.preset.partnerPromotionKey;
  }, [currentPresetEntry]);

  return {
    shouldShowApiKeyLink:
      appId === "claude" || appId === "codex" || appId === "gemini"
        ? shouldShowApiKeyLink
        : false,
    websiteUrl: getWebsiteUrl,
    isPartner,
    partnerPromotionKey,
  };
}
</file>

<file path="src/components/providers/forms/hooks/useCodexCommonConfig.ts">
import { useState, useEffect, useCallback, useRef } from "react";
import {
  updateTomlCommonConfigSnippet,
  hasTomlCommonConfigSnippet,
} from "@/utils/providerConfigUtils";
import { configApi } from "@/lib/api";

const LEGACY_STORAGE_KEY = "cc-switch:codex-common-config-snippet";
const DEFAULT_CODEX_COMMON_CONFIG_SNIPPET = `# Common Codex config
# Add your common TOML configuration here`;

interface UseCodexCommonConfigProps {
  codexConfig: string;
  onConfigChange: (config: string) => void;
  initialData?: {
    settingsConfig?: Record<string, unknown>;
  };
}

/**
 * 管理 Codex 通用配置片段 (TOML 格式)
 * 从 config.json 读取和保存，支持从 localStorage 平滑迁移
 */
export function useCodexCommonConfig({
  codexConfig,
  onConfigChange,
  initialData,
}: UseCodexCommonConfigProps) {
  const [useCommonConfig, setUseCommonConfig] = useState(false);
  const [commonConfigSnippet, setCommonConfigSnippetState] = useState<string>(
    DEFAULT_CODEX_COMMON_CONFIG_SNIPPET,
  );
  const [commonConfigError, setCommonConfigError] = useState("");
  const [isLoading, setIsLoading] = useState(true);

  // 用于跟踪是否正在通过通用配置更新
  const isUpdatingFromCommonConfig = useRef(false);

  // 初始化：从 config.json 加载，支持从 localStorage 迁移
  useEffect(() => {
    let mounted = true;

    const loadSnippet = async () => {
      try {
        // 使用统一 API 加载
        const snippet = await configApi.getCommonConfigSnippet("codex");

        if (snippet && snippet.trim()) {
          if (mounted) {
            setCommonConfigSnippetState(snippet);
          }
        } else {
          // 如果 config.json 中没有，尝试从 localStorage 迁移
          if (typeof window !== "undefined") {
            try {
              const legacySnippet =
                window.localStorage.getItem(LEGACY_STORAGE_KEY);
              if (legacySnippet && legacySnippet.trim()) {
                // 迁移到 config.json
                await configApi.setCommonConfigSnippet("codex", legacySnippet);
                if (mounted) {
                  setCommonConfigSnippetState(legacySnippet);
                }
                // 清理 localStorage
                window.localStorage.removeItem(LEGACY_STORAGE_KEY);
                console.log(
                  "[迁移] Codex 通用配置已从 localStorage 迁移到 config.json",
                );
              }
            } catch (e) {
              console.warn("[迁移] 从 localStorage 迁移失败:", e);
            }
          }
        }
      } catch (error) {
        console.error("加载 Codex 通用配置失败:", error);
      } finally {
        if (mounted) {
          setIsLoading(false);
        }
      }
    };

    loadSnippet();

    return () => {
      mounted = false;
    };
  }, []);

  // 初始化时检查通用配置片段（编辑模式）
  useEffect(() => {
    if (initialData?.settingsConfig && !isLoading) {
      const config =
        typeof initialData.settingsConfig.config === "string"
          ? initialData.settingsConfig.config
          : "";
      const hasCommon = hasTomlCommonConfigSnippet(config, commonConfigSnippet);
      setUseCommonConfig(hasCommon);
    }
  }, [initialData, commonConfigSnippet, isLoading]);

  // 处理通用配置开关
  const handleCommonConfigToggle = useCallback(
    (checked: boolean) => {
      const { updatedConfig, error: snippetError } =
        updateTomlCommonConfigSnippet(
          codexConfig,
          commonConfigSnippet,
          checked,
        );

      if (snippetError) {
        setCommonConfigError(snippetError);
        setUseCommonConfig(false);
        return;
      }

      setCommonConfigError("");
      setUseCommonConfig(checked);
      // 标记正在通过通用配置更新
      isUpdatingFromCommonConfig.current = true;
      onConfigChange(updatedConfig);
      // 在下一个事件循环中重置标记
      setTimeout(() => {
        isUpdatingFromCommonConfig.current = false;
      }, 0);
    },
    [codexConfig, commonConfigSnippet, onConfigChange],
  );

  // 处理通用配置片段变化
  const handleCommonConfigSnippetChange = useCallback(
    (value: string) => {
      const previousSnippet = commonConfigSnippet;
      setCommonConfigSnippetState(value);

      if (!value.trim()) {
        setCommonConfigError("");
        // 保存到 config.json（清空）
        configApi.setCommonConfigSnippet("codex", "").catch((error) => {
          console.error("保存 Codex 通用配置失败:", error);
          setCommonConfigError(`保存失败: ${error}`);
        });

        if (useCommonConfig) {
          const { updatedConfig } = updateTomlCommonConfigSnippet(
            codexConfig,
            previousSnippet,
            false,
          );
          onConfigChange(updatedConfig);
          setUseCommonConfig(false);
        }
        return;
      }

      // TOML 格式校验较为复杂，暂时不做校验，直接清空错误
      setCommonConfigError("");
      // 保存到 config.json
      configApi.setCommonConfigSnippet("codex", value).catch((error) => {
        console.error("保存 Codex 通用配置失败:", error);
        setCommonConfigError(`保存失败: ${error}`);
      });

      // 若当前启用通用配置，需要替换为最新片段
      if (useCommonConfig) {
        const removeResult = updateTomlCommonConfigSnippet(
          codexConfig,
          previousSnippet,
          false,
        );
        if (removeResult.error) {
          setCommonConfigError(removeResult.error);
          return;
        }
        const addResult = updateTomlCommonConfigSnippet(
          removeResult.updatedConfig,
          value,
          true,
        );

        if (addResult.error) {
          setCommonConfigError(addResult.error);
          return;
        }

        // 标记正在通过通用配置更新，避免触发状态检查
        isUpdatingFromCommonConfig.current = true;
        onConfigChange(addResult.updatedConfig);
        // 在下一个事件循环中重置标记
        setTimeout(() => {
          isUpdatingFromCommonConfig.current = false;
        }, 0);
      }
    },
    [commonConfigSnippet, codexConfig, useCommonConfig, onConfigChange],
  );

  // 当配置变化时检查是否包含通用配置（但避免在通过通用配置更新时检查）
  useEffect(() => {
    if (isUpdatingFromCommonConfig.current || isLoading) {
      return;
    }
    const hasCommon = hasTomlCommonConfigSnippet(
      codexConfig,
      commonConfigSnippet,
    );
    setUseCommonConfig(hasCommon);
  }, [codexConfig, commonConfigSnippet, isLoading]);

  return {
    useCommonConfig,
    commonConfigSnippet,
    commonConfigError,
    isLoading,
    handleCommonConfigToggle,
    handleCommonConfigSnippetChange,
  };
}
</file>

<file path="src/components/providers/forms/hooks/useCodexTomlValidation.ts">
import { useState, useCallback, useEffect, useRef } from "react";
import TOML from "smol-toml";

/**
 * Codex config.toml 格式校验 Hook
 * 使用 smol-toml 进行实时 TOML 语法校验（带 debounce）
 */
export function useCodexTomlValidation() {
  const [configError, setConfigError] = useState("");
  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);

  /**
   * 校验 TOML 格式
   * @param tomlText - 待校验的 TOML 文本
   * @returns 是否校验通过
   */
  const validateToml = useCallback((tomlText: string): boolean => {
    // 空字符串视为合法（允许为空）
    if (!tomlText.trim()) {
      setConfigError("");
      return true;
    }

    try {
      TOML.parse(tomlText);
      setConfigError("");
      return true;
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "TOML 格式错误";
      setConfigError(errorMessage);
      return false;
    }
  }, []);

  /**
   * 带 debounce 的校验函数（500ms 延迟）
   * @param tomlText - 待校验的 TOML 文本
   */
  const debouncedValidate = useCallback(
    (tomlText: string) => {
      // 清除之前的定时器
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }

      // 设置新的定时器
      debounceTimerRef.current = setTimeout(() => {
        validateToml(tomlText);
      }, 500);
    },
    [validateToml],
  );

  /**
   * 清空错误信息
   */
  const clearError = useCallback(() => {
    setConfigError("");
  }, []);

  // 清理定时器
  useEffect(() => {
    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, []);

  return {
    configError,
    validateToml,
    debouncedValidate,
    clearError,
  };
}
</file>

<file path="src/components/providers/forms/hooks/useCommonConfigSnippet.ts">
import { useState, useEffect, useCallback, useRef } from "react";
import {
  updateCommonConfigSnippet,
  hasCommonConfigSnippet,
  validateJsonConfig,
} from "@/utils/providerConfigUtils";
import { configApi } from "@/lib/api";

const LEGACY_STORAGE_KEY = "cc-switch:common-config-snippet";
const DEFAULT_COMMON_CONFIG_SNIPPET = `{
  "includeCoAuthoredBy": false
}`;

interface UseCommonConfigSnippetProps {
  settingsConfig: string;
  onConfigChange: (config: string) => void;
  initialData?: {
    settingsConfig?: Record<string, unknown>;
  };
}

/**
 * 管理 Claude 通用配置片段
 * 从 config.json 读取和保存，支持从 localStorage 平滑迁移
 */
export function useCommonConfigSnippet({
  settingsConfig,
  onConfigChange,
  initialData,
}: UseCommonConfigSnippetProps) {
  const [useCommonConfig, setUseCommonConfig] = useState(false);
  const [commonConfigSnippet, setCommonConfigSnippetState] = useState<string>(
    DEFAULT_COMMON_CONFIG_SNIPPET,
  );
  const [commonConfigError, setCommonConfigError] = useState("");
  const [isLoading, setIsLoading] = useState(true);

  // 用于跟踪是否正在通过通用配置更新
  const isUpdatingFromCommonConfig = useRef(false);

  // 初始化：从 config.json 加载，支持从 localStorage 迁移
  useEffect(() => {
    let mounted = true;

    const loadSnippet = async () => {
      try {
        // 使用统一 API 加载
        const snippet = await configApi.getCommonConfigSnippet("claude");

        if (snippet && snippet.trim()) {
          if (mounted) {
            setCommonConfigSnippetState(snippet);
          }
        } else {
          // 如果 config.json 中没有，尝试从 localStorage 迁移
          if (typeof window !== "undefined") {
            try {
              const legacySnippet =
                window.localStorage.getItem(LEGACY_STORAGE_KEY);
              if (legacySnippet && legacySnippet.trim()) {
                // 迁移到 config.json
                await configApi.setCommonConfigSnippet("claude", legacySnippet);
                if (mounted) {
                  setCommonConfigSnippetState(legacySnippet);
                }
                // 清理 localStorage
                window.localStorage.removeItem(LEGACY_STORAGE_KEY);
                console.log(
                  "[迁移] Claude 通用配置已从 localStorage 迁移到 config.json",
                );
              }
            } catch (e) {
              console.warn("[迁移] 从 localStorage 迁移失败:", e);
            }
          }
        }
      } catch (error) {
        console.error("加载通用配置失败:", error);
      } finally {
        if (mounted) {
          setIsLoading(false);
        }
      }
    };

    loadSnippet();

    return () => {
      mounted = false;
    };
  }, []);

  // 初始化时检查通用配置片段（编辑模式）
  useEffect(() => {
    if (initialData && !isLoading) {
      const configString = JSON.stringify(initialData.settingsConfig, null, 2);
      const hasCommon = hasCommonConfigSnippet(
        configString,
        commonConfigSnippet,
      );
      setUseCommonConfig(hasCommon);
    }
  }, [initialData, commonConfigSnippet, isLoading]);

  // 处理通用配置开关
  const handleCommonConfigToggle = useCallback(
    (checked: boolean) => {
      const { updatedConfig, error: snippetError } = updateCommonConfigSnippet(
        settingsConfig,
        commonConfigSnippet,
        checked,
      );

      if (snippetError) {
        setCommonConfigError(snippetError);
        setUseCommonConfig(false);
        return;
      }

      setCommonConfigError("");
      setUseCommonConfig(checked);
      // 标记正在通过通用配置更新
      isUpdatingFromCommonConfig.current = true;
      onConfigChange(updatedConfig);
      // 在下一个事件循环中重置标记
      setTimeout(() => {
        isUpdatingFromCommonConfig.current = false;
      }, 0);
    },
    [settingsConfig, commonConfigSnippet, onConfigChange],
  );

  // 处理通用配置片段变化
  const handleCommonConfigSnippetChange = useCallback(
    (value: string) => {
      const previousSnippet = commonConfigSnippet;
      setCommonConfigSnippetState(value);

      if (!value.trim()) {
        setCommonConfigError("");
        // 保存到 config.json（清空）
        configApi.setCommonConfigSnippet("claude", "").catch((error) => {
          console.error("保存通用配置失败:", error);
          setCommonConfigError(`保存失败: ${error}`);
        });

        if (useCommonConfig) {
          const { updatedConfig } = updateCommonConfigSnippet(
            settingsConfig,
            previousSnippet,
            false,
          );
          onConfigChange(updatedConfig);
          setUseCommonConfig(false);
        }
        return;
      }

      // 验证JSON格式
      const validationError = validateJsonConfig(value, "通用配置片段");
      if (validationError) {
        setCommonConfigError(validationError);
      } else {
        setCommonConfigError("");
        // 保存到 config.json
        configApi.setCommonConfigSnippet("claude", value).catch((error) => {
          console.error("保存通用配置失败:", error);
          setCommonConfigError(`保存失败: ${error}`);
        });
      }

      // 若当前启用通用配置且格式正确，需要替换为最新片段
      if (useCommonConfig && !validationError) {
        const removeResult = updateCommonConfigSnippet(
          settingsConfig,
          previousSnippet,
          false,
        );
        if (removeResult.error) {
          setCommonConfigError(removeResult.error);
          return;
        }
        const addResult = updateCommonConfigSnippet(
          removeResult.updatedConfig,
          value,
          true,
        );

        if (addResult.error) {
          setCommonConfigError(addResult.error);
          return;
        }

        // 标记正在通过通用配置更新，避免触发状态检查
        isUpdatingFromCommonConfig.current = true;
        onConfigChange(addResult.updatedConfig);
        // 在下一个事件循环中重置标记
        setTimeout(() => {
          isUpdatingFromCommonConfig.current = false;
        }, 0);
      }
    },
    [commonConfigSnippet, settingsConfig, useCommonConfig, onConfigChange],
  );

  // 当配置变化时检查是否包含通用配置（但避免在通过通用配置更新时检查）
  useEffect(() => {
    if (isUpdatingFromCommonConfig.current || isLoading) {
      return;
    }
    const hasCommon = hasCommonConfigSnippet(
      settingsConfig,
      commonConfigSnippet,
    );
    setUseCommonConfig(hasCommon);
  }, [settingsConfig, commonConfigSnippet, isLoading]);

  return {
    useCommonConfig,
    commonConfigSnippet,
    commonConfigError,
    isLoading,
    handleCommonConfigToggle,
    handleCommonConfigSnippetChange,
  };
}
</file>

<file path="src/components/providers/forms/hooks/useCustomEndpoints.ts">
import { useMemo } from "react";
import type { AppId } from "@/lib/api";
import type { CustomEndpoint } from "@/types";
import type { ProviderPreset } from "@/config/claudeProviderPresets";
import type { CodexProviderPreset } from "@/config/codexProviderPresets";

type PresetEntry = {
  id: string;
  preset: ProviderPreset | CodexProviderPreset;
};

interface UseCustomEndpointsProps {
  appId: AppId;
  selectedPresetId: string | null;
  presetEntries: PresetEntry[];
  draftCustomEndpoints: string[];
  baseUrl: string;
  codexBaseUrl: string;
}

/**
 * 收集和管理自定义端点
 *
 * 收集来源：
 * 1. 用户在测速弹窗中新增的自定义端点
 * 2. 预设中的 endpointCandidates
 * 3. 当前选中的 Base URL
 */
export function useCustomEndpoints({
  appId,
  selectedPresetId,
  presetEntries,
  draftCustomEndpoints,
  baseUrl,
  codexBaseUrl,
}: UseCustomEndpointsProps) {
  const customEndpointsMap = useMemo(() => {
    const urlSet = new Set<string>();

    // 辅助函数：标准化并添加 URL
    const push = (raw?: string) => {
      const url = (raw || "").trim().replace(/\/+$/, "");
      if (url) urlSet.add(url);
    };

    // 1. 自定义端点（来自用户新增）
    for (const u of draftCustomEndpoints) push(u);

    // 2. 预设端点候选
    if (selectedPresetId && selectedPresetId !== "custom") {
      const entry = presetEntries.find((item) => item.id === selectedPresetId);
      if (entry) {
        const preset = entry.preset as any;
        if (Array.isArray(preset?.endpointCandidates)) {
          for (const u of preset.endpointCandidates as string[]) push(u);
        }
      }
    }

    // 3. 当前 Base URL
    if (appId === "codex") {
      push(codexBaseUrl);
    } else {
      push(baseUrl);
    }

    // 构建 CustomEndpoint map
    const urls = Array.from(urlSet.values());
    if (urls.length === 0) {
      return null;
    }

    const now = Date.now();
    const customMap: Record<string, CustomEndpoint> = {};
    for (const url of urls) {
      if (!customMap[url]) {
        customMap[url] = { url, addedAt: now, lastUsed: undefined };
      }
    }

    return customMap;
  }, [
    appId,
    selectedPresetId,
    presetEntries,
    draftCustomEndpoints,
    baseUrl,
    codexBaseUrl,
  ]);

  return customEndpointsMap;
}
</file>

<file path="src/components/providers/forms/hooks/useGeminiCommonConfig.ts">
import { useState, useEffect, useCallback, useRef } from "react";
import { configApi } from "@/lib/api";

const LEGACY_STORAGE_KEY = "cc-switch:gemini-common-config-snippet";
const DEFAULT_GEMINI_COMMON_CONFIG_SNIPPET = `{
  "timeout": 30000,
  "maxRetries": 3
}`;

interface UseGeminiCommonConfigProps {
  configValue: string;
  onConfigChange: (config: string) => void;
  initialData?: {
    settingsConfig?: Record<string, unknown>;
  };
}

/**
 * 深度合并两个对象（用于合并通用配置）
 */
function deepMerge(target: any, source: any): any {
  if (typeof target !== "object" || target === null) {
    return source;
  }
  if (typeof source !== "object" || source === null) {
    return target;
  }
  if (Array.isArray(source)) {
    return source;
  }

  const result = { ...target };
  for (const key of Object.keys(source)) {
    if (typeof source[key] === "object" && !Array.isArray(source[key])) {
      result[key] = deepMerge(result[key], source[key]);
    } else {
      result[key] = source[key];
    }
  }
  return result;
}

/**
 * 从配置中移除通用配置片段（递归比较）
 */
function removeCommonConfig(config: any, commonConfig: any): any {
  if (typeof config !== "object" || config === null) {
    return config;
  }
  if (typeof commonConfig !== "object" || commonConfig === null) {
    return config;
  }

  const result = { ...config };
  for (const key of Object.keys(commonConfig)) {
    if (result[key] === undefined) continue;

    // 如果值完全相等，删除该键
    if (JSON.stringify(result[key]) === JSON.stringify(commonConfig[key])) {
      delete result[key];
    } else if (
      typeof result[key] === "object" &&
      !Array.isArray(result[key]) &&
      typeof commonConfig[key] === "object" &&
      !Array.isArray(commonConfig[key])
    ) {
      // 递归移除嵌套对象
      result[key] = removeCommonConfig(result[key], commonConfig[key]);
      // 如果移除后对象为空，删除该键
      if (Object.keys(result[key]).length === 0) {
        delete result[key];
      }
    }
  }
  return result;
}

/**
 * 检查配置中是否包含通用配置片段
 */
function hasCommonConfigSnippet(config: any, commonConfig: any): boolean {
  if (typeof config !== "object" || config === null) return false;
  if (typeof commonConfig !== "object" || commonConfig === null) return false;

  for (const key of Object.keys(commonConfig)) {
    if (config[key] === undefined) return false;
    if (JSON.stringify(config[key]) !== JSON.stringify(commonConfig[key])) {
      // 检查嵌套对象
      if (
        typeof config[key] === "object" &&
        !Array.isArray(config[key]) &&
        typeof commonConfig[key] === "object" &&
        !Array.isArray(commonConfig[key])
      ) {
        if (!hasCommonConfigSnippet(config[key], commonConfig[key])) {
          return false;
        }
      } else {
        return false;
      }
    }
  }
  return true;
}

/**
 * 管理 Gemini 通用配置片段 (JSON 格式)
 * 从 config.json 读取和保存，支持从 localStorage 平滑迁移
 */
export function useGeminiCommonConfig({
  configValue,
  onConfigChange,
  initialData,
}: UseGeminiCommonConfigProps) {
  const [useCommonConfig, setUseCommonConfig] = useState(false);
  const [commonConfigSnippet, setCommonConfigSnippetState] = useState<string>(
    DEFAULT_GEMINI_COMMON_CONFIG_SNIPPET,
  );
  const [commonConfigError, setCommonConfigError] = useState("");
  const [isLoading, setIsLoading] = useState(true);

  // 用于跟踪是否正在通过通用配置更新
  const isUpdatingFromCommonConfig = useRef(false);

  // 初始化：从 config.json 加载，支持从 localStorage 迁移
  useEffect(() => {
    let mounted = true;

    const loadSnippet = async () => {
      try {
        // 使用统一 API 加载
        const snippet = await configApi.getCommonConfigSnippet("gemini");

        if (snippet && snippet.trim()) {
          if (mounted) {
            setCommonConfigSnippetState(snippet);
          }
        } else {
          // 如果 config.json 中没有，尝试从 localStorage 迁移
          if (typeof window !== "undefined") {
            try {
              const legacySnippet =
                window.localStorage.getItem(LEGACY_STORAGE_KEY);
              if (legacySnippet && legacySnippet.trim()) {
                // 迁移到 config.json
                await configApi.setCommonConfigSnippet("gemini", legacySnippet);
                if (mounted) {
                  setCommonConfigSnippetState(legacySnippet);
                }
                // 清理 localStorage
                window.localStorage.removeItem(LEGACY_STORAGE_KEY);
                console.log(
                  "[迁移] Gemini 通用配置已从 localStorage 迁移到 config.json",
                );
              }
            } catch (e) {
              console.warn("[迁移] 从 localStorage 迁移失败:", e);
            }
          }
        }
      } catch (error) {
        console.error("加载 Gemini 通用配置失败:", error);
      } finally {
        if (mounted) {
          setIsLoading(false);
        }
      }
    };

    loadSnippet();

    return () => {
      mounted = false;
    };
  }, []);

  // 初始化时检查通用配置片段（编辑模式）
  useEffect(() => {
    if (initialData?.settingsConfig && !isLoading) {
      try {
        const config =
          typeof initialData.settingsConfig.config === "object"
            ? initialData.settingsConfig.config
            : {};
        const commonConfigObj = JSON.parse(commonConfigSnippet);
        const hasCommon = hasCommonConfigSnippet(config, commonConfigObj);
        setUseCommonConfig(hasCommon);
      } catch {
        // ignore parse error
      }
    }
  }, [initialData, commonConfigSnippet, isLoading]);

  // 处理通用配置开关
  const handleCommonConfigToggle = useCallback(
    (checked: boolean) => {
      try {
        const configObj = configValue.trim() ? JSON.parse(configValue) : {};
        const commonConfigObj = JSON.parse(commonConfigSnippet);

        let updatedConfig: any;
        if (checked) {
          // 合并通用配置
          updatedConfig = deepMerge(configObj, commonConfigObj);
        } else {
          // 移除通用配置
          updatedConfig = removeCommonConfig(configObj, commonConfigObj);
        }

        setCommonConfigError("");
        setUseCommonConfig(checked);

        // 标记正在通过通用配置更新
        isUpdatingFromCommonConfig.current = true;
        onConfigChange(JSON.stringify(updatedConfig, null, 2));

        // 在下一个事件循环中重置标记
        setTimeout(() => {
          isUpdatingFromCommonConfig.current = false;
        }, 0);
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : String(error);
        setCommonConfigError(`配置合并失败: ${errorMessage}`);
        setUseCommonConfig(false);
      }
    },
    [configValue, commonConfigSnippet, onConfigChange],
  );

  // 处理通用配置片段变化
  const handleCommonConfigSnippetChange = useCallback(
    (value: string) => {
      const previousSnippet = commonConfigSnippet;
      setCommonConfigSnippetState(value);

      if (!value.trim()) {
        setCommonConfigError("");
        // 保存到 config.json（清空）
        configApi.setCommonConfigSnippet("gemini", "").catch((error) => {
          console.error("保存 Gemini 通用配置失败:", error);
          setCommonConfigError(`保存失败: ${error}`);
        });

        if (useCommonConfig) {
          // 移除旧的通用配置
          try {
            const configObj = configValue.trim() ? JSON.parse(configValue) : {};
            const previousCommonConfigObj = JSON.parse(previousSnippet);
            const updatedConfig = removeCommonConfig(
              configObj,
              previousCommonConfigObj,
            );
            onConfigChange(JSON.stringify(updatedConfig, null, 2));
            setUseCommonConfig(false);
          } catch {
            // ignore
          }
        }
        return;
      }

      // 校验 JSON 格式
      try {
        JSON.parse(value);
        setCommonConfigError("");
        // 保存到 config.json
        configApi.setCommonConfigSnippet("gemini", value).catch((error) => {
          console.error("保存 Gemini 通用配置失败:", error);
          setCommonConfigError(`保存失败: ${error}`);
        });
      } catch {
        setCommonConfigError("通用配置片段格式错误（必须是有效的 JSON）");
        return;
      }

      // 若当前启用通用配置，需要替换为最新片段
      if (useCommonConfig) {
        try {
          const configObj = configValue.trim() ? JSON.parse(configValue) : {};
          const previousCommonConfigObj = JSON.parse(previousSnippet);
          const newCommonConfigObj = JSON.parse(value);

          // 先移除旧的通用配置
          const withoutOld = removeCommonConfig(
            configObj,
            previousCommonConfigObj,
          );
          // 再合并新的通用配置
          const withNew = deepMerge(withoutOld, newCommonConfigObj);

          // 标记正在通过通用配置更新，避免触发状态检查
          isUpdatingFromCommonConfig.current = true;
          onConfigChange(JSON.stringify(withNew, null, 2));

          // 在下一个事件循环中重置标记
          setTimeout(() => {
            isUpdatingFromCommonConfig.current = false;
          }, 0);
        } catch (error) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          setCommonConfigError(`配置替换失败: ${errorMessage}`);
        }
      }
    },
    [commonConfigSnippet, configValue, useCommonConfig, onConfigChange],
  );

  // 当配置变化时检查是否包含通用配置（但避免在通过通用配置更新时检查）
  useEffect(() => {
    if (isUpdatingFromCommonConfig.current || isLoading) {
      return;
    }
    try {
      const configObj = configValue.trim() ? JSON.parse(configValue) : {};
      const commonConfigObj = JSON.parse(commonConfigSnippet);
      const hasCommon = hasCommonConfigSnippet(configObj, commonConfigObj);
      setUseCommonConfig(hasCommon);
    } catch {
      // ignore parse error
    }
  }, [configValue, commonConfigSnippet, isLoading]);

  return {
    useCommonConfig,
    commonConfigSnippet,
    commonConfigError,
    isLoading,
    handleCommonConfigToggle,
    handleCommonConfigSnippetChange,
  };
}
</file>

<file path="src/components/providers/forms/hooks/useGeminiConfigState.ts">
import { useState, useCallback, useEffect } from "react";

interface UseGeminiConfigStateProps {
  initialData?: {
    settingsConfig?: Record<string, unknown>;
  };
}

/**
 * 管理 Gemini 配置状态
 * Gemini 配置包含两部分：env (环境变量) 和 config (扩展配置 JSON)
 */
export function useGeminiConfigState({
  initialData,
}: UseGeminiConfigStateProps) {
  const [geminiEnv, setGeminiEnvState] = useState("");
  const [geminiConfig, setGeminiConfigState] = useState("");
  const [geminiApiKey, setGeminiApiKey] = useState("");
  const [geminiBaseUrl, setGeminiBaseUrl] = useState("");
  const [geminiModel, setGeminiModel] = useState("");
  const [envError, setEnvError] = useState("");
  const [configError, setConfigError] = useState("");

  // 将 JSON env 对象转换为 .env 格式字符串
  // 保留所有环境变量，已知 key 优先显示
  const envObjToString = useCallback(
    (envObj: Record<string, unknown>): string => {
      const priorityKeys = [
        "GOOGLE_GEMINI_BASE_URL",
        "GEMINI_API_KEY",
        "GEMINI_MODEL",
      ];
      const lines: string[] = [];
      const addedKeys = new Set<string>();

      // 先添加已知 key（按顺序）
      for (const key of priorityKeys) {
        if (typeof envObj[key] === "string" && envObj[key]) {
          lines.push(`${key}=${envObj[key]}`);
          addedKeys.add(key);
        }
      }

      // 再添加其他自定义 key（保留用户添加的环境变量）
      for (const [key, value] of Object.entries(envObj)) {
        if (!addedKeys.has(key) && typeof value === "string") {
          lines.push(`${key}=${value}`);
        }
      }

      return lines.join("\n");
    },
    [],
  );

  // 将 .env 格式字符串转换为 JSON env 对象
  const envStringToObj = useCallback(
    (envString: string): Record<string, string> => {
      const env: Record<string, string> = {};
      const lines = envString.split("\n");
      lines.forEach((line) => {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith("#")) return;
        const equalIndex = trimmed.indexOf("=");
        if (equalIndex > 0) {
          const key = trimmed.substring(0, equalIndex).trim();
          const value = trimmed.substring(equalIndex + 1).trim();
          env[key] = value;
        }
      });
      return env;
    },
    [],
  );

  // 初始化 Gemini 配置（编辑模式）
  useEffect(() => {
    if (!initialData) return;

    const config = initialData.settingsConfig;
    if (typeof config === "object" && config !== null) {
      // 设置 env
      const env = (config as any).env || {};
      setGeminiEnvState(envObjToString(env));

      // 设置 config
      const configObj = (config as any).config || {};
      setGeminiConfigState(JSON.stringify(configObj, null, 2));

      // 提取 API Key、Base URL 和 Model
      if (typeof env.GEMINI_API_KEY === "string") {
        setGeminiApiKey(env.GEMINI_API_KEY);
      }
      if (typeof env.GOOGLE_GEMINI_BASE_URL === "string") {
        setGeminiBaseUrl(env.GOOGLE_GEMINI_BASE_URL);
      }
      if (typeof env.GEMINI_MODEL === "string") {
        setGeminiModel(env.GEMINI_MODEL);
      }
    }
  }, [initialData, envObjToString]);

  // 从 geminiEnv 中提取并同步 API Key、Base URL 和 Model
  useEffect(() => {
    const envObj = envStringToObj(geminiEnv);
    const extractedKey = envObj.GEMINI_API_KEY || "";
    const extractedBaseUrl = envObj.GOOGLE_GEMINI_BASE_URL || "";
    const extractedModel = envObj.GEMINI_MODEL || "";

    if (extractedKey !== geminiApiKey) {
      setGeminiApiKey(extractedKey);
    }
    if (extractedBaseUrl !== geminiBaseUrl) {
      setGeminiBaseUrl(extractedBaseUrl);
    }
    if (extractedModel !== geminiModel) {
      setGeminiModel(extractedModel);
    }
  }, [geminiEnv, envStringToObj, geminiApiKey, geminiBaseUrl, geminiModel]);

  // 验证 Gemini Config JSON
  const validateGeminiConfig = useCallback((value: string): string => {
    if (!value.trim()) return ""; // 空值允许
    try {
      const parsed = JSON.parse(value);
      if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
        return "";
      }
      return "Config must be a JSON object";
    } catch {
      return "Invalid JSON format";
    }
  }, []);

  // 设置 env
  const setGeminiEnv = useCallback((value: string) => {
    setGeminiEnvState(value);
    // .env 格式较宽松，不做严格校验
    setEnvError("");
  }, []);

  // 设置 config (支持函数更新)
  const setGeminiConfig = useCallback(
    (value: string | ((prev: string) => string)) => {
      const newValue =
        typeof value === "function" ? value(geminiConfig) : value;
      setGeminiConfigState(newValue);
      setConfigError(validateGeminiConfig(newValue));
    },
    [geminiConfig, validateGeminiConfig],
  );

  // 处理 Gemini API Key 输入并写回 env
  const handleGeminiApiKeyChange = useCallback(
    (key: string) => {
      const trimmed = key.trim();
      setGeminiApiKey(trimmed);

      const envObj = envStringToObj(geminiEnv);
      envObj.GEMINI_API_KEY = trimmed;
      const newEnv = envObjToString(envObj);
      setGeminiEnv(newEnv);
    },
    [geminiEnv, envStringToObj, envObjToString, setGeminiEnv],
  );

  // 处理 Gemini Base URL 变化
  const handleGeminiBaseUrlChange = useCallback(
    (url: string) => {
      const sanitized = url.trim().replace(/\/+$/, "");
      setGeminiBaseUrl(sanitized);

      const envObj = envStringToObj(geminiEnv);
      envObj.GOOGLE_GEMINI_BASE_URL = sanitized;
      const newEnv = envObjToString(envObj);
      setGeminiEnv(newEnv);
    },
    [geminiEnv, envStringToObj, envObjToString, setGeminiEnv],
  );

  // 处理 Gemini Model 变化
  const handleGeminiModelChange = useCallback(
    (model: string) => {
      const trimmed = model.trim();
      setGeminiModel(trimmed);

      const envObj = envStringToObj(geminiEnv);
      envObj.GEMINI_MODEL = trimmed;
      const newEnv = envObjToString(envObj);
      setGeminiEnv(newEnv);
    },
    [geminiEnv, envStringToObj, envObjToString, setGeminiEnv],
  );

  // 处理 env 变化
  const handleGeminiEnvChange = useCallback(
    (value: string) => {
      setGeminiEnv(value);
    },
    [setGeminiEnv],
  );

  // 处理 config 变化
  const handleGeminiConfigChange = useCallback(
    (value: string) => {
      setGeminiConfig(value);
    },
    [setGeminiConfig],
  );

  // 重置配置（用于预设切换）
  const resetGeminiConfig = useCallback(
    (env: Record<string, unknown>, config: Record<string, unknown>) => {
      const envString = envObjToString(env);
      const configString = JSON.stringify(config, null, 2);

      setGeminiEnv(envString);
      setGeminiConfig(configString);

      // 提取 API Key、Base URL 和 Model
      if (typeof env.GEMINI_API_KEY === "string") {
        setGeminiApiKey(env.GEMINI_API_KEY);
      } else {
        setGeminiApiKey("");
      }

      if (typeof env.GOOGLE_GEMINI_BASE_URL === "string") {
        setGeminiBaseUrl(env.GOOGLE_GEMINI_BASE_URL);
      } else {
        setGeminiBaseUrl("");
      }

      if (typeof env.GEMINI_MODEL === "string") {
        setGeminiModel(env.GEMINI_MODEL);
      } else {
        setGeminiModel("");
      }
    },
    [envObjToString, setGeminiEnv, setGeminiConfig],
  );

  return {
    geminiEnv,
    geminiConfig,
    geminiApiKey,
    geminiBaseUrl,
    geminiModel,
    envError,
    configError,
    setGeminiEnv,
    setGeminiConfig,
    handleGeminiApiKeyChange,
    handleGeminiBaseUrlChange,
    handleGeminiModelChange,
    handleGeminiEnvChange,
    handleGeminiConfigChange,
    resetGeminiConfig,
    envStringToObj,
    envObjToString,
  };
}
</file>

<file path="src/components/providers/forms/hooks/useModelState.ts">
import { useState, useCallback, useEffect } from "react";

interface UseModelStateProps {
  settingsConfig: string;
  onConfigChange: (config: string) => void;
}

/**
 * 管理模型选择状态
 * 支持 ANTHROPIC_MODEL 和 ANTHROPIC_SMALL_FAST_MODEL
 */
export function useModelState({
  settingsConfig,
  onConfigChange,
}: UseModelStateProps) {
  const [claudeModel, setClaudeModel] = useState("");
  const [defaultHaikuModel, setDefaultHaikuModel] = useState("");
  const [defaultSonnetModel, setDefaultSonnetModel] = useState("");
  const [defaultOpusModel, setDefaultOpusModel] = useState("");

  // 初始化读取：读新键；若缺失，按兼容优先级回退
  // Haiku: DEFAULT_HAIKU || SMALL_FAST || MODEL
  // Sonnet: DEFAULT_SONNET || MODEL || SMALL_FAST
  // Opus: DEFAULT_OPUS || MODEL || SMALL_FAST
  // 仅在 settingsConfig 变化时同步一次（表单加载/切换预设时）
  useEffect(() => {
    try {
      const cfg = settingsConfig ? JSON.parse(settingsConfig) : {};
      const env = cfg?.env || {};
      const model =
        typeof env.ANTHROPIC_MODEL === "string" ? env.ANTHROPIC_MODEL : "";
      const small =
        typeof env.ANTHROPIC_SMALL_FAST_MODEL === "string"
          ? env.ANTHROPIC_SMALL_FAST_MODEL
          : "";
      const haiku =
        typeof env.ANTHROPIC_DEFAULT_HAIKU_MODEL === "string"
          ? env.ANTHROPIC_DEFAULT_HAIKU_MODEL
          : small || model;
      const sonnet =
        typeof env.ANTHROPIC_DEFAULT_SONNET_MODEL === "string"
          ? env.ANTHROPIC_DEFAULT_SONNET_MODEL
          : model || small;
      const opus =
        typeof env.ANTHROPIC_DEFAULT_OPUS_MODEL === "string"
          ? env.ANTHROPIC_DEFAULT_OPUS_MODEL
          : model || small;

      setClaudeModel(model || "");
      setDefaultHaikuModel(haiku || "");
      setDefaultSonnetModel(sonnet || "");
      setDefaultOpusModel(opus || "");
    } catch {
      // ignore
    }
  }, [settingsConfig]);

  const handleModelChange = useCallback(
    (
      field:
        | "ANTHROPIC_MODEL"
        | "ANTHROPIC_DEFAULT_HAIKU_MODEL"
        | "ANTHROPIC_DEFAULT_SONNET_MODEL"
        | "ANTHROPIC_DEFAULT_OPUS_MODEL",
      value: string,
    ) => {
      if (field === "ANTHROPIC_MODEL") setClaudeModel(value);
      if (field === "ANTHROPIC_DEFAULT_HAIKU_MODEL")
        setDefaultHaikuModel(value);
      if (field === "ANTHROPIC_DEFAULT_SONNET_MODEL")
        setDefaultSonnetModel(value);
      if (field === "ANTHROPIC_DEFAULT_OPUS_MODEL") setDefaultOpusModel(value);

      try {
        const currentConfig = settingsConfig
          ? JSON.parse(settingsConfig)
          : { env: {} };
        if (!currentConfig.env) currentConfig.env = {};

        // 新键仅写入；旧键不再写入
        const trimmed = value.trim();
        if (trimmed) {
          currentConfig.env[field] = trimmed;
        } else {
          delete currentConfig.env[field];
        }
        // 删除旧键
        delete currentConfig.env["ANTHROPIC_SMALL_FAST_MODEL"];

        onConfigChange(JSON.stringify(currentConfig, null, 2));
      } catch (err) {
        console.error("Failed to update model config:", err);
      }
    },
    [settingsConfig, onConfigChange],
  );

  return {
    claudeModel,
    setClaudeModel,
    defaultHaikuModel,
    setDefaultHaikuModel,
    defaultSonnetModel,
    setDefaultSonnetModel,
    defaultOpusModel,
    setDefaultOpusModel,
    handleModelChange,
  };
}
</file>

<file path="src/components/providers/forms/hooks/useProviderCategory.ts">
import { useState, useEffect } from "react";
import type { ProviderCategory } from "@/types";
import type { AppId } from "@/lib/api";
import { providerPresets } from "@/config/claudeProviderPresets";
import { codexProviderPresets } from "@/config/codexProviderPresets";
import { geminiProviderPresets } from "@/config/geminiProviderPresets";

interface UseProviderCategoryProps {
  appId: AppId;
  selectedPresetId: string | null;
  isEditMode: boolean;
  initialCategory?: ProviderCategory;
}

/**
 * 管理供应商类别状态
 * 根据选择的预设自动更新类别
 */
export function useProviderCategory({
  appId,
  selectedPresetId,
  isEditMode,
  initialCategory,
}: UseProviderCategoryProps) {
  const [category, setCategory] = useState<ProviderCategory | undefined>(
    // 编辑模式：使用 initialCategory
    isEditMode ? initialCategory : undefined,
  );

  useEffect(() => {
    // 编辑模式：只在初始化时设置，后续不自动更新
    if (isEditMode) {
      setCategory(initialCategory);
      return;
    }

    if (selectedPresetId === "custom") {
      setCategory("custom");
      return;
    }

    if (!selectedPresetId) return;

    // 从预设 ID 提取索引
    const match = selectedPresetId.match(/^(claude|codex|gemini)-(\d+)$/);
    if (!match) return;

    const [, type, indexStr] = match;
    const index = parseInt(indexStr, 10);

    if (type === "codex" && appId === "codex") {
      const preset = codexProviderPresets[index];
      if (preset) {
        setCategory(
          preset.category || (preset.isOfficial ? "official" : undefined),
        );
      }
    } else if (type === "claude" && appId === "claude") {
      const preset = providerPresets[index];
      if (preset) {
        setCategory(
          preset.category || (preset.isOfficial ? "official" : undefined),
        );
      }
    } else if (type === "gemini" && appId === "gemini") {
      const preset = geminiProviderPresets[index];
      if (preset) {
        setCategory(preset.category || undefined);
      }
    }
  }, [appId, selectedPresetId, isEditMode, initialCategory]);

  return { category, setCategory };
}
</file>

<file path="src/components/providers/forms/hooks/useSpeedTestEndpoints.ts">
import { useMemo } from "react";
import type { AppId } from "@/lib/api";
import type { ProviderPreset } from "@/config/claudeProviderPresets";
import type { CodexProviderPreset } from "@/config/codexProviderPresets";
import type { ProviderMeta, EndpointCandidate } from "@/types";

type PresetEntry = {
  id: string;
  preset: ProviderPreset | CodexProviderPreset;
};

interface UseSpeedTestEndpointsProps {
  appId: AppId;
  selectedPresetId: string | null;
  presetEntries: PresetEntry[];
  baseUrl: string;
  codexBaseUrl: string;
  initialData?: {
    settingsConfig?: Record<string, unknown>;
    meta?: ProviderMeta;
  };
}

/**
 * 收集端点测速弹窗的初始端点列表
 *
 * 收集来源：
 * 1. 当前选中的 Base URL
 * 2. 编辑模式下的初始数据 URL
 * 3. 预设中的 endpointCandidates
 *
 * 注意：已保存的自定义端点通过 getCustomEndpoints API 在 EndpointSpeedTest 组件中加载，
 * 不在此处读取，避免重复导入。
 */
export function useSpeedTestEndpoints({
  appId,
  selectedPresetId,
  presetEntries,
  baseUrl,
  codexBaseUrl,
  initialData,
}: UseSpeedTestEndpointsProps) {
  const claudeEndpoints = useMemo<EndpointCandidate[]>(() => {
    // Reuse this branch for Claude and Gemini (non-Codex)
    if (appId !== "claude" && appId !== "gemini") return [];

    const map = new Map<string, EndpointCandidate>();
    // 候选端点标记为 isCustom: false，表示来自预设或配置
    // 已保存的自定义端点会在 EndpointSpeedTest 组件中通过 API 加载
    const add = (url?: string, isCustom = false) => {
      if (!url) return;
      const sanitized = url.trim().replace(/\/+$/, "");
      if (!sanitized || map.has(sanitized)) return;
      map.set(sanitized, { url: sanitized, isCustom });
    };

    // 1. 当前 Base URL
    if (baseUrl) {
      add(baseUrl);
    }

    // 2. 编辑模式：初始数据中的 URL
    if (initialData && typeof initialData.settingsConfig === "object") {
      const configEnv = initialData.settingsConfig as {
        env?: { ANTHROPIC_BASE_URL?: string; GOOGLE_GEMINI_BASE_URL?: string };
      };
      const envUrls = [
        configEnv.env?.ANTHROPIC_BASE_URL,
        configEnv.env?.GOOGLE_GEMINI_BASE_URL,
      ];
      envUrls.forEach((u) => {
        if (typeof u === "string") add(u);
      });
    }

    // 3. 预设中的 endpointCandidates
    if (selectedPresetId && selectedPresetId !== "custom") {
      const entry = presetEntries.find((item) => item.id === selectedPresetId);
      if (entry) {
        const preset = entry.preset as ProviderPreset & {
          settingsConfig?: { env?: { GOOGLE_GEMINI_BASE_URL?: string } };
          endpointCandidates?: string[];
        };
        // 添加预设自己的 baseUrl（兼容 Claude/Gemini）
        const presetEnv = preset.settingsConfig as {
          env?: {
            ANTHROPIC_BASE_URL?: string;
            GOOGLE_GEMINI_BASE_URL?: string;
          };
        };
        const presetUrls = [
          presetEnv?.env?.ANTHROPIC_BASE_URL,
          presetEnv?.env?.GOOGLE_GEMINI_BASE_URL,
        ];
        presetUrls.forEach((u) => add(u));
        // 添加预设的候选端点
        if (preset.endpointCandidates) {
          preset.endpointCandidates.forEach((url) => add(url));
        }
      }
    }

    return Array.from(map.values());
  }, [appId, baseUrl, initialData, selectedPresetId, presetEntries]);

  const codexEndpoints = useMemo<EndpointCandidate[]>(() => {
    if (appId !== "codex") return [];

    const map = new Map<string, EndpointCandidate>();
    // 候选端点标记为 isCustom: false，表示来自预设或配置
    // 已保存的自定义端点会在 EndpointSpeedTest 组件中通过 API 加载
    const add = (url?: string, isCustom = false) => {
      if (!url) return;
      const sanitized = url.trim().replace(/\/+$/, "");
      if (!sanitized || map.has(sanitized)) return;
      map.set(sanitized, { url: sanitized, isCustom });
    };

    // 1. 当前 Codex Base URL
    if (codexBaseUrl) {
      add(codexBaseUrl);
    }

    // 2. 编辑模式：初始数据中的 URL
    const initialCodexConfig = initialData?.settingsConfig as
      | {
          config?: string;
        }
      | undefined;
    const configStr = initialCodexConfig?.config ?? "";
    // 从 TOML 中提取 base_url
    const match = /base_url\s*=\s*["']([^"']+)["']/i.exec(configStr);
    if (match?.[1]) {
      add(match[1]);
    }

    // 3. 预设中的 endpointCandidates
    if (selectedPresetId && selectedPresetId !== "custom") {
      const entry = presetEntries.find((item) => item.id === selectedPresetId);
      if (entry) {
        const preset = entry.preset as CodexProviderPreset;
        // 添加预设自己的 baseUrl
        const presetConfig = preset.config || "";
        const presetMatch = /base_url\s*=\s*["']([^"']+)["']/i.exec(
          presetConfig,
        );
        if (presetMatch?.[1]) {
          add(presetMatch[1]);
        }
        // 添加预设的候选端点
        if (preset.endpointCandidates) {
          preset.endpointCandidates.forEach((url) => add(url));
        }
      }
    }

    return Array.from(map.values());
  }, [appId, codexBaseUrl, initialData, selectedPresetId, presetEntries]);

  return appId === "codex" ? codexEndpoints : claudeEndpoints;
}
</file>

<file path="src/components/providers/forms/hooks/useTemplateValues.ts">
import { useState, useEffect, useCallback, useMemo } from "react";
import type {
  ProviderPreset,
  TemplateValueConfig,
} from "@/config/claudeProviderPresets";
import type { CodexProviderPreset } from "@/config/codexProviderPresets";
import { applyTemplateValues } from "@/utils/providerConfigUtils";

type TemplatePath = Array<string | number>;
type TemplateValueMap = Record<string, TemplateValueConfig>;

interface PresetEntry {
  id: string;
  preset: ProviderPreset | CodexProviderPreset;
}

interface UseTemplateValuesProps {
  selectedPresetId: string | null;
  presetEntries: PresetEntry[];
  settingsConfig: string;
  onConfigChange: (config: string) => void;
}

/**
 * 收集配置中包含模板占位符的路径
 */
const collectTemplatePaths = (
  source: unknown,
  templateKeys: string[],
  currentPath: TemplatePath = [],
  acc: TemplatePath[] = [],
): TemplatePath[] => {
  if (typeof source === "string") {
    const hasPlaceholder = templateKeys.some((key) =>
      source.includes(`\${${key}}`),
    );
    if (hasPlaceholder) {
      acc.push([...currentPath]);
    }
    return acc;
  }

  if (Array.isArray(source)) {
    source.forEach((item, index) =>
      collectTemplatePaths(item, templateKeys, [...currentPath, index], acc),
    );
    return acc;
  }

  if (source && typeof source === "object") {
    Object.entries(source).forEach(([key, value]) =>
      collectTemplatePaths(value, templateKeys, [...currentPath, key], acc),
    );
  }

  return acc;
};

/**
 * 根据路径获取值
 */
const getValueAtPath = (source: any, path: TemplatePath) => {
  return path.reduce<any>((acc, key) => {
    if (acc === undefined || acc === null) {
      return undefined;
    }
    return acc[key as keyof typeof acc];
  }, source);
};

/**
 * 根据路径设置值
 */
const setValueAtPath = (
  target: any,
  path: TemplatePath,
  value: unknown,
): any => {
  if (path.length === 0) {
    return value;
  }

  let current = target;

  for (let i = 0; i < path.length - 1; i++) {
    const key = path[i];
    const nextKey = path[i + 1];
    const isNextIndex = typeof nextKey === "number";

    if (current[key as keyof typeof current] === undefined) {
      current[key as keyof typeof current] = isNextIndex ? [] : {};
    } else {
      const currentValue = current[key as keyof typeof current];
      if (isNextIndex && !Array.isArray(currentValue)) {
        current[key as keyof typeof current] = [];
      } else if (
        !isNextIndex &&
        (typeof currentValue !== "object" || currentValue === null)
      ) {
        current[key as keyof typeof current] = {};
      }
    }

    current = current[key as keyof typeof current];
  }

  const finalKey = path[path.length - 1];
  current[finalKey as keyof typeof current] = value;
  return target;
};

/**
 * 应用模板值到配置字符串（只更新模板占位符所在的字段）
 */
const applyTemplateValuesToConfigString = (
  presetConfig: any,
  currentConfigString: string,
  values: TemplateValueMap,
) => {
  const replacedConfig = applyTemplateValues(presetConfig, values);
  const templateKeys = Object.keys(values);
  if (templateKeys.length === 0) {
    return JSON.stringify(replacedConfig, null, 2);
  }

  const placeholderPaths = collectTemplatePaths(presetConfig, templateKeys);

  try {
    const parsedConfig = currentConfigString.trim()
      ? JSON.parse(currentConfigString)
      : {};
    let targetConfig: any;
    if (Array.isArray(parsedConfig)) {
      targetConfig = [...parsedConfig];
    } else if (parsedConfig && typeof parsedConfig === "object") {
      targetConfig = JSON.parse(JSON.stringify(parsedConfig));
    } else {
      targetConfig = {};
    }

    if (placeholderPaths.length === 0) {
      return JSON.stringify(targetConfig, null, 2);
    }

    let mutatedConfig = targetConfig;

    for (const path of placeholderPaths) {
      const nextValue = getValueAtPath(replacedConfig, path);
      if (path.length === 0) {
        mutatedConfig = nextValue;
      } else {
        setValueAtPath(mutatedConfig, path, nextValue);
      }
    }

    return JSON.stringify(mutatedConfig, null, 2);
  } catch {
    return JSON.stringify(replacedConfig, null, 2);
  }
};

/**
 * 管理模板变量的状态和逻辑
 */
export function useTemplateValues({
  selectedPresetId,
  presetEntries,
  settingsConfig,
  onConfigChange,
}: UseTemplateValuesProps) {
  const [templateValues, setTemplateValues] = useState<TemplateValueMap>({});

  // 获取当前选中的预设
  const selectedPreset = useMemo(() => {
    if (!selectedPresetId || selectedPresetId === "custom") {
      return null;
    }
    const entry = presetEntries.find((item) => item.id === selectedPresetId);
    // 只处理 ProviderPreset (Claude 预设)
    if (entry && "settingsConfig" in entry.preset) {
      return entry.preset as ProviderPreset;
    }
    return null;
  }, [selectedPresetId, presetEntries]);

  // 获取模板变量条目
  const templateValueEntries = useMemo(() => {
    if (!selectedPreset?.templateValues) {
      return [];
    }
    return Object.entries(selectedPreset.templateValues) as Array<
      [string, TemplateValueConfig]
    >;
  }, [selectedPreset]);

  // 当选择预设时，初始化模板值
  useEffect(() => {
    if (selectedPreset?.templateValues) {
      const initialValues = Object.fromEntries(
        Object.entries(selectedPreset.templateValues).map(([key, config]) => [
          key,
          {
            ...config,
            editorValue: config.editorValue || config.defaultValue || "",
          },
        ]),
      );
      setTemplateValues(initialValues);
    } else {
      setTemplateValues({});
    }
  }, [selectedPreset]);

  // 处理模板值变化
  const handleTemplateValueChange = useCallback(
    (key: string, value: string) => {
      if (!selectedPreset?.templateValues) {
        return;
      }

      const config = selectedPreset.templateValues[key];
      if (!config) {
        return;
      }

      setTemplateValues((prev) => {
        const prevEntry = prev[key];
        const nextEntry: TemplateValueConfig = {
          ...config,
          ...(prevEntry ?? {}),
          editorValue: value,
        };
        const nextValues: TemplateValueMap = {
          ...prev,
          [key]: nextEntry,
        };

        // 应用模板值到配置
        try {
          const configString = applyTemplateValuesToConfigString(
            selectedPreset.settingsConfig,
            settingsConfig,
            nextValues,
          );
          onConfigChange(configString);
        } catch (err) {
          console.error("更新模板值失败:", err);
        }

        return nextValues;
      });
    },
    [selectedPreset, settingsConfig, onConfigChange],
  );

  // 验证所有模板值是否已填写
  const validateTemplateValues = useCallback((): {
    isValid: boolean;
    missingField?: { key: string; label: string };
  } => {
    if (templateValueEntries.length === 0) {
      return { isValid: true };
    }

    for (const [key, config] of templateValueEntries) {
      const entry = templateValues[key];
      const resolvedValue = (
        entry?.editorValue ??
        entry?.defaultValue ??
        config.defaultValue ??
        ""
      ).trim();
      if (!resolvedValue) {
        return {
          isValid: false,
          missingField: { key, label: config.label },
        };
      }
    }

    return { isValid: true };
  }, [templateValueEntries, templateValues]);

  return {
    templateValues,
    templateValueEntries,
    selectedPreset,
    handleTemplateValueChange,
    validateTemplateValues,
  };
}
</file>

<file path="src/components/providers/forms/ProviderForm.tsx">
import { useEffect, useMemo, useState, useCallback } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useTranslation } from "react-i18next";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import { Form, FormField, FormItem, FormMessage } from "@/components/ui/form";
import { providerSchema, type ProviderFormData } from "@/lib/schemas/provider";
import type { AppId } from "@/lib/api";
import type { ProviderCategory, ProviderMeta } from "@/types";
import {
  providerPresets,
  type ProviderPreset,
} from "@/config/claudeProviderPresets";
import {
  codexProviderPresets,
  type CodexProviderPreset,
} from "@/config/codexProviderPresets";
import {
  geminiProviderPresets,
  type GeminiProviderPreset,
} from "@/config/geminiProviderPresets";
import { applyTemplateValues } from "@/utils/providerConfigUtils";
import { mergeProviderMeta } from "@/utils/providerMetaUtils";
import { getCodexCustomTemplate } from "@/config/codexTemplates";
import CodexConfigEditor from "./CodexConfigEditor";
import { CommonConfigEditor } from "./CommonConfigEditor";
import GeminiConfigEditor from "./GeminiConfigEditor";
import { ProviderPresetSelector } from "./ProviderPresetSelector";
import { BasicFormFields } from "./BasicFormFields";
import { ClaudeFormFields } from "./ClaudeFormFields";
import { CodexFormFields } from "./CodexFormFields";
import { GeminiFormFields } from "./GeminiFormFields";
import {
  useProviderCategory,
  useApiKeyState,
  useBaseUrlState,
  useModelState,
  useCodexConfigState,
  useApiKeyLink,
  useTemplateValues,
  useCommonConfigSnippet,
  useCodexCommonConfig,
  useSpeedTestEndpoints,
  useCodexTomlValidation,
  useGeminiConfigState,
  useGeminiCommonConfig,
} from "./hooks";

const CLAUDE_DEFAULT_CONFIG = JSON.stringify({ env: {} }, null, 2);
const CODEX_DEFAULT_CONFIG = JSON.stringify({ auth: {}, config: "" }, null, 2);
const GEMINI_DEFAULT_CONFIG = JSON.stringify(
  {
    env: {
      GOOGLE_GEMINI_BASE_URL: "",
      GEMINI_API_KEY: "",
      GEMINI_MODEL: "gemini-3-pro-preview",
    },
  },
  null,
  2,
);

type PresetEntry = {
  id: string;
  preset: ProviderPreset | CodexProviderPreset | GeminiProviderPreset;
};

interface ProviderFormProps {
  appId: AppId;
  providerId?: string;
  submitLabel: string;
  onSubmit: (values: ProviderFormValues) => void;
  onCancel: () => void;
  initialData?: {
    name?: string;
    websiteUrl?: string;
    notes?: string;
    settingsConfig?: Record<string, unknown>;
    category?: ProviderCategory;
    meta?: ProviderMeta;
    icon?: string;
    iconColor?: string;
  };
  showButtons?: boolean;
}

export function ProviderForm({
  appId,
  providerId,
  submitLabel,
  onSubmit,
  onCancel,
  initialData,
  showButtons = true,
}: ProviderFormProps) {
  const { t } = useTranslation();
  const isEditMode = Boolean(initialData);

  const [selectedPresetId, setSelectedPresetId] = useState<string | null>(
    initialData ? null : "custom",
  );
  const [activePreset, setActivePreset] = useState<{
    id: string;
    category?: ProviderCategory;
    isPartner?: boolean;
    partnerPromotionKey?: string;
  } | null>(null);
  const [isEndpointModalOpen, setIsEndpointModalOpen] = useState(false);
  const [isCodexEndpointModalOpen, setIsCodexEndpointModalOpen] =
    useState(false);

  // 新建供应商：收集端点测速弹窗中的"自定义端点"，提交时一次性落盘到 meta.custom_endpoints
  // 编辑供应商：端点已通过 API 直接保存，不再需要此状态
  const [draftCustomEndpoints, setDraftCustomEndpoints] = useState<string[]>(
    () => {
      // 仅在新建模式下使用
      if (initialData) return [];
      return [];
    },
  );

  // 使用 category hook
  const { category } = useProviderCategory({
    appId,
    selectedPresetId,
    isEditMode,
    initialCategory: initialData?.category,
  });

  useEffect(() => {
    setSelectedPresetId(initialData ? null : "custom");
    setActivePreset(null);

    // 编辑模式不需要恢复 draftCustomEndpoints，端点已通过 API 管理
    if (!initialData) {
      setDraftCustomEndpoints([]);
    }
  }, [appId, initialData]);

  const defaultValues: ProviderFormData = useMemo(
    () => ({
      name: initialData?.name ?? "",
      websiteUrl: initialData?.websiteUrl ?? "",
      notes: initialData?.notes ?? "",
      settingsConfig: initialData?.settingsConfig
        ? JSON.stringify(initialData.settingsConfig, null, 2)
        : appId === "codex"
          ? CODEX_DEFAULT_CONFIG
          : appId === "gemini"
            ? GEMINI_DEFAULT_CONFIG
            : CLAUDE_DEFAULT_CONFIG,
      icon: initialData?.icon ?? "",
      iconColor: initialData?.iconColor ?? "",
    }),
    [initialData, appId],
  );

  const form = useForm<ProviderFormData>({
    resolver: zodResolver(providerSchema),
    defaultValues,
    mode: "onSubmit",
  });

  // 使用 API Key hook
  const {
    apiKey,
    handleApiKeyChange,
    showApiKey: shouldShowApiKey,
  } = useApiKeyState({
    initialConfig: form.watch("settingsConfig"),
    onConfigChange: (config) => form.setValue("settingsConfig", config),
    selectedPresetId,
    category,
    appType: appId,
  });

  // 使用 Base URL hook (Claude, Codex, Gemini)
  const { baseUrl, handleClaudeBaseUrlChange } = useBaseUrlState({
    appType: appId,
    category,
    settingsConfig: form.watch("settingsConfig"),
    codexConfig: "",
    onSettingsConfigChange: (config) => form.setValue("settingsConfig", config),
    onCodexConfigChange: () => {
      /* noop */
    },
  });

  // 使用 Model hook（新：主模型 + Haiku/Sonnet/Opus 默认模型）
  const {
    claudeModel,
    defaultHaikuModel,
    defaultSonnetModel,
    defaultOpusModel,
    handleModelChange,
  } = useModelState({
    settingsConfig: form.watch("settingsConfig"),
    onConfigChange: (config) => form.setValue("settingsConfig", config),
  });

  // 使用 Codex 配置 hook (仅 Codex 模式)
  const {
    codexAuth,
    codexConfig,
    codexApiKey,
    codexBaseUrl,
    codexModelName,
    codexAuthError,
    setCodexAuth,
    handleCodexApiKeyChange,
    handleCodexBaseUrlChange,
    handleCodexModelNameChange,
    handleCodexConfigChange: originalHandleCodexConfigChange,
    resetCodexConfig,
  } = useCodexConfigState({ initialData });

  // 使用 Codex TOML 校验 hook (仅 Codex 模式)
  const { configError: codexConfigError, debouncedValidate } =
    useCodexTomlValidation();

  // 包装 handleCodexConfigChange，添加实时校验
  const handleCodexConfigChange = useCallback(
    (value: string) => {
      originalHandleCodexConfigChange(value);
      debouncedValidate(value);
    },
    [originalHandleCodexConfigChange, debouncedValidate],
  );

  // Codex 新建模式：初始化时自动填充模板
  useEffect(() => {
    if (appId === "codex" && !initialData && selectedPresetId === "custom") {
      const template = getCodexCustomTemplate();
      resetCodexConfig(template.auth, template.config);
    }
  }, [appId, initialData, selectedPresetId, resetCodexConfig]);

  useEffect(() => {
    form.reset(defaultValues);
  }, [defaultValues, form]);

  const presetCategoryLabels: Record<string, string> = useMemo(
    () => ({
      official: t("providerForm.categoryOfficial", {
        defaultValue: "官方",
      }),
      cn_official: t("providerForm.categoryCnOfficial", {
        defaultValue: "国内官方",
      }),
      aggregator: t("providerForm.categoryAggregation", {
        defaultValue: "聚合服务",
      }),
      third_party: t("providerForm.categoryThirdParty", {
        defaultValue: "第三方",
      }),
    }),
    [t],
  );

  const presetEntries = useMemo(() => {
    if (appId === "codex") {
      return codexProviderPresets.map<PresetEntry>((preset, index) => ({
        id: `codex-${index}`,
        preset,
      }));
    } else if (appId === "gemini") {
      return geminiProviderPresets.map<PresetEntry>((preset, index) => ({
        id: `gemini-${index}`,
        preset,
      }));
    }
    return providerPresets.map<PresetEntry>((preset, index) => ({
      id: `claude-${index}`,
      preset,
    }));
  }, [appId]);

  // 使用模板变量 hook (仅 Claude 模式)
  const {
    templateValues,
    templateValueEntries,
    selectedPreset: templatePreset,
    handleTemplateValueChange,
    validateTemplateValues,
  } = useTemplateValues({
    selectedPresetId: appId === "claude" ? selectedPresetId : null,
    presetEntries: appId === "claude" ? presetEntries : [],
    settingsConfig: form.watch("settingsConfig"),
    onConfigChange: (config) => form.setValue("settingsConfig", config),
  });

  // 使用通用配置片段 hook (仅 Claude 模式)
  const {
    useCommonConfig,
    commonConfigSnippet,
    commonConfigError,
    handleCommonConfigToggle,
    handleCommonConfigSnippetChange,
  } = useCommonConfigSnippet({
    settingsConfig: form.watch("settingsConfig"),
    onConfigChange: (config) => form.setValue("settingsConfig", config),
    initialData: appId === "claude" ? initialData : undefined,
  });

  // 使用 Codex 通用配置片段 hook (仅 Codex 模式)
  const {
    useCommonConfig: useCodexCommonConfigFlag,
    commonConfigSnippet: codexCommonConfigSnippet,
    commonConfigError: codexCommonConfigError,
    handleCommonConfigToggle: handleCodexCommonConfigToggle,
    handleCommonConfigSnippetChange: handleCodexCommonConfigSnippetChange,
  } = useCodexCommonConfig({
    codexConfig,
    onConfigChange: handleCodexConfigChange,
    initialData: appId === "codex" ? initialData : undefined,
  });

  // 使用 Gemini 配置 hook (仅 Gemini 模式)
  const {
    geminiEnv,
    geminiConfig,
    geminiApiKey,
    geminiBaseUrl,
    geminiModel,
    envError,
    configError: geminiConfigError,
    handleGeminiApiKeyChange: originalHandleGeminiApiKeyChange,
    handleGeminiBaseUrlChange: originalHandleGeminiBaseUrlChange,
    handleGeminiModelChange: originalHandleGeminiModelChange,
    handleGeminiEnvChange,
    handleGeminiConfigChange,
    resetGeminiConfig,
    envStringToObj,
  } = useGeminiConfigState({
    initialData: appId === "gemini" ? initialData : undefined,
  });

  // 包装 Gemini handlers 以同步 settingsConfig
  const handleGeminiApiKeyChange = useCallback(
    (key: string) => {
      originalHandleGeminiApiKeyChange(key);
      // 同步更新 settingsConfig
      try {
        const config = JSON.parse(form.watch("settingsConfig") || "{}");
        if (!config.env) config.env = {};
        config.env.GEMINI_API_KEY = key.trim();
        form.setValue("settingsConfig", JSON.stringify(config, null, 2));
      } catch {
        // ignore
      }
    },
    [originalHandleGeminiApiKeyChange, form],
  );

  const handleGeminiBaseUrlChange = useCallback(
    (url: string) => {
      originalHandleGeminiBaseUrlChange(url);
      // 同步更新 settingsConfig
      try {
        const config = JSON.parse(form.watch("settingsConfig") || "{}");
        if (!config.env) config.env = {};
        config.env.GOOGLE_GEMINI_BASE_URL = url.trim().replace(/\/+$/, "");
        form.setValue("settingsConfig", JSON.stringify(config, null, 2));
      } catch {
        // ignore
      }
    },
    [originalHandleGeminiBaseUrlChange, form],
  );

  const handleGeminiModelChange = useCallback(
    (model: string) => {
      originalHandleGeminiModelChange(model);
      // 同步更新 settingsConfig
      try {
        const config = JSON.parse(form.watch("settingsConfig") || "{}");
        if (!config.env) config.env = {};
        config.env.GEMINI_MODEL = model.trim();
        form.setValue("settingsConfig", JSON.stringify(config, null, 2));
      } catch {
        // ignore
      }
    },
    [originalHandleGeminiModelChange, form],
  );

  // 使用 Gemini 通用配置 hook (仅 Gemini 模式)
  const {
    useCommonConfig: useGeminiCommonConfigFlag,
    commonConfigSnippet: geminiCommonConfigSnippet,
    commonConfigError: geminiCommonConfigError,
    handleCommonConfigToggle: handleGeminiCommonConfigToggle,
    handleCommonConfigSnippetChange: handleGeminiCommonConfigSnippetChange,
  } = useGeminiCommonConfig({
    configValue: geminiConfig,
    onConfigChange: handleGeminiConfigChange,
    initialData: appId === "gemini" ? initialData : undefined,
  });

  const [isCommonConfigModalOpen, setIsCommonConfigModalOpen] = useState(false);

  const handleSubmit = (values: ProviderFormData) => {
    // 验证模板变量（仅 Claude 模式）
    if (appId === "claude" && templateValueEntries.length > 0) {
      const validation = validateTemplateValues();
      if (!validation.isValid && validation.missingField) {
        toast.error(
          t("providerForm.fillParameter", {
            label: validation.missingField.label,
            defaultValue: `请填写 ${validation.missingField.label}`,
          }),
        );
        return;
      }
    }

    // 供应商名称必填校验
    if (!values.name.trim()) {
      toast.error(
        t("providerForm.fillSupplierName", {
          defaultValue: "请填写供应商名称",
        }),
      );
      return;
    }

    // 非官方供应商必填校验：端点和 API Key
    if (category !== "official") {
      if (appId === "claude") {
        if (!baseUrl.trim()) {
          toast.error(
            t("providerForm.endpointRequired", {
              defaultValue: "非官方供应商请填写 API 端点",
            }),
          );
          return;
        }
        if (!apiKey.trim()) {
          toast.error(
            t("providerForm.apiKeyRequired", {
              defaultValue: "非官方供应商请填写 API Key",
            }),
          );
          return;
        }
      } else if (appId === "codex") {
        if (!codexBaseUrl.trim()) {
          toast.error(
            t("providerForm.endpointRequired", {
              defaultValue: "非官方供应商请填写 API 端点",
            }),
          );
          return;
        }
        if (!codexApiKey.trim()) {
          toast.error(
            t("providerForm.apiKeyRequired", {
              defaultValue: "非官方供应商请填写 API Key",
            }),
          );
          return;
        }
      } else if (appId === "gemini") {
        if (!geminiBaseUrl.trim()) {
          toast.error(
            t("providerForm.endpointRequired", {
              defaultValue: "非官方供应商请填写 API 端点",
            }),
          );
          return;
        }
        if (!geminiApiKey.trim()) {
          toast.error(
            t("providerForm.apiKeyRequired", {
              defaultValue: "非官方供应商请填写 API Key",
            }),
          );
          return;
        }
      }
    }

    let settingsConfig: string;

    // Codex: 组合 auth 和 config
    if (appId === "codex") {
      try {
        const authJson = JSON.parse(codexAuth);
        const configObj = {
          auth: authJson,
          config: codexConfig ?? "",
        };
        settingsConfig = JSON.stringify(configObj);
      } catch (err) {
        // 如果解析失败，使用表单中的配置
        settingsConfig = values.settingsConfig.trim();
      }
    } else if (appId === "gemini") {
      // Gemini: 组合 env 和 config
      try {
        const envObj = envStringToObj(geminiEnv);
        const configObj = geminiConfig.trim() ? JSON.parse(geminiConfig) : {};
        const combined = {
          env: envObj,
          config: configObj,
        };
        settingsConfig = JSON.stringify(combined);
      } catch (err) {
        // 如果解析失败，使用表单中的配置
        settingsConfig = values.settingsConfig.trim();
      }
    } else {
      // Claude: 使用表单配置
      settingsConfig = values.settingsConfig.trim();
    }

    const payload: ProviderFormValues = {
      ...values,
      name: values.name.trim(),
      websiteUrl: values.websiteUrl?.trim() ?? "",
      settingsConfig,
    };

    if (activePreset) {
      payload.presetId = activePreset.id;
      if (activePreset.category) {
        payload.presetCategory = activePreset.category;
      }
      // 继承合作伙伴标识
      if (activePreset.isPartner) {
        payload.isPartner = activePreset.isPartner;
      }
    }

    // 处理 meta 字段：仅在新建模式下从 draftCustomEndpoints 生成 custom_endpoints
    // 编辑模式：端点已通过 API 直接保存，不在此处理
    if (!isEditMode && draftCustomEndpoints.length > 0) {
      const customEndpointsToSave: Record<
        string,
        import("@/types").CustomEndpoint
      > = draftCustomEndpoints.reduce(
        (acc, url) => {
          const now = Date.now();
          acc[url] = { url, addedAt: now, lastUsed: undefined };
          return acc;
        },
        {} as Record<string, import("@/types").CustomEndpoint>,
      );

      // 检测是否需要清空端点（重要：区分"用户清空端点"和"用户没有修改端点"）
      const hadEndpoints =
        initialData?.meta?.custom_endpoints &&
        Object.keys(initialData.meta.custom_endpoints).length > 0;
      const needsClearEndpoints =
        hadEndpoints && draftCustomEndpoints.length === 0;

      // 如果用户明确清空了端点，传递空对象（而不是 null）让后端知道要删除
      let mergedMeta = needsClearEndpoints
        ? mergeProviderMeta(initialData?.meta, {})
        : mergeProviderMeta(initialData?.meta, customEndpointsToSave);

      // 添加合作伙伴标识与促销 key
      if (activePreset?.isPartner) {
        mergedMeta = {
          ...(mergedMeta ?? {}),
          isPartner: true,
        };
      }

      if (activePreset?.partnerPromotionKey) {
        mergedMeta = {
          ...(mergedMeta ?? {}),
          partnerPromotionKey: activePreset.partnerPromotionKey,
        };
      }

      if (mergedMeta !== undefined) {
        payload.meta = mergedMeta;
      }
    }

    onSubmit(payload);
  };

  const groupedPresets = useMemo(() => {
    return presetEntries.reduce<Record<string, PresetEntry[]>>((acc, entry) => {
      const category = entry.preset.category ?? "others";
      if (!acc[category]) {
        acc[category] = [];
      }
      acc[category].push(entry);
      return acc;
    }, {});
  }, [presetEntries]);

  const categoryKeys = useMemo(() => {
    return Object.keys(groupedPresets).filter(
      (key) => key !== "custom" && groupedPresets[key]?.length,
    );
  }, [groupedPresets]);

  // 判断是否显示端点测速（仅官方类别不显示）
  const shouldShowSpeedTest = category !== "official";

  // 使用 API Key 链接 hook (Claude)
  const {
    shouldShowApiKeyLink: shouldShowClaudeApiKeyLink,
    websiteUrl: claudeWebsiteUrl,
    isPartner: isClaudePartner,
    partnerPromotionKey: claudePartnerPromotionKey,
  } = useApiKeyLink({
    appId: "claude",
    category,
    selectedPresetId,
    presetEntries,
    formWebsiteUrl: form.watch("websiteUrl") || "",
  });

  // 使用 API Key 链接 hook (Codex)
  const {
    shouldShowApiKeyLink: shouldShowCodexApiKeyLink,
    websiteUrl: codexWebsiteUrl,
    isPartner: isCodexPartner,
    partnerPromotionKey: codexPartnerPromotionKey,
  } = useApiKeyLink({
    appId: "codex",
    category,
    selectedPresetId,
    presetEntries,
    formWebsiteUrl: form.watch("websiteUrl") || "",
  });

  // 使用 API Key 链接 hook (Gemini)
  const {
    shouldShowApiKeyLink: shouldShowGeminiApiKeyLink,
    websiteUrl: geminiWebsiteUrl,
    isPartner: isGeminiPartner,
    partnerPromotionKey: geminiPartnerPromotionKey,
  } = useApiKeyLink({
    appId: "gemini",
    category,
    selectedPresetId,
    presetEntries,
    formWebsiteUrl: form.watch("websiteUrl") || "",
  });

  // 使用端点测速候选 hook
  const speedTestEndpoints = useSpeedTestEndpoints({
    appId,
    selectedPresetId,
    presetEntries,
    baseUrl,
    codexBaseUrl,
    initialData,
  });

  const handlePresetChange = (value: string) => {
    setSelectedPresetId(value);
    if (value === "custom") {
      setActivePreset(null);
      form.reset(defaultValues);

      // Codex 自定义模式：加载模板
      if (appId === "codex") {
        const template = getCodexCustomTemplate();
        resetCodexConfig(template.auth, template.config);
      }
      // Gemini 自定义模式：重置为空配置
      if (appId === "gemini") {
        resetGeminiConfig({}, {});
      }
      return;
    }

    const entry = presetEntries.find((item) => item.id === value);
    if (!entry) {
      return;
    }

    setActivePreset({
      id: value,
      category: entry.preset.category,
      isPartner: entry.preset.isPartner,
      partnerPromotionKey: entry.preset.partnerPromotionKey,
    });

    if (appId === "codex") {
      const preset = entry.preset as CodexProviderPreset;
      const auth = preset.auth ?? {};
      const config = preset.config ?? "";

      // 重置 Codex 配置
      resetCodexConfig(auth, config);

      // 更新表单其他字段
      form.reset({
        name: preset.name,
        websiteUrl: preset.websiteUrl ?? "",
        settingsConfig: JSON.stringify({ auth, config }, null, 2),
        icon: preset.icon ?? "",
        iconColor: preset.iconColor ?? "",
      });
      return;
    }

    if (appId === "gemini") {
      const preset = entry.preset as GeminiProviderPreset;
      const env = (preset.settingsConfig as any)?.env ?? {};
      const config = (preset.settingsConfig as any)?.config ?? {};

      // 重置 Gemini 配置
      resetGeminiConfig(env, config);

      // 更新表单其他字段
      form.reset({
        name: preset.name,
        websiteUrl: preset.websiteUrl ?? "",
        settingsConfig: JSON.stringify(preset.settingsConfig, null, 2),
        icon: preset.icon ?? "",
        iconColor: preset.iconColor ?? "",
      });
      return;
    }

    const preset = entry.preset as ProviderPreset;
    const config = applyTemplateValues(
      preset.settingsConfig,
      preset.templateValues,
    );

    form.reset({
      name: preset.name,
      websiteUrl: preset.websiteUrl ?? "",
      settingsConfig: JSON.stringify(config, null, 2),
      icon: preset.icon ?? "",
      iconColor: preset.iconColor ?? "",
    });
  };

  return (
    <Form {...form}>
      <form
        id="provider-form"
        onSubmit={form.handleSubmit(handleSubmit)}
        className="space-y-6 glass rounded-xl p-6 border border-white/10"
      >
        {/* 预设供应商选择（仅新增模式显示） */}
        {!initialData && (
          <ProviderPresetSelector
            selectedPresetId={selectedPresetId}
            groupedPresets={groupedPresets}
            categoryKeys={categoryKeys}
            presetCategoryLabels={presetCategoryLabels}
            onPresetChange={handlePresetChange}
            category={category}
          />
        )}

        {/* 基础字段 */}
        <BasicFormFields form={form} />

        {/* Claude 专属字段 */}
        {appId === "claude" && (
          <ClaudeFormFields
            providerId={providerId}
            shouldShowApiKey={shouldShowApiKey(
              form.watch("settingsConfig"),
              isEditMode,
            )}
            apiKey={apiKey}
            onApiKeyChange={handleApiKeyChange}
            category={category}
            shouldShowApiKeyLink={shouldShowClaudeApiKeyLink}
            websiteUrl={claudeWebsiteUrl}
            isPartner={isClaudePartner}
            partnerPromotionKey={claudePartnerPromotionKey}
            templateValueEntries={templateValueEntries}
            templateValues={templateValues}
            templatePresetName={templatePreset?.name || ""}
            onTemplateValueChange={handleTemplateValueChange}
            shouldShowSpeedTest={shouldShowSpeedTest}
            baseUrl={baseUrl}
            onBaseUrlChange={handleClaudeBaseUrlChange}
            isEndpointModalOpen={isEndpointModalOpen}
            onEndpointModalToggle={setIsEndpointModalOpen}
            onCustomEndpointsChange={
              isEditMode ? undefined : setDraftCustomEndpoints
            }
            shouldShowModelSelector={category !== "official"}
            claudeModel={claudeModel}
            defaultHaikuModel={defaultHaikuModel}
            defaultSonnetModel={defaultSonnetModel}
            defaultOpusModel={defaultOpusModel}
            onModelChange={handleModelChange}
            speedTestEndpoints={speedTestEndpoints}
          />
        )}

        {/* Codex 专属字段 */}
        {appId === "codex" && (
          <CodexFormFields
            providerId={providerId}
            codexApiKey={codexApiKey}
            onApiKeyChange={handleCodexApiKeyChange}
            category={category}
            shouldShowApiKeyLink={shouldShowCodexApiKeyLink}
            websiteUrl={codexWebsiteUrl}
            isPartner={isCodexPartner}
            partnerPromotionKey={codexPartnerPromotionKey}
            shouldShowSpeedTest={shouldShowSpeedTest}
            codexBaseUrl={codexBaseUrl}
            onBaseUrlChange={handleCodexBaseUrlChange}
            isEndpointModalOpen={isCodexEndpointModalOpen}
            onEndpointModalToggle={setIsCodexEndpointModalOpen}
            onCustomEndpointsChange={
              isEditMode ? undefined : setDraftCustomEndpoints
            }
            shouldShowModelField={category !== "official"}
            modelName={codexModelName}
            onModelNameChange={handleCodexModelNameChange}
            speedTestEndpoints={speedTestEndpoints}
          />
        )}

        {/* Gemini 专属字段 */}
        {appId === "gemini" && (
          <GeminiFormFields
            providerId={providerId}
            shouldShowApiKey={shouldShowApiKey(
              form.watch("settingsConfig"),
              isEditMode,
            )}
            apiKey={geminiApiKey}
            onApiKeyChange={handleGeminiApiKeyChange}
            category={category}
            shouldShowApiKeyLink={shouldShowGeminiApiKeyLink}
            websiteUrl={geminiWebsiteUrl}
            isPartner={isGeminiPartner}
            partnerPromotionKey={geminiPartnerPromotionKey}
            shouldShowSpeedTest={shouldShowSpeedTest}
            baseUrl={geminiBaseUrl}
            onBaseUrlChange={handleGeminiBaseUrlChange}
            isEndpointModalOpen={isEndpointModalOpen}
            onEndpointModalToggle={setIsEndpointModalOpen}
            onCustomEndpointsChange={setDraftCustomEndpoints}
            shouldShowModelField={true}
            model={geminiModel}
            onModelChange={handleGeminiModelChange}
            speedTestEndpoints={speedTestEndpoints}
          />
        )}

        {/* 配置编辑器：Codex、Claude、Gemini 分别使用不同的编辑器 */}
        {appId === "codex" ? (
          <>
            <CodexConfigEditor
              authValue={codexAuth}
              configValue={codexConfig}
              onAuthChange={setCodexAuth}
              onConfigChange={handleCodexConfigChange}
              useCommonConfig={useCodexCommonConfigFlag}
              onCommonConfigToggle={handleCodexCommonConfigToggle}
              commonConfigSnippet={codexCommonConfigSnippet}
              onCommonConfigSnippetChange={handleCodexCommonConfigSnippetChange}
              commonConfigError={codexCommonConfigError}
              authError={codexAuthError}
              configError={codexConfigError}
            />
            {/* 配置验证错误显示 */}
            <FormField
              control={form.control}
              name="settingsConfig"
              render={() => (
                <FormItem className="space-y-0">
                  <FormMessage />
                </FormItem>
              )}
            />
          </>
        ) : appId === "gemini" ? (
          <>
            <GeminiConfigEditor
              envValue={geminiEnv}
              configValue={geminiConfig}
              onEnvChange={handleGeminiEnvChange}
              onConfigChange={handleGeminiConfigChange}
              useCommonConfig={useGeminiCommonConfigFlag}
              onCommonConfigToggle={handleGeminiCommonConfigToggle}
              commonConfigSnippet={geminiCommonConfigSnippet}
              onCommonConfigSnippetChange={
                handleGeminiCommonConfigSnippetChange
              }
              commonConfigError={geminiCommonConfigError}
              envError={envError}
              configError={geminiConfigError}
            />
            {/* 配置验证错误显示 */}
            <FormField
              control={form.control}
              name="settingsConfig"
              render={() => (
                <FormItem className="space-y-0">
                  <FormMessage />
                </FormItem>
              )}
            />
          </>
        ) : (
          <>
            <CommonConfigEditor
              value={form.watch("settingsConfig")}
              onChange={(value) => form.setValue("settingsConfig", value)}
              useCommonConfig={useCommonConfig}
              onCommonConfigToggle={handleCommonConfigToggle}
              commonConfigSnippet={commonConfigSnippet}
              onCommonConfigSnippetChange={handleCommonConfigSnippetChange}
              commonConfigError={commonConfigError}
              onEditClick={() => setIsCommonConfigModalOpen(true)}
              isModalOpen={isCommonConfigModalOpen}
              onModalClose={() => setIsCommonConfigModalOpen(false)}
            />
            {/* 配置验证错误显示 */}
            <FormField
              control={form.control}
              name="settingsConfig"
              render={() => (
                <FormItem className="space-y-0">
                  <FormMessage />
                </FormItem>
              )}
            />
          </>
        )}

        {showButtons && (
          <div className="flex justify-end gap-2">
            <Button variant="outline" type="button" onClick={onCancel}>
              {t("common.cancel")}
            </Button>
            <Button type="submit">{submitLabel}</Button>
          </div>
        )}
      </form>
    </Form>
  );
}

export type ProviderFormValues = ProviderFormData & {
  presetId?: string;
  presetCategory?: ProviderCategory;
  isPartner?: boolean;
  meta?: ProviderMeta;
};
</file>

<file path="src/components/providers/forms/shared/ApiKeySection.tsx">
import { useTranslation } from "react-i18next";
import ApiKeyInput from "../ApiKeyInput";
import type { ProviderCategory } from "@/types";

interface ApiKeySectionProps {
  id?: string;
  label?: string;
  value: string;
  onChange: (value: string) => void;
  category?: ProviderCategory;
  shouldShowLink: boolean;
  websiteUrl: string;
  placeholder?: {
    official: string;
    thirdParty: string;
  };
  disabled?: boolean;
  isPartner?: boolean;
  partnerPromotionKey?: string;
}

export function ApiKeySection({
  id,
  label,
  value,
  onChange,
  category,
  shouldShowLink,
  websiteUrl,
  placeholder,
  disabled,
  isPartner,
  partnerPromotionKey,
}: ApiKeySectionProps) {
  const { t } = useTranslation();

  const defaultPlaceholder = {
    official: t("providerForm.officialNoApiKey", {
      defaultValue: "官方供应商无需 API Key",
    }),
    thirdParty: t("providerForm.apiKeyAutoFill", {
      defaultValue: "输入 API Key，将自动填充到配置",
    }),
  };

  const finalPlaceholder = placeholder || defaultPlaceholder;

  return (
    <div className="space-y-1">
      <ApiKeyInput
        id={id}
        label={label}
        value={value}
        onChange={onChange}
        placeholder={
          category === "official"
            ? finalPlaceholder.official
            : finalPlaceholder.thirdParty
        }
        disabled={disabled ?? category === "official"}
      />
      {/* API Key 获取链接 */}
      {shouldShowLink && websiteUrl && (
        <div className="space-y-2 -mt-1 pl-1">
          <a
            href={websiteUrl}
            target="_blank"
            rel="noopener noreferrer"
            className="text-xs text-blue-400 dark:text-blue-500 hover:text-blue-500 dark:hover:text-blue-400 transition-colors"
          >
            {t("providerForm.getApiKey", {
              defaultValue: "获取 API Key",
            })}
          </a>

          {/* 合作伙伴促销信息 */}
          {isPartner && partnerPromotionKey && (
            <div className="rounded-md bg-blue-50 dark:bg-blue-950/30 p-2.5 border border-blue-200 dark:border-blue-800">
              <p className="text-xs leading-relaxed text-blue-700 dark:text-blue-300">
                💡{" "}
                {t(`providerForm.partnerPromotion.${partnerPromotionKey}`, {
                  defaultValue: "",
                })}
              </p>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/providers/forms/shared/EndpointField.tsx">
import { useTranslation } from "react-i18next";
import { FormLabel } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Zap } from "lucide-react";

interface EndpointFieldProps {
  id: string;
  label: string;
  value: string;
  onChange: (value: string) => void;
  placeholder: string;
  hint?: string;
  showManageButton?: boolean;
  onManageClick?: () => void;
  manageButtonLabel?: string;
}

export function EndpointField({
  id,
  label,
  value,
  onChange,
  placeholder,
  hint,
  showManageButton = true,
  onManageClick,
  manageButtonLabel,
}: EndpointFieldProps) {
  const { t } = useTranslation();

  const defaultManageLabel = t("providerForm.manageAndTest", {
    defaultValue: "管理和测速",
  });

  return (
    <div className="space-y-2">
      <div className="flex items-center justify-between">
        <FormLabel htmlFor={id}>{label}</FormLabel>
        {showManageButton && onManageClick && (
          <button
            type="button"
            onClick={onManageClick}
            className="flex items-center gap-1 text-xs text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition-colors"
          >
            <Zap className="h-3.5 w-3.5" />
            {manageButtonLabel || defaultManageLabel}
          </button>
        )}
      </div>
      <Input
        id={id}
        type="url"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        autoComplete="off"
      />
      {hint ? (
        <div className="p-3 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-700 rounded-lg">
          <p className="text-xs text-amber-600 dark:text-amber-400">{hint}</p>
        </div>
      ) : null}
    </div>
  );
}
</file>

<file path="src/components/providers/forms/shared/index.ts">
export { ApiKeySection } from "./ApiKeySection";
export { EndpointField } from "./EndpointField";
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-lg text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        // 主按钮：蓝底白字（对应旧版 primary）
        default:
          "bg-blue-500 text-white hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700",
        // 危险按钮：红底白字（对应旧版 danger）
        destructive:
          "bg-red-500 text-white hover:bg-red-600 dark:bg-red-600 dark:hover:bg-red-700",
        // 轮廓按钮
        outline:
          "border border-border-default bg-background hover:bg-gray-100 hover:border-border-hover dark:hover:bg-gray-800",
        // 次按钮：灰色（对应旧版 secondary）
        secondary:
          "text-gray-500 hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-800 dark:hover:text-gray-200",
        // 幽灵按钮（对应旧版 ghost）
        ghost:
          "text-gray-500 hover:text-gray-900 hover:bg-gray-100 dark:text-gray-400 dark:hover:text-gray-100 dark:hover:bg-gray-800",
        // MCP 专属按钮：祖母绿
        mcp: "bg-emerald-500 text-white hover:bg-emerald-600 dark:bg-emerald-600 dark:hover:bg-emerald-700",
        // 链接按钮
        link: "text-blue-500 underline-offset-4 hover:underline dark:text-blue-400",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9 p-1.5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className,
    )}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className,
    )}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardDescription,
  CardContent,
};
</file>

<file path="src/components/ui/checkbox.tsx">
import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("grid place-content-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };
</file>

<file path="src/components/ui/dialog.tsx">
import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay> & {
    zIndex?: "base" | "nested" | "alert" | "top";
  }
>(({ className, zIndex = "base", ...props }, ref) => {
  const zIndexMap = {
    base: "z-40",
    nested: "z-50",
    alert: "z-[60]",
    top: "z-[110]",
  };

  return (
    <DialogPrimitive.Overlay
      ref={ref}
      className={cn(
        "fixed inset-0 bg-black/50 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        zIndexMap[zIndex],
        className,
      )}
      {...props}
    />
  );
});
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content> & {
    zIndex?: "base" | "nested" | "alert" | "top";
    variant?: "default" | "fullscreen";
    overlayClassName?: string;
  }
>(
  (
    {
      className,
      children,
      zIndex = "base",
      variant = "default",
      overlayClassName,
      ...props
    },
    ref,
  ) => {
    const zIndexMap = {
      base: "z-40",
      nested: "z-50",
      alert: "z-[60]",
      top: "z-[110]",
    };

    const variantClass = {
      default:
        "fixed left-1/2 top-1/2 flex flex-col w-full max-w-lg max-h-[90vh] translate-x-[-50%] translate-y-[-50%] border border-border-default bg-background text-foreground shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
      fullscreen:
        "fixed inset-0 flex flex-col w-screen h-screen translate-x-0 translate-y-0 bg-background text-foreground p-0 sm:rounded-none shadow-none",
    }[variant];

    return (
      <DialogPortal>
        <DialogOverlay zIndex={zIndex} className={overlayClassName} />
        <DialogPrimitive.Content
          ref={ref}
          className={cn(variantClass, zIndexMap[zIndex], className)}
          onInteractOutside={(e) => {
            // 防止点击遮罩层关闭对话框
            e.preventDefault();
          }}
          {...props}
        >
          {children}
        </DialogPrimitive.Content>
      </DialogPortal>
    );
  },
);
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left px-6 py-5 border-b border-border-default bg-muted/20 flex-shrink-0",
      className,
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end sm:items-center px-6 py-5 border-t border-border-default bg-muted/20 flex-shrink-0",
      className,
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-tight tracking-tight",
      className,
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
  DialogClose,
};
</file>

<file path="src/components/ui/dropdown-menu.tsx">
import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] rounded-md border border-border-default bg-popover p-1 text-popover-foreground shadow-md",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border border-border-default bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <svg
          className="h-4 w-4"
          viewBox="0 0 20 20"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M16.704 5.292a1 1 0 0 1 .083 1.32l-.083.094-8 8a1 1 0 0 1-1.32.083l-.094-.083-4-4a1 1 0 0 1 1.32-1.497l.094.083L8 12.585l7.293-7.292a1 1 0 0 1 1.32-.083l.094.083Z"
            fill="currentColor"
          />
        </svg>
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <div className="h-2 w-2 rounded-full bg-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-muted-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => (
  <span
    className={cn(
      "ml-auto text-xs tracking-widest text-muted-foreground",
      className,
    )}
    {...props}
  />
);
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
  DropdownMenuRadioGroup,
};
</file>

<file path="src/components/ui/form.tsx">
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { Slot } from "@radix-ui/react-slot";
import {
  Controller,
  FormProvider,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form";
import { cn } from "@/lib/utils";

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue,
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }

  const id = itemContext.id;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

const FormItemContext = React.createContext<{ id: string }>(
  {} as { id: string },
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = "FormItem";

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <LabelPrimitive.Root
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = LabelPrimitive.Root.displayName;

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { formItemId, formDescriptionId, formMessageId } = useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={`${formDescriptionId} ${formMessageId}`}
      {...props}
    />
  );
});
FormControl.displayName = "FormControl";

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  );
});
FormDescription.displayName = "FormDescription";

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error?.message ?? children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = "FormMessage";

export {
  Form,
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  useFormField,
};
</file>

<file path="src/components/ui/label.tsx">
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cn } from "@/lib/utils";

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(
      "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
      className,
    )}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };
</file>

<file path="src/components/ui/select.tsx">
import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";
import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-border-default bg-background px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:border-border-active disabled:cursor-not-allowed disabled:opacity-50",
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 min-w-[8rem] overflow-hidden rounded-md border border-border-default bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      position={position}
      {...props}
    >
      <SelectPrimitive.ScrollUpButton className="flex cursor-default items-center justify-center bg-popover py-1">
        <ChevronUp className="h-4 w-4" />
      </SelectPrimitive.ScrollUpButton>
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectPrimitive.ScrollDownButton className="flex cursor-default items-center justify-center bg-popover py-1">
        <ChevronDown className="h-4 w-4" />
      </SelectPrimitive.ScrollDownButton>
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
};
</file>

<file path="src/components/ui/sonner.tsx">
import { Toaster as SonnerToaster } from "sonner";

export function Toaster() {
  return (
    <SonnerToaster
      position="top-center"
      richColors
      theme="system"
      toastOptions={{
        duration: 2000,
        classNames: {
          toast:
            "group rounded-md border bg-background text-foreground shadow-lg",
          title: "text-sm font-semibold",
          description: "text-sm text-muted-foreground",
          closeButton:
            "absolute right-2 top-2 rounded-full p-1 text-muted-foreground transition-colors hover:bg-muted hover:text-foreground",
          actionButton:
            "rounded-md bg-primary px-3 py-1 text-xs font-medium text-primary-foreground transition-colors hover:bg-primary/90",
        },
      }}
    />
  );
}
</file>

<file path="src/components/ui/table.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
));
Table.displayName = "Table";

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead
    ref={ref}
    className={cn("[&_tr]:border-b [&_tr]:border-border-default", className)}
    {...props}
  />
));
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
));
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className,
    )}
    {...props}
  />
));
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b border-border-default transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className,
    )}
    {...props}
  />
));
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className,
    )}
    {...props}
  />
));
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
));
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
));
TableCaption.displayName = "TableCaption";

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react";
import { cn } from "@/lib/utils";

export type TextareaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>;

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-border-default bg-background px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-blue-500/20 dark:focus:ring-blue-400/20 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        autoComplete="off"
        autoCorrect="off"
        autoCapitalize="none"
        spellCheck={false}
        ref={ref}
        {...props}
      />
    );
  },
);
Textarea.displayName = "Textarea";

export { Textarea };
</file>

<file path="src/config/geminiProviderPresets.ts">
import type { ProviderCategory } from "@/types";

/**
 * Gemini 预设供应商的视觉主题配置
 */
export interface GeminiPresetTheme {
  /** 图标类型：'gemini' | 'generic' */
  icon?: "gemini" | "generic";
  /** 背景色（选中状态），支持 hex 颜色 */
  backgroundColor?: string;
  /** 文字色（选中状态），支持 hex 颜色 */
  textColor?: string;
}

export interface GeminiProviderPreset {
  name: string;
  websiteUrl: string;
  apiKeyUrl?: string;
  settingsConfig: object;
  baseURL?: string;
  model?: string;
  description?: string;
  category?: ProviderCategory;
  isPartner?: boolean;
  partnerPromotionKey?: string;
  endpointCandidates?: string[];
  theme?: GeminiPresetTheme;
  // 图标配置
  icon?: string; // 图标名称
  iconColor?: string; // 图标颜色
}

export const geminiProviderPresets: GeminiProviderPreset[] = [
  {
    name: "AI Code With",
    websiteUrl: "https://aicodewith.com",
    settingsConfig: {
      env: {
        GOOGLE_GEMINI_BASE_URL: "https://api.aicodewith.com/gemini_cli",
        GEMINI_MODEL: "gemini-3-pro-preview",
      },
    },
    baseURL: "https://api.aicodewith.com/gemini_cli",
    model: "gemini-3-pro-preview",
    description: "AI Code With",
    category: "third_party",
    endpointCandidates: ["https://api.aicodewith.com/gemini_cli"],
    icon: "aicodewith",
    iconColor: "#111111",
  },
];

export function getGeminiPresetByName(
  name: string,
): GeminiProviderPreset | undefined {
  return geminiProviderPresets.find((preset) => preset.name === name);
}

export function getGeminiPresetByUrl(
  url: string,
): GeminiProviderPreset | undefined {
  if (!url) return undefined;
  return geminiProviderPresets.find(
    (preset) =>
      preset.baseURL &&
      url.toLowerCase().includes(preset.baseURL.toLowerCase()),
  );
}
</file>

<file path="src/lib/api/config.ts">
// 配置相关 API
import { invoke } from "@tauri-apps/api/core";

export type AppType = "claude" | "codex" | "gemini";

/**
 * 获取 Claude 通用配置片段（已废弃，使用 getCommonConfigSnippet）
 * @returns 通用配置片段（JSON 字符串），如果不存在则返回 null
 * @deprecated 使用 getCommonConfigSnippet('claude') 替代
 */
export async function getClaudeCommonConfigSnippet(): Promise<string | null> {
  return invoke<string | null>("get_claude_common_config_snippet");
}

/**
 * 设置 Claude 通用配置片段（已废弃，使用 setCommonConfigSnippet）
 * @param snippet - 通用配置片段（JSON 字符串）
 * @throws 如果 JSON 格式无效
 * @deprecated 使用 setCommonConfigSnippet('claude', snippet) 替代
 */
export async function setClaudeCommonConfigSnippet(
  snippet: string,
): Promise<void> {
  return invoke("set_claude_common_config_snippet", { snippet });
}

/**
 * 获取通用配置片段（统一接口）
 * @param appType - 应用类型（claude/codex/gemini）
 * @returns 通用配置片段（原始字符串），如果不存在则返回 null
 */
export async function getCommonConfigSnippet(
  appType: AppType,
): Promise<string | null> {
  return invoke<string | null>("get_common_config_snippet", { appType });
}

/**
 * 设置通用配置片段（统一接口）
 * @param appType - 应用类型（claude/codex/gemini）
 * @param snippet - 通用配置片段（原始字符串）
 * @throws 如果格式无效（Claude/Gemini 验证 JSON，Codex 暂不验证）
 */
export async function setCommonConfigSnippet(
  appType: AppType,
  snippet: string,
): Promise<void> {
  return invoke("set_common_config_snippet", { appType, snippet });
}
</file>

<file path="src/lib/api/env.ts">
import { invoke } from "@tauri-apps/api/core";
import type { EnvConflict, BackupInfo } from "@/types/env";

/**
 * 环境变量管理 API
 */

/**
 * 检查指定应用的环境变量冲突
 * @param appType 应用类型 ("claude" | "codex" | "gemini")
 * @returns 环境变量冲突列表
 */
export async function checkEnvConflicts(
  appType: string,
): Promise<EnvConflict[]> {
  return invoke<EnvConflict[]>("check_env_conflicts", { app: appType });
}

/**
 * 删除指定的环境变量 (会自动备份)
 * @param conflicts 要删除的环境变量冲突列表
 * @returns 备份信息
 */
export async function deleteEnvVars(
  conflicts: EnvConflict[],
): Promise<BackupInfo> {
  return invoke<BackupInfo>("delete_env_vars", { conflicts });
}

/**
 * 从备份文件恢复环境变量
 * @param backupPath 备份文件路径
 */
export async function restoreEnvBackup(backupPath: string): Promise<void> {
  return invoke<void>("restore_env_backup", { backupPath });
}

/**
 * 检查所有应用的环境变量冲突
 * @returns 按应用类型分组的环境变量冲突
 */
export async function checkAllEnvConflicts(): Promise<
  Record<string, EnvConflict[]>
> {
  const apps = ["claude", "codex", "gemini"];
  const results: Record<string, EnvConflict[]> = {};

  await Promise.all(
    apps.map(async (app) => {
      try {
        results[app] = await checkEnvConflicts(app);
      } catch (error) {
        console.error(`检查 ${app} 环境变量失败:`, error);
        results[app] = [];
      }
    }),
  );

  return results;
}
</file>

<file path="src/lib/api/index.ts">
export type { AppId } from "./types";
export { providersApi } from "./providers";
export { settingsApi } from "./settings";
export { mcpApi } from "./mcp";
export { promptsApi } from "./prompts";
export { usageApi } from "./usage";
export { vscodeApi } from "./vscode";
export * as configApi from "./config";
export type { ProviderSwitchEvent } from "./providers";
export type { Prompt } from "./prompts";
</file>

<file path="src/lib/api/mcp.ts">
import { invoke } from "@tauri-apps/api/core";
import type {
  McpConfigResponse,
  McpServer,
  McpServerSpec,
  McpServersMap,
  McpStatus,
} from "@/types";
import type { AppId } from "./types";

export const mcpApi = {
  async getStatus(): Promise<McpStatus> {
    return await invoke("get_claude_mcp_status");
  },

  async readConfig(): Promise<string | null> {
    return await invoke("read_claude_mcp_config");
  },

  async upsertServer(
    id: string,
    spec: McpServerSpec | Record<string, any>,
  ): Promise<boolean> {
    return await invoke("upsert_claude_mcp_server", { id, spec });
  },

  async deleteServer(id: string): Promise<boolean> {
    return await invoke("delete_claude_mcp_server", { id });
  },

  async validateCommand(cmd: string): Promise<boolean> {
    return await invoke("validate_mcp_command", { cmd });
  },

  /**
   * @deprecated 使用 getAllServers() 代替（v3.7.0+）
   */
  async getConfig(app: AppId = "claude"): Promise<McpConfigResponse> {
    return await invoke("get_mcp_config", { app });
  },

  /**
   * @deprecated 使用 upsertUnifiedServer() 代替（v3.7.0+）
   */
  async upsertServerInConfig(
    app: AppId,
    id: string,
    spec: McpServer,
    options?: { syncOtherSide?: boolean },
  ): Promise<boolean> {
    const payload = {
      app,
      id,
      spec,
      ...(options?.syncOtherSide !== undefined
        ? { syncOtherSide: options.syncOtherSide }
        : {}),
    };
    return await invoke("upsert_mcp_server_in_config", payload);
  },

  /**
   * @deprecated 使用 deleteUnifiedServer() 代替（v3.7.0+）
   */
  async deleteServerInConfig(
    app: AppId,
    id: string,
    options?: { syncOtherSide?: boolean },
  ): Promise<boolean> {
    const payload = {
      app,
      id,
      ...(options?.syncOtherSide !== undefined
        ? { syncOtherSide: options.syncOtherSide }
        : {}),
    };
    return await invoke("delete_mcp_server_in_config", payload);
  },

  /**
   * @deprecated 使用 toggleApp() 代替（v3.7.0+）
   */
  async setEnabled(app: AppId, id: string, enabled: boolean): Promise<boolean> {
    return await invoke("set_mcp_enabled", { app, id, enabled });
  },

  // ========================================================================
  // v3.7.0 新增：统一 MCP 管理 API
  // ========================================================================

  /**
   * 获取所有 MCP 服务器（统一结构）
   */
  async getAllServers(): Promise<McpServersMap> {
    return await invoke("get_mcp_servers");
  },

  /**
   * 添加或更新 MCP 服务器（统一结构）
   */
  async upsertUnifiedServer(server: McpServer): Promise<void> {
    return await invoke("upsert_mcp_server", { server });
  },

  /**
   * 删除 MCP 服务器
   */
  async deleteUnifiedServer(id: string): Promise<boolean> {
    return await invoke("delete_mcp_server", { id });
  },

  /**
   * 切换 MCP 服务器在指定应用的启用状态
   */
  async toggleApp(
    serverId: string,
    app: AppId,
    enabled: boolean,
  ): Promise<void> {
    return await invoke("toggle_mcp_app", { serverId, app, enabled });
  },
};
</file>

<file path="src/lib/api/prompts.ts">
import { invoke } from "@tauri-apps/api/core";
import type { AppId } from "./types";

export interface Prompt {
  id: string;
  name: string;
  content: string;
  description?: string;
  enabled: boolean;
  createdAt?: number;
  updatedAt?: number;
}

export const promptsApi = {
  async getPrompts(app: AppId): Promise<Record<string, Prompt>> {
    return await invoke("get_prompts", { app });
  },

  async upsertPrompt(app: AppId, id: string, prompt: Prompt): Promise<void> {
    return await invoke("upsert_prompt", { app, id, prompt });
  },

  async deletePrompt(app: AppId, id: string): Promise<void> {
    return await invoke("delete_prompt", { app, id });
  },

  async enablePrompt(app: AppId, id: string): Promise<void> {
    return await invoke("enable_prompt", { app, id });
  },

  async importFromFile(app: AppId): Promise<string> {
    return await invoke("import_prompt_from_file", { app });
  },

  async getCurrentFileContent(app: AppId): Promise<string | null> {
    return await invoke("get_current_prompt_file_content", { app });
  },
};
</file>

<file path="src/lib/api/types.ts">
// 前端统一使用 AppId 作为应用标识（与后端命令参数 `app` 一致）
export type AppId = "claude" | "codex" | "gemini"; // 新增 gemini
</file>

<file path="src/lib/api/vscode.ts">
import { invoke } from "@tauri-apps/api/core";
import type { CustomEndpoint } from "@/types";
import type { AppId } from "./types";

export interface EndpointLatencyResult {
  url: string;
  latency: number | null;
  status?: number;
  error?: string;
}

export const vscodeApi = {
  async getLiveProviderSettings(appId: AppId) {
    return await invoke("read_live_provider_settings", { app: appId });
  },

  async testApiEndpoints(
    urls: string[],
    options?: { timeoutSecs?: number },
  ): Promise<EndpointLatencyResult[]> {
    return await invoke("test_api_endpoints", {
      urls,
      timeoutSecs: options?.timeoutSecs,
    });
  },

  async getCustomEndpoints(
    appId: AppId,
    providerId: string,
  ): Promise<CustomEndpoint[]> {
    return await invoke("get_custom_endpoints", {
      app: appId,
      providerId: providerId,
    });
  },

  async addCustomEndpoint(
    appId: AppId,
    providerId: string,
    url: string,
  ): Promise<void> {
    await invoke("add_custom_endpoint", {
      app: appId,
      providerId: providerId,
      url,
    });
  },

  async removeCustomEndpoint(
    appId: AppId,
    providerId: string,
    url: string,
  ): Promise<void> {
    await invoke("remove_custom_endpoint", {
      app: appId,
      providerId: providerId,
      url,
    });
  },

  async updateEndpointLastUsed(
    appId: AppId,
    providerId: string,
    url: string,
  ): Promise<void> {
    await invoke("update_endpoint_last_used", {
      app: appId,
      providerId: providerId,
      url,
    });
  },

  async exportConfigToFile(filePath: string) {
    return await invoke("export_config_to_file", {
      filePath,
    });
  },

  async importConfigFromFile(filePath: string) {
    return await invoke("import_config_from_file", {
      filePath,
    });
  },

  async saveFileDialog(defaultName: string): Promise<string | null> {
    return await invoke("save_file_dialog", {
      defaultName,
    });
  },

  async openFileDialog(): Promise<string | null> {
    return await invoke("open_file_dialog");
  },
};
</file>

<file path="src/lib/query/index.ts">
export * from "./queryClient";
export * from "./queries";
export * from "./mutations";
</file>

<file path="src/lib/query/queryClient.ts">
import { QueryClient } from "@tanstack/react-query";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      refetchOnWindowFocus: false,
      staleTime: 1000 * 60 * 5,
    },
    mutations: {
      retry: false,
    },
  },
});
</file>

<file path="src/utils/errorUtils.ts">
/**
 * 从各种错误对象中提取错误信息
 * @param error 错误对象
 * @returns 提取的错误信息字符串
 */
export const extractErrorMessage = (error: unknown): string => {
  if (!error) return "";
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error && error.message.trim()) {
    return error.message;
  }

  if (typeof error === "object") {
    const errObject = error as Record<string, unknown>;

    const candidate = errObject.message ?? errObject.error ?? errObject.detail;
    if (typeof candidate === "string" && candidate.trim()) {
      return candidate;
    }

    const payload = errObject.payload;
    if (typeof payload === "string" && payload.trim()) {
      return payload;
    }
    if (payload && typeof payload === "object") {
      const payloadObj = payload as Record<string, unknown>;
      const payloadCandidate =
        payloadObj.message ?? payloadObj.error ?? payloadObj.detail;
      if (typeof payloadCandidate === "string" && payloadCandidate.trim()) {
        return payloadCandidate;
      }
    }
  }

  return "";
};

/**
 * 将已知的 MCP 相关后端错误（通常为中文硬编码）映射为 i18n 文案
 * 采用包含式匹配，尽量稳健地覆盖不同上下文的相似消息。
 * 若无法识别，返回空字符串以便调用方回退到原始 detail 或默认 i18n。
 */
export const translateMcpBackendError = (
  message: string,
  t: (key: string, opts?: any) => string,
): string => {
  if (!message) return "";
  const msg = String(message).trim();

  // 基础字段与结构校验相关
  if (msg.includes("MCP 服务器 ID 不能为空")) {
    return t("mcp.error.idRequired");
  }
  if (
    msg.includes("MCP 服务器定义必须为 JSON 对象") ||
    msg.includes("MCP 服务器条目必须为 JSON 对象") ||
    msg.includes("MCP 服务器条目缺少 server 字段") ||
    msg.includes("MCP 服务器 server 字段必须为 JSON 对象") ||
    msg.includes("MCP 服务器连接定义必须为 JSON 对象") ||
    msg.includes("MCP 服务器 '" /* 不是对象 */) ||
    msg.includes("不是对象") ||
    msg.includes("服务器配置必须是对象") ||
    msg.includes("MCP 服务器 name 必须为字符串") ||
    msg.includes("MCP 服务器 description 必须为字符串") ||
    msg.includes("MCP 服务器 homepage 必须为字符串") ||
    msg.includes("MCP 服务器 docs 必须为字符串") ||
    msg.includes("MCP 服务器 tags 必须为字符串数组") ||
    msg.includes("MCP 服务器 enabled 必须为布尔值")
  ) {
    return t("mcp.error.jsonInvalid");
  }
  if (msg.includes("MCP 服务器 type 必须是")) {
    return t("mcp.error.jsonInvalid");
  }

  // 必填字段
  if (
    msg.includes("stdio 类型的 MCP 服务器缺少 command 字段") ||
    msg.includes("必须包含 command 字段")
  ) {
    return t("mcp.error.commandRequired");
  }
  if (
    msg.includes("http 类型的 MCP 服务器缺少 url 字段") ||
    msg.includes("sse 类型的 MCP 服务器缺少 url 字段") ||
    msg.includes("必须包含 url 字段") ||
    msg === "URL 不能为空"
  ) {
    return t("mcp.wizard.urlRequired");
  }

  // 文件解析/序列化
  if (
    msg.includes("解析 ~/.claude.json 失败") ||
    msg.includes("解析 config.toml 失败") ||
    msg.includes("无法识别的 TOML 格式") ||
    msg.includes("TOML 内容不能为空")
  ) {
    return t("mcp.error.tomlInvalid");
  }
  if (msg.includes("序列化 config.toml 失败")) {
    return t("mcp.error.tomlInvalid");
  }

  return "";
};
</file>

<file path="src/utils/postChangeSync.ts">
import { settingsApi } from "@/lib/api";

/**
 * 统一的“后置同步”工具：将当前使用的供应商写回对应应用的 live 配置。
 * 不抛出异常，由调用方根据返回值决定提示策略。
 */
export async function syncCurrentProvidersLiveSafe(): Promise<{
  ok: boolean;
  error?: Error;
}> {
  try {
    await settingsApi.syncCurrentProvidersLive();
    return { ok: true };
  } catch (err) {
    const error = err instanceof Error ? err : new Error(String(err ?? ""));
    return { ok: false, error };
  }
}
</file>

<file path="src/utils/providerMetaUtils.ts">
import type { CustomEndpoint, ProviderMeta } from "@/types";

/**
 * 合并供应商元数据中的自定义端点。
 * - 当 customEndpoints 为空对象时，明确删除自定义端点但保留其它元数据。
 * - 当 customEndpoints 为 null/undefined 时，不修改端点（保留原有端点）。
 * - 当 customEndpoints 存在时，覆盖原有自定义端点。
 * - 若结果为空对象且非明确清空场景则返回 undefined，避免写入空 meta。
 */
export function mergeProviderMeta(
  initialMeta: ProviderMeta | undefined,
  customEndpoints: Record<string, CustomEndpoint> | null | undefined,
): ProviderMeta | undefined {
  const hasCustomEndpoints =
    !!customEndpoints && Object.keys(customEndpoints).length > 0;

  // 明确清空：传入空对象（非 null/undefined）表示用户想要删除所有端点
  const isExplicitClear =
    customEndpoints !== null &&
    customEndpoints !== undefined &&
    Object.keys(customEndpoints).length === 0;

  if (hasCustomEndpoints) {
    return {
      ...(initialMeta ? { ...initialMeta } : {}),
      custom_endpoints: customEndpoints!,
    };
  }

  // 明确清空端点
  if (isExplicitClear) {
    if (!initialMeta) {
      // 新供应商且用户没有添加端点（理论上不会到这里）
      return undefined;
    }

    if ("custom_endpoints" in initialMeta) {
      const { custom_endpoints, ...rest } = initialMeta;
      // 保留其他字段（如 usage_script）
      // 即使 rest 为空，也要返回空对象（让后端知道要清空 meta）
      return Object.keys(rest).length > 0 ? rest : {};
    }

    // initialMeta 中本来就没有 custom_endpoints
    return { ...initialMeta };
  }

  // null/undefined：用户没有修改端点，保持不变
  if (!initialMeta) {
    return undefined;
  }

  if ("custom_endpoints" in initialMeta) {
    const { custom_endpoints, ...rest } = initialMeta;
    return Object.keys(rest).length > 0 ? rest : undefined;
  }

  return { ...initialMeta };
}
</file>

<file path="src/utils/textNormalization.ts">
/**
 * 将常见的中文/全角/弯引号统一为 ASCII 引号，以避免 TOML 解析失败。
 * - 双引号：” “ „ ‟ ＂ → "
 * - 单引号：’ ‘ ＇ → '
 * 保守起见，不替换书名号/角引号（《》、「」等），避免误伤内容语义。
 */
export const normalizeQuotes = (text: string): string => {
  if (!text) return text;
  return (
    text
      // 双引号族 → "
      .replace(/[“”„‟＂]/g, '"')
      // 单引号族 → '
      .replace(/[‘’＇]/g, "'")
  );
};

/**
 * 专用于 TOML 文本的归一化；目前等同于 normalizeQuotes，后续可扩展（如空白、行尾等）。
 */
export const normalizeTomlText = (text: string): string =>
  normalizeQuotes(text);
</file>

<file path="src/utils/tomlUtils.ts">
import { parse as parseToml, stringify as stringifyToml } from "smol-toml";
import { normalizeTomlText } from "@/utils/textNormalization";
import { McpServerSpec } from "../types";

/**
 * 验证 TOML 格式并转换为 JSON 对象
 * @param text TOML 文本
 * @returns 错误信息（空字符串表示成功）
 */
export const validateToml = (text: string): string => {
  if (!text.trim()) return "";
  try {
    const normalized = normalizeTomlText(text);
    const parsed = parseToml(normalized);
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
      return "mustBeObject";
    }
    return "";
  } catch (e: any) {
    // 返回底层错误信息，由上层进行 i18n 包装
    return e?.message || "parseError";
  }
};

/**
 * 将 McpServerSpec 对象转换为 TOML 字符串
 * 使用 @iarna/toml 的 stringify，自动处理转义与嵌套表
 * 保留所有字段（包括扩展字段如 timeout_ms）
 */
export const mcpServerToToml = (server: McpServerSpec): string => {
  // 先复制所有字段（保留扩展字段）
  const obj: any = { ...server };

  // 去除未定义字段，确保输出更干净
  for (const k of Object.keys(obj)) {
    if (obj[k] === undefined) delete obj[k];
  }

  // stringify 默认会带换行，做一次 trim 以适配文本框展示
  return stringifyToml(obj).trim();
};

/**
 * 将 TOML 文本转换为 McpServerSpec 对象（单个服务器配置）
 * 支持两种格式：
 * 1. 直接的服务器配置（type, command, args 等）
 * 2. [mcp_servers.<id>] 格式（推荐，取第一个服务器）
 * 3. [mcp.servers.<id>] 错误格式（容错解析，同样取第一个服务器）
 * @param tomlText TOML 文本
 * @returns McpServer 对象
 * @throws 解析或转换失败时抛出错误
 */
export const tomlToMcpServer = (tomlText: string): McpServerSpec => {
  if (!tomlText.trim()) {
    throw new Error("TOML 内容不能为空");
  }

  const parsed = parseToml(normalizeTomlText(tomlText));

  // 情况 1: 直接是服务器配置（包含 type/command/url 等字段）
  if (
    parsed.type ||
    parsed.command ||
    parsed.url ||
    parsed.args ||
    parsed.env
  ) {
    return normalizeServerConfig(parsed);
  }

  // 情况 2: [mcp_servers.<id>] 格式（推荐）
  if (parsed.mcp_servers && typeof parsed.mcp_servers === "object") {
    const serverIds = Object.keys(parsed.mcp_servers);
    if (serverIds.length > 0) {
      const firstServer = (parsed.mcp_servers as any)[serverIds[0]];
      return normalizeServerConfig(firstServer);
    }
  }

  // 情况 3: [mcp.servers.<id>] 错误格式（容错解析）
  if (parsed.mcp && typeof parsed.mcp === "object") {
    const mcpObj = parsed.mcp as any;
    if (mcpObj.servers && typeof mcpObj.servers === "object") {
      const serverIds = Object.keys(mcpObj.servers);
      if (serverIds.length > 0) {
        const firstServer = mcpObj.servers[serverIds[0]];
        return normalizeServerConfig(firstServer);
      }
    }
  }

  throw new Error(
    "无法识别的 TOML 格式。请提供单个 MCP 服务器配置，或使用 [mcp_servers.<id>] 格式",
  );
};

/**
 * 规范化服务器配置对象为 McpServer 格式
 * 保留所有字段（包括扩展字段如 timeout_ms）
 */
function normalizeServerConfig(config: any): McpServerSpec {
  if (!config || typeof config !== "object") {
    throw new Error("服务器配置必须是对象");
  }

  const type = (config.type as string) || "stdio";

  // 已知字段列表（用于后续排除）
  const knownFields = new Set<string>();

  if (type === "stdio") {
    if (!config.command || typeof config.command !== "string") {
      throw new Error("stdio 类型的 MCP 服务器必须包含 command 字段");
    }

    const server: McpServerSpec = {
      type: "stdio",
      command: config.command,
    };
    knownFields.add("type");
    knownFields.add("command");

    // 可选字段
    if (config.args && Array.isArray(config.args)) {
      server.args = config.args.map((arg: any) => String(arg));
      knownFields.add("args");
    }
    if (config.env && typeof config.env === "object") {
      const env: Record<string, string> = {};
      for (const [k, v] of Object.entries(config.env)) {
        env[k] = String(v);
      }
      server.env = env;
      knownFields.add("env");
    }
    if (config.cwd && typeof config.cwd === "string") {
      server.cwd = config.cwd;
      knownFields.add("cwd");
    }

    // 保留所有未知字段（如 timeout_ms 等扩展字段）
    for (const key of Object.keys(config)) {
      if (!knownFields.has(key)) {
        server[key] = config[key];
      }
    }

    return server;
  } else if (type === "http" || type === "sse") {
    if (!config.url || typeof config.url !== "string") {
      throw new Error(`${type} 类型的 MCP 服务器必须包含 url 字段`);
    }

    const server: McpServerSpec = {
      type: type as "http" | "sse",
      url: config.url,
    };
    knownFields.add("type");
    knownFields.add("url");

    // 可选字段
    if (config.headers && typeof config.headers === "object") {
      const headers: Record<string, string> = {};
      for (const [k, v] of Object.entries(config.headers)) {
        headers[k] = String(v);
      }
      server.headers = headers;
      knownFields.add("headers");
    }

    // 保留所有未知字段
    for (const key of Object.keys(config)) {
      if (!knownFields.has(key)) {
        server[key] = config[key];
      }
    }

    return server;
  } else {
    throw new Error(`不支持的 MCP 服务器类型: ${type}`);
  }
}

/**
 * 尝试从 TOML 中提取合理的服务器 ID/标题
 * @param tomlText TOML 文本
 * @returns 建议的 ID，失败返回空字符串
 */
export const extractIdFromToml = (tomlText: string): string => {
  try {
    const parsed = parseToml(normalizeTomlText(tomlText));

    // 尝试从 [mcp_servers.<id>] 或 [mcp.servers.<id>] 中提取 ID
    if (parsed.mcp_servers && typeof parsed.mcp_servers === "object") {
      const serverIds = Object.keys(parsed.mcp_servers);
      if (serverIds.length > 0) {
        return serverIds[0];
      }
    }

    if (parsed.mcp && typeof parsed.mcp === "object") {
      const mcpObj = parsed.mcp as any;
      if (mcpObj.servers && typeof mcpObj.servers === "object") {
        const serverIds = Object.keys(mcpObj.servers);
        if (serverIds.length > 0) {
          return serverIds[0];
        }
      }
    }

    // 尝试从 command 中推断
    if (parsed.command && typeof parsed.command === "string") {
      const cmd = parsed.command.split(/[\\/]/).pop() || "";
      return cmd.replace(/\.(exe|bat|sh|js|py)$/i, "");
    }
  } catch {
    // 解析失败，返回空
  }

  return "";
};
</file>

<file path="src/components/providers/FailoverPriorityBadge.tsx">
import { cn } from "@/lib/utils";
import { useTranslation } from "react-i18next";

interface FailoverPriorityBadgeProps {
  priority: number; // 1, 2, 3, ...
  className?: string;
}

/**
 * 故障转移优先级徽章
 * 显示供应商在故障转移队列中的优先级顺序
 */
export function FailoverPriorityBadge({
  priority,
  className,
}: FailoverPriorityBadgeProps) {
  const { t } = useTranslation();

  return (
    <div
      className={cn(
        "inline-flex items-center px-1.5 py-0.5 rounded text-xs font-semibold",
        "bg-emerald-500/10 text-emerald-600 dark:text-emerald-400",
        className,
      )}
      title={t("failover.priority.tooltip", {
        priority,
        defaultValue: `故障转移优先级 ${priority}`,
      })}
    >
      P{priority}
    </div>
  );
}
</file>

<file path="src/components/providers/forms/ApiKeyInput.tsx">
import React, { useState } from "react";
import { Eye, EyeOff } from "lucide-react";
import { useTranslation } from "react-i18next";

interface ApiKeyInputProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  disabled?: boolean;
  required?: boolean;
  label?: string;
  id?: string;
}

const ApiKeyInput: React.FC<ApiKeyInputProps> = ({
  value,
  onChange,
  placeholder,
  disabled = false,
  required = false,
  label = "API Key",
  id = "apiKey",
}) => {
  const { t } = useTranslation();
  const [showKey, setShowKey] = useState(false);

  const toggleShowKey = () => {
    setShowKey(!showKey);
  };

  const inputClass = `w-full px-3 py-2 pr-10 border rounded-lg text-sm transition-colors ${
    disabled
      ? "bg-muted border-border-default text-muted-foreground cursor-not-allowed"
      : "border-border-default dark:bg-gray-800 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500/20 dark:focus:ring-blue-400/20"
  }`;

  return (
    <div className="space-y-2">
      <label
        htmlFor={id}
        className="block text-sm font-medium text-gray-900 dark:text-gray-100"
      >
        {label} {required && "*"}
      </label>
      <div className="relative">
        <input
          type={showKey ? "text" : "password"}
          id={id}
          value={value}
          onChange={(e) => onChange(e.target.value)}
          placeholder={placeholder ?? t("apiKeyInput.placeholder")}
          disabled={disabled}
          required={required}
          autoComplete="off"
          className={inputClass}
        />
        {!disabled && value && (
          <button
            type="button"
            onClick={toggleShowKey}
            className="absolute inset-y-0 right-0 flex items-center pr-3 text-gray-500 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition-colors"
            aria-label={showKey ? t("apiKeyInput.hide") : t("apiKeyInput.show")}
          >
            {showKey ? <EyeOff size={16} /> : <Eye size={16} />}
          </button>
        )}
      </div>
    </div>
  );
};

export default ApiKeyInput;
</file>

<file path="src/components/providers/forms/EndpointSpeedTest.tsx">
import React, { useCallback, useEffect, useMemo, useState } from "react";
import { useTranslation } from "react-i18next";
import { Zap, Loader2, Plus, X, AlertCircle, Save } from "lucide-react";
import type { AppId } from "@/lib/api";
import { vscodeApi } from "@/lib/api/vscode";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { FullScreenPanel } from "@/components/common/FullScreenPanel";
import type { CustomEndpoint, EndpointCandidate } from "@/types";

// 端点测速超时配置（秒）
const ENDPOINT_TIMEOUT_SECS = {
  codex: 12,
  claude: 8,
  gemini: 8, // 新增 gemini
} as const;

interface TestResult {
  url: string;
  latency: number | null;
  status?: number;
  error?: string | null;
}

interface EndpointSpeedTestProps {
  appId: AppId;
  providerId?: string;
  value: string;
  onChange: (url: string) => void;
  initialEndpoints: EndpointCandidate[];
  visible?: boolean;
  onClose: () => void;
  // 新建模式：当自定义端点列表变化时回传（仅包含 isCustom 的条目）
  // 编辑模式：不使用此回调，端点直接保存到后端
  onCustomEndpointsChange?: (urls: string[]) => void;
}

interface EndpointEntry extends EndpointCandidate {
  id: string;
  latency: number | null;
  status?: number;
  error?: string | null;
}

const randomId = () => `ep_${Math.random().toString(36).slice(2, 9)}`;

const normalizeEndpointUrl = (url: string): string =>
  url.trim().replace(/\/+$/, "");

const buildInitialEntries = (
  candidates: EndpointCandidate[],
  selected: string,
): EndpointEntry[] => {
  const map = new Map<string, EndpointEntry>();
  const addCandidate = (candidate: EndpointCandidate) => {
    const sanitized = candidate.url ? normalizeEndpointUrl(candidate.url) : "";
    if (!sanitized) return;
    if (map.has(sanitized)) return;

    map.set(sanitized, {
      id: candidate.id ?? randomId(),
      url: sanitized,
      isCustom: candidate.isCustom ?? false,
      latency: null,
      status: undefined,
      error: null,
    });
  };

  candidates.forEach(addCandidate);

  const selectedUrl = normalizeEndpointUrl(selected);
  if (selectedUrl && !map.has(selectedUrl)) {
    addCandidate({ url: selectedUrl, isCustom: true });
  }

  return Array.from(map.values());
};

const EndpointSpeedTest: React.FC<EndpointSpeedTestProps> = ({
  appId,
  providerId,
  value,
  onChange,
  initialEndpoints,
  visible = true,
  onClose,
  onCustomEndpointsChange,
}) => {
  const { t } = useTranslation();
  const [entries, setEntries] = useState<EndpointEntry[]>(() =>
    buildInitialEntries(initialEndpoints, value),
  );
  const [customUrl, setCustomUrl] = useState("");
  const [addError, setAddError] = useState<string | null>(null);
  const [autoSelect, setAutoSelect] = useState(true);
  const [isTesting, setIsTesting] = useState(false);
  const [lastError, setLastError] = useState<string | null>(null);
  const [isSaving, setIsSaving] = useState(false);

  // 记录初始的自定义端点，用于对比变化
  const [initialCustomUrls, setInitialCustomUrls] = useState<Set<string>>(
    new Set(),
  );

  const normalizedSelected = normalizeEndpointUrl(value);

  const hasEndpoints = entries.length > 0;
  const isEditMode = Boolean(providerId); // 编辑模式有 providerId

  // 编辑模式：加载已保存的自定义端点
  useEffect(() => {
    let cancelled = false;

    const loadCustomEndpoints = async () => {
      try {
        if (!providerId) return; // 新建模式不加载

        const customEndpoints = await vscodeApi.getCustomEndpoints(
          appId,
          providerId,
        );

        if (cancelled) return;

        const candidates: EndpointCandidate[] = customEndpoints.map(
          (ep: CustomEndpoint) => ({
            url: ep.url,
            isCustom: true,
          }),
        );

        // 记录初始的自定义端点
        const customUrls = new Set(
          customEndpoints.map((ep) => normalizeEndpointUrl(ep.url)),
        );
        setInitialCustomUrls(customUrls);

        // 合并自定义端点与初始端点
        setEntries((prev) => {
          const map = new Map<string, EndpointEntry>();

          // 先添加现有端点（来自预设，isCustom 可能为 false）
          prev.forEach((entry) => {
            map.set(entry.url, entry);
          });

          // 合并从后端加载的自定义端点
          // 关键：如果 URL 已存在（与预设重合），需要将 isCustom 更新为 true
          // 因为它存在于数据库中，需要在 handleSave 时被正确识别
          candidates.forEach((candidate) => {
            const sanitized = normalizeEndpointUrl(candidate.url);
            if (!sanitized) return;

            const existing = map.get(sanitized);
            if (existing) {
              // URL 已存在，更新 isCustom 为 true（因为它在数据库中）
              existing.isCustom = true;
            } else {
              // URL 不存在，添加新条目
              map.set(sanitized, {
                id: randomId(),
                url: sanitized,
                isCustom: true,
                latency: null,
                status: undefined,
                error: null,
              });
            }
          });

          return Array.from(map.values());
        });
      } catch (error) {
        if (!cancelled) {
          console.error(t("endpointTest.loadEndpointsFailed"), error);
        }
      }
    };

    // 只在编辑模式下加载
    if (providerId) {
      loadCustomEndpoints();
    }

    return () => {
      cancelled = true;
    };
  }, [appId, providerId, t, initialEndpoints]);

  // 新建模式：将自定义端点变化透传给父组件（仅限 isCustom）
  // 编辑模式：不使用此回调，端点已通过 API 直接保存
  useEffect(() => {
    if (!onCustomEndpointsChange || isEditMode) return; // 编辑模式不使用回调
    try {
      const customUrls = Array.from(
        new Set(
          entries
            .filter((e) => e.isCustom)
            .map((e) => (e.url ? normalizeEndpointUrl(e.url) : ""))
            .filter(Boolean),
        ),
      );
      onCustomEndpointsChange(customUrls);
    } catch (err) {
      // ignore
    }
  }, [entries, onCustomEndpointsChange, isEditMode]);

  const sortedEntries = useMemo(() => {
    return entries.slice().sort((a: TestResult, b: TestResult) => {
      const aLatency = a.latency ?? Number.POSITIVE_INFINITY;
      const bLatency = b.latency ?? Number.POSITIVE_INFINITY;
      if (aLatency === bLatency) {
        return a.url.localeCompare(b.url);
      }
      return aLatency - bLatency;
    });
  }, [entries]);

  const handleAddEndpoint = useCallback(async () => {
    const candidate = customUrl.trim();
    let errorMsg: string | null = null;

    if (!candidate) {
      errorMsg = t("endpointTest.enterValidUrl");
    }

    let parsed: URL | null = null;
    if (!errorMsg) {
      try {
        parsed = new URL(candidate);
      } catch {
        errorMsg = t("endpointTest.invalidUrlFormat");
      }
    }

    // 明确只允许 http: 和 https:
    const allowedProtocols = ["http:", "https:"];
    if (!errorMsg && parsed && !allowedProtocols.includes(parsed.protocol)) {
      errorMsg = t("endpointTest.onlyHttps");
    }

    let sanitized = "";
    if (!errorMsg && parsed) {
      sanitized = normalizeEndpointUrl(parsed.toString());
      // 使用当前 entries 做去重校验
      const isDuplicate = entries.some((entry) => entry.url === sanitized);
      if (isDuplicate) {
        errorMsg = t("endpointTest.urlExists");
      }
    }

    if (errorMsg) {
      setAddError(errorMsg);
      return;
    }

    setAddError(null);
    setLastError(null);

    // 更新本地状态（延迟保存，点击保存按钮时统一处理）
    setEntries((prev) => {
      if (prev.some((e) => e.url === sanitized)) return prev;
      return [
        ...prev,
        {
          id: randomId(),
          url: sanitized,
          isCustom: true,
          latency: null,
          status: undefined,
          error: null,
        },
      ];
    });

    if (!normalizedSelected) {
      onChange(sanitized);
    }

    setCustomUrl("");
  }, [customUrl, entries, normalizedSelected, onChange, t]);

  const handleRemoveEndpoint = useCallback(
    (entry: EndpointEntry) => {
      // 清空之前的错误提示
      setLastError(null);

      // 更新本地状态（延迟保存，点击保存按钮时统一处理）
      setEntries((prev) => {
        const next = prev.filter((item) => item.id !== entry.id);
        if (entry.url === normalizedSelected) {
          const fallback = next[0];
          onChange(fallback ? fallback.url : "");
        }
        return next;
      });
    },
    [normalizedSelected, onChange],
  );

  const runSpeedTest = useCallback(async () => {
    const urls = entries.map((entry) => entry.url);
    if (urls.length === 0) {
      setLastError(t("endpointTest.pleaseAddEndpoint"));
      return;
    }

    setIsTesting(true);
    setLastError(null);

    // 清空所有延迟数据，显示 loading 状态
    setEntries((prev) =>
      prev.map((entry) => ({
        ...entry,
        latency: null,
        status: undefined,
        error: null,
      })),
    );

    try {
      const results = await vscodeApi.testApiEndpoints(urls, {
        timeoutSecs: ENDPOINT_TIMEOUT_SECS[appId],
      });

      const resultMap = new Map(
        results.map((item) => [normalizeEndpointUrl(item.url), item]),
      );

      setEntries((prev) =>
        prev.map((entry) => {
          const match = resultMap.get(entry.url);
          if (!match) {
            return {
              ...entry,
              latency: null,
              status: undefined,
              error: t("endpointTest.noResult"),
            };
          }
          return {
            ...entry,
            latency:
              typeof match.latency === "number"
                ? Math.round(match.latency)
                : null,
            status: match.status,
            error: match.error ?? null,
          };
        }),
      );

      if (autoSelect) {
        const successful = results
          .filter(
            (item) => typeof item.latency === "number" && item.latency !== null,
          )
          .sort((a, b) => (a.latency! || 0) - (b.latency! || 0));
        const best = successful[0];
        if (best && best.url && best.url !== normalizedSelected) {
          onChange(best.url);
        }
      }
    } catch (error) {
      const message =
        error instanceof Error
          ? error.message
          : `${t("endpointTest.testFailed", { error: String(error) })}`;
      setLastError(message);
    } finally {
      setIsTesting(false);
    }
  }, [entries, autoSelect, appId, normalizedSelected, onChange, t]);

  const handleSelect = useCallback(
    (url: string) => {
      if (!url || url === normalizedSelected) return;
      onChange(url);
    },
    [normalizedSelected, onChange],
  );

  // 保存端点变更
  const handleSave = useCallback(async () => {
    // 编辑模式：对比初始端点和当前端点，批量保存变更
    if (isEditMode && providerId) {
      setIsSaving(true);
      setLastError(null);

      try {
        // 获取当前的自定义端点
        const currentCustomUrls = new Set(
          entries
            .filter((e) => e.isCustom)
            .map((e) => normalizeEndpointUrl(e.url)),
        );

        // 找出新增的端点
        const toAdd = Array.from(currentCustomUrls).filter(
          (url) => !initialCustomUrls.has(url),
        );

        // 找出删除的端点
        const toRemove = Array.from(initialCustomUrls).filter(
          (url) => !currentCustomUrls.has(url),
        );

        // 批量添加
        for (const url of toAdd) {
          await vscodeApi.addCustomEndpoint(appId, providerId, url);
        }

        // 批量删除
        for (const url of toRemove) {
          await vscodeApi.removeCustomEndpoint(appId, providerId, url);
        }

        // 更新初始端点列表
        setInitialCustomUrls(currentCustomUrls);
      } catch (error) {
        const message =
          error instanceof Error ? error.message : t("endpointTest.saveFailed");
        setLastError(message);
        setIsSaving(false);
        return;
      } finally {
        setIsSaving(false);
      }
    }

    // 关闭弹窗
    onClose();
  }, [isEditMode, providerId, entries, initialCustomUrls, appId, onClose, t]);

  if (!visible) return null;

  const footer = (
    <div className="flex items-center gap-2">
      <Button
        type="button"
        variant="outline"
        onClick={(event) => {
          event.preventDefault();
          onClose();
        }}
        disabled={isSaving}
      >
        {t("common.cancel")}
      </Button>
      <Button
        type="button"
        onClick={handleSave}
        disabled={isSaving}
        className="gap-2"
      >
        {isSaving ? (
          <>
            <Loader2 className="w-4 h-4 animate-spin" />
            {t("common.saving")}
          </>
        ) : (
          <>
            <Save className="w-4 h-4" />
            {t("common.save")}
          </>
        )}
      </Button>
    </div>
  );

  return (
    <FullScreenPanel
      isOpen={visible}
      title={t("endpointTest.title")}
      onClose={onClose}
      footer={footer}
    >
      <div className="glass rounded-xl p-6 border border-white/10 flex flex-col gap-6">
        {/* 测速控制栏 */}
        <div className="flex items-center justify-between">
          <div className="text-sm text-muted-foreground">
            {entries.length} {t("endpointTest.endpoints")}
          </div>
          <div className="flex items-center gap-3">
            <label className="flex items-center gap-1.5 text-xs text-gray-600 dark:text-gray-400">
              <input
                type="checkbox"
                checked={autoSelect}
                onChange={(event) => setAutoSelect(event.target.checked)}
                className="h-3.5 w-3.5 rounded border-border-default bg-background text-primary focus:ring-2 focus:ring-primary/20"
              />
              {t("endpointTest.autoSelect")}
            </label>
            <Button
              type="button"
              onClick={runSpeedTest}
              disabled={isTesting || !hasEndpoints}
              size="sm"
              className="h-7 w-24 gap-1.5 text-xs bg-primary text-primary-foreground hover:bg-primary/90 disabled:opacity-60"
            >
              {isTesting ? (
                <>
                  <Loader2 className="h-3.5 w-3.5 animate-spin" />
                  {t("endpointTest.testing")}
                </>
              ) : (
                <>
                  <Zap className="h-3.5 w-3.5" />
                  {t("endpointTest.testSpeed")}
                </>
              )}
            </Button>
          </div>
        </div>

        {/* 添加输入 */}
        <div className="space-y-1.5">
          <div className="flex gap-2">
            <Input
              type="url"
              value={customUrl}
              placeholder={t("endpointTest.addEndpointPlaceholder")}
              onChange={(event) => setCustomUrl(event.target.value)}
              onKeyDown={(event) => {
                if (event.key === "Enter") {
                  event.preventDefault();
                  handleAddEndpoint();
                }
              }}
              className="flex-1"
            />
            <Button
              type="button"
              onClick={handleAddEndpoint}
              variant="outline"
              size="icon"
            >
              <Plus className="h-4 w-4" />
            </Button>
          </div>
          {addError && (
            <div className="flex items-center gap-1.5 text-xs text-red-600 dark:text-red-400">
              <AlertCircle className="h-3 w-3" />
              {addError}
            </div>
          )}
        </div>

        {/* 端点列表 */}
        {hasEndpoints ? (
          <div className="space-y-2">
            {sortedEntries.map((entry) => {
              const isSelected = normalizedSelected === entry.url;
              const latency = entry.latency;

              return (
                <div
                  key={entry.id}
                  onClick={() => handleSelect(entry.url)}
                  className={`group flex cursor-pointer items-center justify-between px-3 py-2.5 rounded-lg border transition text-foreground ${
                    isSelected
                      ? "border-primary/70 bg-primary/5 shadow-sm"
                      : "border-border-default bg-background hover:bg-muted"
                  }`}
                >
                  <div className="flex min-w-0 flex-1 items-center gap-3">
                    {/* 选择指示器 */}
                    <div
                      className={`h-1.5 w-1.5 flex-shrink-0 rounded-full transition ${
                        isSelected
                          ? "bg-blue-500 dark:bg-blue-400"
                          : "bg-gray-300 dark:bg-gray-700"
                      }`}
                    />

                    {/* 内容 */}
                    <div className="min-w-0 flex-1">
                      <div className="truncate text-sm text-foreground">
                        {entry.url}
                      </div>
                    </div>
                  </div>

                  {/* 右侧信息 */}
                  <div className="flex items-center gap-2">
                    {latency !== null ? (
                      <div className="text-right">
                        <div
                          className={`font-mono text-sm font-medium ${
                            latency < 300
                              ? "text-emerald-600 dark:text-emerald-400"
                              : latency < 500
                                ? "text-yellow-600 dark:text-yellow-400"
                                : latency < 800
                                  ? "text-orange-600 dark:text-orange-400"
                                  : "text-red-600 dark:text-red-400"
                          }`}
                        >
                          {latency}ms
                        </div>
                        <div className="text-[10px] text-gray-500 dark:text-gray-400">
                          {entry.status
                            ? t("endpointTest.status", { code: entry.status })
                            : t("endpointTest.notTested")}
                        </div>
                      </div>
                    ) : isTesting ? (
                      <Loader2 className="h-4 w-4 animate-spin text-gray-400" />
                    ) : entry.error ? (
                      <div className="text-xs text-gray-400">
                        {t("endpointTest.failed")}
                      </div>
                    ) : (
                      <div className="text-xs text-gray-400">—</div>
                    )}

                    <button
                      type="button"
                      onClick={(event) => {
                        event.stopPropagation();
                        handleRemoveEndpoint(entry);
                      }}
                      className="opacity-0 transition hover:text-red-600 group-hover:opacity-100 dark:hover:text-red-400"
                    >
                      <X className="h-4 w-4" />
                    </button>
                  </div>
                </div>
              );
            })}
          </div>
        ) : (
          <div className="rounded-md border border-dashed border-border-default bg-muted px-4 py-8 text-center text-sm text-muted-foreground">
            {t("endpointTest.empty")}
          </div>
        )}

        {/* 错误提示 */}
        {lastError && (
          <div className="flex items-center gap-1.5 text-xs text-red-600 dark:text-red-400">
            <AlertCircle className="h-3 w-3" />
            {lastError}
          </div>
        )}
      </div>
    </FullScreenPanel>
  );
};

export default EndpointSpeedTest;
</file>

<file path="src/components/providers/forms/hooks/useApiKeyState.ts">
import { useEffect, useState, useCallback } from "react";
import type { ProviderCategory } from "@/types";
import {
  getApiKeyFromConfig,
  setApiKeyInConfig,
  hasApiKeyField,
} from "@/utils/providerConfigUtils";

interface UseApiKeyStateProps {
  initialConfig?: string;
  onConfigChange: (config: string) => void;
  selectedPresetId: string | null;
  category?: ProviderCategory;
  appType?: string;
}

/**
 * 管理 API Key 输入状态
 * 自动同步 API Key 和 JSON 配置
 */
export function useApiKeyState({
  initialConfig,
  onConfigChange,
  selectedPresetId,
  category,
  appType,
}: UseApiKeyStateProps) {
  const [apiKey, setApiKey] = useState(() => {
    if (initialConfig) {
      return getApiKeyFromConfig(initialConfig, appType);
    }
    return "";
  });

  // 当外部通过 form.reset / 读取 live 等方式更新配置时，同步回 API Key 状态
  // - 仅在 JSON 可解析时同步，避免用户编辑 JSON 过程中因临时无效导致输入框闪烁
  useEffect(() => {
    if (!initialConfig) return;

    try {
      JSON.parse(initialConfig);
    } catch {
      return;
    }

    // 仅当配置确实包含 API Key 字段时才同步（避免无意清空用户正在输入的 key）
    if (!hasApiKeyField(initialConfig, appType)) {
      return;
    }

    const extracted = getApiKeyFromConfig(initialConfig, appType);
    if (extracted !== apiKey) {
      setApiKey(extracted);
    }
  }, [initialConfig, appType, apiKey]);

  const handleApiKeyChange = useCallback(
    (key: string) => {
      setApiKey(key);

      const configString = setApiKeyInConfig(
        initialConfig || "{}",
        key.trim(),
        {
          // 最佳实践：仅在“新增模式”且“非官方类别”时补齐缺失字段
          // - 新增模式：selectedPresetId !== null
          // - 非官方类别：category !== undefined && category !== "official"
          // - 官方类别：不创建字段（UI 也会禁用输入框）
          // - 未传入 category：不创建字段（避免意外行为）
          createIfMissing:
            selectedPresetId !== null &&
            category !== undefined &&
            category !== "official",
          appType,
        },
      );

      onConfigChange(configString);
    },
    [initialConfig, selectedPresetId, category, appType, onConfigChange],
  );

  const showApiKey = useCallback(
    (config: string, isEditMode: boolean) => {
      return (
        selectedPresetId !== null ||
        (isEditMode && hasApiKeyField(config, appType))
      );
    },
    [selectedPresetId, appType],
  );

  return {
    apiKey,
    setApiKey,
    handleApiKeyChange,
    showApiKey,
  };
}
</file>

<file path="src/components/providers/forms/hooks/useBaseUrlState.ts">
import { useState, useCallback, useRef, useEffect } from "react";
import {
  extractCodexBaseUrl,
  setCodexBaseUrl as setCodexBaseUrlInConfig,
} from "@/utils/providerConfigUtils";
import type { ProviderCategory } from "@/types";

interface UseBaseUrlStateProps {
  appType: "claude" | "codex" | "gemini";
  category: ProviderCategory | undefined;
  settingsConfig: string;
  codexConfig?: string;
  onSettingsConfigChange: (config: string) => void;
  onCodexConfigChange?: (config: string) => void;
}

/**
 * 管理 Base URL 状态
 * 支持 Claude (JSON) 和 Codex (TOML) 两种格式
 */
export function useBaseUrlState({
  appType,
  category,
  settingsConfig,
  codexConfig,
  onSettingsConfigChange,
  onCodexConfigChange,
}: UseBaseUrlStateProps) {
  const [baseUrl, setBaseUrl] = useState("");
  const [codexBaseUrl, setCodexBaseUrl] = useState("");
  const [geminiBaseUrl, setGeminiBaseUrl] = useState("");
  const isUpdatingRef = useRef(false);

  // 从配置同步到 state（Claude）
  useEffect(() => {
    if (appType !== "claude") return;
    // 只有 official 类别不显示 Base URL 输入框，其他类别都需要回填
    if (category === "official") return;
    if (isUpdatingRef.current) return;

    try {
      const config = JSON.parse(settingsConfig || "{}");
      const envUrl: unknown = config?.env?.ANTHROPIC_BASE_URL;
      if (typeof envUrl === "string" && envUrl && envUrl.trim() !== baseUrl) {
        setBaseUrl(envUrl.trim());
      }
    } catch {
      // ignore
    }
  }, [appType, category, settingsConfig, baseUrl]);

  // 从配置同步到 state（Codex）
  useEffect(() => {
    if (appType !== "codex") return;
    // 只有 official 类别不显示 Base URL 输入框，其他类别都需要回填
    if (category === "official") return;
    if (isUpdatingRef.current) return;
    if (!codexConfig) return;

    const extracted = extractCodexBaseUrl(codexConfig) || "";
    if (extracted !== codexBaseUrl) {
      setCodexBaseUrl(extracted);
    }
  }, [appType, category, codexConfig, codexBaseUrl]);

  // 从Claude配置同步到 state（Gemini）
  useEffect(() => {
    if (appType !== "gemini") return;
    // 只有 official 类别不显示 Base URL 输入框，其他类别都需要回填
    if (category === "official") return;
    if (isUpdatingRef.current) return;

    try {
      const config = JSON.parse(settingsConfig || "{}");
      const envUrl: unknown = config?.env?.GOOGLE_GEMINI_BASE_URL;
      const nextUrl = typeof envUrl === "string" ? envUrl.trim() : "";
      if (nextUrl !== geminiBaseUrl) {
        setGeminiBaseUrl(nextUrl);
        setBaseUrl(nextUrl); // 也更新 baseUrl 用于 UI
      }
    } catch {
      // ignore
    }
  }, [appType, category, settingsConfig, geminiBaseUrl]);

  // 处理 Claude Base URL 变化
  const handleClaudeBaseUrlChange = useCallback(
    (url: string) => {
      const sanitized = url.trim();
      setBaseUrl(sanitized);
      isUpdatingRef.current = true;

      try {
        const config = JSON.parse(settingsConfig || "{}");
        if (!config.env) {
          config.env = {};
        }
        config.env.ANTHROPIC_BASE_URL = sanitized;
        onSettingsConfigChange(JSON.stringify(config, null, 2));
      } catch {
        // ignore
      } finally {
        setTimeout(() => {
          isUpdatingRef.current = false;
        }, 0);
      }
    },
    [settingsConfig, onSettingsConfigChange],
  );

  // 处理 Codex Base URL 变化
  const handleCodexBaseUrlChange = useCallback(
    (url: string) => {
      const sanitized = url.trim();
      setCodexBaseUrl(sanitized);

      if (!sanitized || !onCodexConfigChange) {
        return;
      }

      isUpdatingRef.current = true;
      const updatedConfig = setCodexBaseUrlInConfig(
        codexConfig || "",
        sanitized,
      );
      onCodexConfigChange(updatedConfig);

      setTimeout(() => {
        isUpdatingRef.current = false;
      }, 0);
    },
    [codexConfig, onCodexConfigChange],
  );

  // 处理 Gemini Base URL 变化
  const handleGeminiBaseUrlChange = useCallback(
    (url: string) => {
      const sanitized = url.trim();
      setGeminiBaseUrl(sanitized);
      setBaseUrl(sanitized); // 也更新 baseUrl 用于 UI
      isUpdatingRef.current = true;

      try {
        const config = JSON.parse(settingsConfig || "{}");
        if (!config.env) {
          config.env = {};
        }
        config.env.GOOGLE_GEMINI_BASE_URL = sanitized;
        onSettingsConfigChange(JSON.stringify(config, null, 2));
      } catch {
        // ignore
      } finally {
        setTimeout(() => {
          isUpdatingRef.current = false;
        }, 0);
      }
    },
    [settingsConfig, onSettingsConfigChange],
  );

  return {
    baseUrl,
    setBaseUrl,
    codexBaseUrl,
    setCodexBaseUrl,
    geminiBaseUrl,
    setGeminiBaseUrl,
    handleClaudeBaseUrlChange,
    handleCodexBaseUrlChange,
    handleGeminiBaseUrlChange,
  };
}
</file>

<file path="src/components/providers/forms/hooks/useCodexConfigState.ts">
import { useState, useCallback, useEffect, useRef } from "react";
import {
  extractCodexBaseUrl,
  setCodexBaseUrl as setCodexBaseUrlInConfig,
  extractCodexModelName,
  setCodexModelName as setCodexModelNameInConfig,
} from "@/utils/providerConfigUtils";
import { normalizeTomlText } from "@/utils/textNormalization";

interface UseCodexConfigStateProps {
  initialData?: {
    settingsConfig?: Record<string, unknown>;
  };
}

/**
 * 管理 Codex 配置状态
 * Codex 配置包含两部分：auth.json (JSON) 和 config.toml (TOML 字符串)
 */
export function useCodexConfigState({ initialData }: UseCodexConfigStateProps) {
  const [codexAuth, setCodexAuthState] = useState("");
  const [codexConfig, setCodexConfigState] = useState("");
  const [codexApiKey, setCodexApiKey] = useState("");
  const [codexBaseUrl, setCodexBaseUrl] = useState("");
  const [codexModelName, setCodexModelName] = useState("");
  const [codexAuthError, setCodexAuthError] = useState("");

  const isUpdatingCodexBaseUrlRef = useRef(false);
  const isUpdatingCodexModelNameRef = useRef(false);

  // 初始化 Codex 配置（编辑模式）
  useEffect(() => {
    if (!initialData) return;

    const config = initialData.settingsConfig;
    if (typeof config === "object" && config !== null) {
      // 设置 auth.json
      const auth = (config as any).auth || {};
      setCodexAuthState(JSON.stringify(auth, null, 2));

      // 设置 config.toml
      const configStr =
        typeof (config as any).config === "string"
          ? (config as any).config
          : "";
      setCodexConfigState(configStr);

      // 提取 Base URL
      const initialBaseUrl = extractCodexBaseUrl(configStr);
      if (initialBaseUrl) {
        setCodexBaseUrl(initialBaseUrl);
      }

      // 提取 Model Name
      const initialModelName = extractCodexModelName(configStr);
      if (initialModelName) {
        setCodexModelName(initialModelName);
      }

      // 提取 API Key
      try {
        if (auth && typeof auth.OPENAI_API_KEY === "string") {
          setCodexApiKey(auth.OPENAI_API_KEY);
        }
      } catch {
        // ignore
      }
    }
  }, [initialData]);

  // 与 TOML 配置保持基础 URL 同步
  useEffect(() => {
    if (isUpdatingCodexBaseUrlRef.current) {
      return;
    }
    const extracted = extractCodexBaseUrl(codexConfig) || "";
    if (extracted !== codexBaseUrl) {
      setCodexBaseUrl(extracted);
    }
  }, [codexConfig, codexBaseUrl]);

  // 与 TOML 配置保持模型名称同步
  useEffect(() => {
    if (isUpdatingCodexModelNameRef.current) {
      return;
    }
    const extracted = extractCodexModelName(codexConfig) || "";
    if (extracted !== codexModelName) {
      setCodexModelName(extracted);
    }
  }, [codexConfig, codexModelName]);

  // 获取 API Key（从 auth JSON）
  const getCodexAuthApiKey = useCallback((authString: string): string => {
    try {
      const auth = JSON.parse(authString || "{}");
      return typeof auth.OPENAI_API_KEY === "string" ? auth.OPENAI_API_KEY : "";
    } catch {
      return "";
    }
  }, []);

  // 从 codexAuth 中提取并同步 API Key
  useEffect(() => {
    const extractedKey = getCodexAuthApiKey(codexAuth);
    if (extractedKey !== codexApiKey) {
      setCodexApiKey(extractedKey);
    }
  }, [codexAuth, codexApiKey]);

  // 验证 Codex Auth JSON
  const validateCodexAuth = useCallback((value: string): string => {
    if (!value.trim()) return "";
    try {
      const parsed = JSON.parse(value);
      if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
        return "Auth JSON must be an object";
      }
      return "";
    } catch {
      return "Invalid JSON format";
    }
  }, []);

  // 设置 auth 并验证
  const setCodexAuth = useCallback(
    (value: string) => {
      setCodexAuthState(value);
      setCodexAuthError(validateCodexAuth(value));
    },
    [validateCodexAuth],
  );

  // 设置 config (支持函数更新)
  const setCodexConfig = useCallback(
    (value: string | ((prev: string) => string)) => {
      setCodexConfigState((prev) =>
        typeof value === "function"
          ? (value as (input: string) => string)(prev)
          : value,
      );
    },
    [],
  );

  // 处理 Codex API Key 输入并写回 auth.json
  const handleCodexApiKeyChange = useCallback(
    (key: string) => {
      const trimmed = key.trim();
      setCodexApiKey(trimmed);
      try {
        const auth = JSON.parse(codexAuth || "{}");
        auth.OPENAI_API_KEY = trimmed;
        setCodexAuth(JSON.stringify(auth, null, 2));
      } catch {
        // ignore
      }
    },
    [codexAuth, setCodexAuth],
  );

  // 处理 Codex Base URL 变化
  const handleCodexBaseUrlChange = useCallback(
    (url: string) => {
      const sanitized = url.trim();
      setCodexBaseUrl(sanitized);

      if (!sanitized) {
        return;
      }

      isUpdatingCodexBaseUrlRef.current = true;
      setCodexConfig((prev) => setCodexBaseUrlInConfig(prev, sanitized));
      setTimeout(() => {
        isUpdatingCodexBaseUrlRef.current = false;
      }, 0);
    },
    [setCodexConfig],
  );

  // 处理 Codex Model Name 变化
  const handleCodexModelNameChange = useCallback(
    (modelName: string) => {
      const trimmed = modelName.trim();
      setCodexModelName(trimmed);

      if (!trimmed) {
        return;
      }

      isUpdatingCodexModelNameRef.current = true;
      setCodexConfig((prev) => setCodexModelNameInConfig(prev, trimmed));
      setTimeout(() => {
        isUpdatingCodexModelNameRef.current = false;
      }, 0);
    },
    [setCodexConfig],
  );

  // 处理 config 变化（同步 Base URL 和 Model Name）
  const handleCodexConfigChange = useCallback(
    (value: string) => {
      // 归一化中文/全角/弯引号，避免 TOML 解析报错
      const normalized = normalizeTomlText(value);
      setCodexConfig(normalized);

      if (!isUpdatingCodexBaseUrlRef.current) {
        const extracted = extractCodexBaseUrl(normalized) || "";
        if (extracted !== codexBaseUrl) {
          setCodexBaseUrl(extracted);
        }
      }

      if (!isUpdatingCodexModelNameRef.current) {
        const extractedModel = extractCodexModelName(normalized) || "";
        if (extractedModel !== codexModelName) {
          setCodexModelName(extractedModel);
        }
      }
    },
    [setCodexConfig, codexBaseUrl, codexModelName],
  );

  // 重置配置（用于预设切换）
  const resetCodexConfig = useCallback(
    (auth: Record<string, unknown>, config: string) => {
      const authString = JSON.stringify(auth, null, 2);
      setCodexAuth(authString);
      setCodexConfig(config);

      const baseUrl = extractCodexBaseUrl(config);
      if (baseUrl) {
        setCodexBaseUrl(baseUrl);
      }

      const modelName = extractCodexModelName(config);
      if (modelName) {
        setCodexModelName(modelName);
      } else {
        setCodexModelName("");
      }

      // 提取 API Key
      try {
        if (auth && typeof auth.OPENAI_API_KEY === "string") {
          setCodexApiKey(auth.OPENAI_API_KEY);
        } else {
          setCodexApiKey("");
        }
      } catch {
        setCodexApiKey("");
      }
    },
    [setCodexAuth, setCodexConfig],
  );

  return {
    codexAuth,
    codexConfig,
    codexApiKey,
    codexBaseUrl,
    codexModelName,
    codexAuthError,
    setCodexAuth,
    setCodexConfig,
    handleCodexApiKeyChange,
    handleCodexBaseUrlChange,
    handleCodexModelNameChange,
    handleCodexConfigChange,
    resetCodexConfig,
    getCodexAuthApiKey,
    validateCodexAuth,
  };
}
</file>

<file path="src/components/providers/ProviderEmptyState.tsx">
import { Users } from "lucide-react";
import { useTranslation } from "react-i18next";
import { Button } from "@/components/ui/button";

interface ProviderEmptyStateProps {
  onCreate?: () => void;
}

export function ProviderEmptyState({ onCreate }: ProviderEmptyStateProps) {
  const { t } = useTranslation();

  return (
    <div className="flex flex-col items-center justify-center rounded-lg border border-dashed border-border p-10 text-center">
      <div className="mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-muted">
        <Users className="h-7 w-7 text-muted-foreground" />
      </div>
      <h3 className="text-lg font-semibold">{t("provider.noProviders")}</h3>
      <p className="mt-2 max-w-sm text-sm text-muted-foreground">
        {t("provider.noProvidersDescription")}
      </p>
      {onCreate && (
        <Button className="mt-6" onClick={onCreate}>
          {t("provider.addProvider")}
        </Button>
      )}
    </div>
  );
}
</file>

<file path="src/components/ui/accordion.tsx">
import * as React from "react";
import * as AccordionPrimitive from "@radix-ui/react-accordion";
import { ChevronDown } from "lucide-react";

import { cn } from "@/lib/utils";

const Accordion = AccordionPrimitive.Root;

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
));
AccordionItem.displayName = "AccordionItem";

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
));
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
));

AccordionContent.displayName = AccordionPrimitive.Content.displayName;

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent };
</file>

<file path="src/components/ui/alert.tsx">
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
));
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
));
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
));
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertTitle, AlertDescription };
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react";
import { cn } from "@/lib/utils";

export type InputProps = React.InputHTMLAttributes<HTMLInputElement>;

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-border-default bg-background text-foreground px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-blue-500/20 dark:focus:ring-blue-400/20 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };
</file>

<file path="src/components/ui/switch.tsx">
import * as React from "react";
import * as SwitchPrimitives from "@radix-ui/react-switch";
import { cn } from "@/lib/utils";

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    ref={ref}
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-emerald-500 dark:data-[state=checked]:bg-emerald-600 data-[state=unchecked]:bg-gray-200 dark:data-[state=unchecked]:bg-gray-900",
      className,
    )}
    {...props}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-white dark:bg-gray-400 shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0",
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };
</file>

<file path="src/components/ui/tabs.tsx">
import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";
import { cn } from "@/lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center gap-1 rounded-md bg-muted p-1 text-muted-foreground",
      className,
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex min-w-[120px] items-center justify-center whitespace-nowrap rounded-md px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-blue-500 data-[state=active]:text-white data-[state=active]:shadow-sm dark:data-[state=active]:bg-blue-600 data-[state=inactive]:opacity-60 data-[state=inactive]:hover:opacity-100 data-[state=inactive]:hover:bg-muted/50",
      className,
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className,
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };
</file>

<file path="src/lib/api/usage.ts">
import { invoke } from "@tauri-apps/api/core";
import type {
  UsageSummary,
  DailyStats,
  ProviderStats,
  ModelStats,
  RequestLog,
  LogFilters,
  ModelPricing,
  ProviderLimitStatus,
  PaginatedLogs,
} from "@/types/usage";
import type { UsageResult } from "@/types";
import type { AppId } from "./types";

export const usageApi = {
  // Provider usage script methods
  query: async (providerId: string, appId: AppId): Promise<UsageResult> => {
    return invoke("queryProviderUsage", { providerId, app: appId });
  },

  testScript: async (
    providerId: string,
    appId: AppId,
    scriptCode: string,
    timeout?: number,
    apiKey?: string,
    baseUrl?: string,
    accessToken?: string,
    userId?: string,
  ): Promise<UsageResult> => {
    return invoke("testUsageScript", {
      providerId,
      app: appId,
      scriptCode,
      timeout,
      apiKey,
      baseUrl,
      accessToken,
      userId,
    });
  },

  // Proxy usage statistics methods
  getUsageSummary: async (
    startDate?: number,
    endDate?: number,
  ): Promise<UsageSummary> => {
    return invoke("get_usage_summary", { startDate, endDate });
  },

  getUsageTrends: async (days: number): Promise<DailyStats[]> => {
    return invoke("get_usage_trends", { days });
  },

  getProviderStats: async (): Promise<ProviderStats[]> => {
    return invoke("get_provider_stats");
  },

  getModelStats: async (): Promise<ModelStats[]> => {
    return invoke("get_model_stats");
  },

  getRequestLogs: async (
    filters: LogFilters,
    page: number = 0,
    pageSize: number = 20,
  ): Promise<PaginatedLogs> => {
    return invoke("get_request_logs", {
      filters,
      page,
      pageSize,
    });
  },

  getRequestDetail: async (requestId: string): Promise<RequestLog | null> => {
    return invoke("get_request_detail", { requestId });
  },

  getModelPricing: async (): Promise<ModelPricing[]> => {
    return invoke("get_model_pricing");
  },

  updateModelPricing: async (
    modelId: string,
    displayName: string,
    inputCost: string,
    outputCost: string,
    cacheReadCost: string,
    cacheCreationCost: string,
  ): Promise<void> => {
    return invoke("update_model_pricing", {
      modelId,
      displayName,
      inputCost,
      outputCost,
      cacheReadCost,
      cacheCreationCost,
    });
  },

  deleteModelPricing: async (modelId: string): Promise<void> => {
    return invoke("delete_model_pricing", { modelId });
  },

  checkProviderLimits: async (
    providerId: string,
    appType: string,
  ): Promise<ProviderLimitStatus> => {
    return invoke("check_provider_limits", { providerId, appType });
  },
};
</file>

<file path="src/lib/query/queries.ts">
import {
  useQuery,
  type UseQueryResult,
  keepPreviousData,
} from "@tanstack/react-query";
import { providersApi, settingsApi, usageApi, type AppId } from "@/lib/api";
import type { Provider, Settings, UsageResult } from "@/types";

const sortProviders = (
  providers: Record<string, Provider>,
): Record<string, Provider> => {
  const sortedEntries = Object.values(providers)
    .sort((a, b) => {
      const indexA = a.sortIndex ?? Number.MAX_SAFE_INTEGER;
      const indexB = b.sortIndex ?? Number.MAX_SAFE_INTEGER;
      if (indexA !== indexB) {
        return indexA - indexB;
      }

      const timeA = a.createdAt ?? 0;
      const timeB = b.createdAt ?? 0;
      if (timeA === timeB) {
        return a.name.localeCompare(b.name, "zh-CN");
      }
      return timeA - timeB;
    })
    .map((provider) => [provider.id, provider] as const);

  return Object.fromEntries(sortedEntries);
};

export interface ProvidersQueryData {
  providers: Record<string, Provider>;
  currentProviderId: string;
}

export interface UseProvidersQueryOptions {
  isProxyRunning?: boolean; // 代理服务是否运行中
}

export const useProvidersQuery = (
  appId: AppId,
  options?: UseProvidersQueryOptions,
): UseQueryResult<ProvidersQueryData> => {
  const { isProxyRunning = false } = options || {};

  return useQuery({
    queryKey: ["providers", appId],
    placeholderData: keepPreviousData,
    // 当代理服务运行时，每 10 秒刷新一次供应商列表
    // 这样可以自动反映后端熔断器自动禁用代理目标的变更
    refetchInterval: isProxyRunning ? 10000 : false,
    queryFn: async () => {
      let providers: Record<string, Provider> = {};
      let currentProviderId = "";

      try {
        providers = await providersApi.getAll(appId);
      } catch (error) {
        console.error("获取供应商列表失败:", error);
      }

      try {
        currentProviderId = await providersApi.getCurrent(appId);
      } catch (error) {
        console.error("获取当前供应商失败:", error);
      }

      if (Object.keys(providers).length === 0) {
        try {
          const success = await providersApi.importDefault(appId);
          if (success) {
            providers = await providersApi.getAll(appId);
            currentProviderId = await providersApi.getCurrent(appId);
          }
        } catch (error) {
          console.error("导入默认配置失败:", error);
        }
      }

      return {
        providers: sortProviders(providers),
        currentProviderId,
      };
    },
  });
};

export const useSettingsQuery = (): UseQueryResult<Settings> => {
  return useQuery({
    queryKey: ["settings"],
    queryFn: async () => settingsApi.get(),
  });
};

export interface UseUsageQueryOptions {
  enabled?: boolean;
  autoQueryInterval?: number; // 自动查询间隔（分钟），0 表示禁用
}

export const useUsageQuery = (
  providerId: string,
  appId: AppId,
  options?: UseUsageQueryOptions,
) => {
  const { enabled = true, autoQueryInterval = 0 } = options || {};

  // 计算 staleTime：如果有自动刷新间隔，使用该间隔；否则默认 5 分钟
  // 这样可以避免切换 app 页面时重复触发查询
  const staleTime =
    autoQueryInterval > 0
      ? autoQueryInterval * 60 * 1000 // 与刷新间隔保持一致
      : 5 * 60 * 1000; // 默认 5 分钟

  const query = useQuery<UsageResult>({
    queryKey: ["usage", providerId, appId],
    queryFn: async () => usageApi.query(providerId, appId),
    enabled: enabled && !!providerId,
    refetchInterval:
      autoQueryInterval > 0
        ? Math.max(autoQueryInterval, 1) * 60 * 1000 // 最小1分钟
        : false,
    refetchIntervalInBackground: true, // 后台也继续定时查询
    refetchOnWindowFocus: false,
    retry: false,
    staleTime, // 使用动态计算的缓存时间
    gcTime: 10 * 60 * 1000, // 缓存保留 10 分钟（组件卸载后）
  });

  return {
    ...query,
    lastQueriedAt: query.dataUpdatedAt || null,
  };
};
</file>

<file path="src/lib/query/usage.ts">
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { usageApi } from "@/lib/api/usage";
import type { LogFilters } from "@/types/usage";

// Query keys
export const usageKeys = {
  all: ["usage"] as const,
  summary: (startDate?: number, endDate?: number) =>
    [...usageKeys.all, "summary", startDate, endDate] as const,
  trends: (days: number) => [...usageKeys.all, "trends", days] as const,
  providerStats: () => [...usageKeys.all, "provider-stats"] as const,
  modelStats: () => [...usageKeys.all, "model-stats"] as const,
  logs: (filters: LogFilters, page: number, pageSize: number) =>
    [...usageKeys.all, "logs", filters, page, pageSize] as const,
  detail: (requestId: string) =>
    [...usageKeys.all, "detail", requestId] as const,
  pricing: () => [...usageKeys.all, "pricing"] as const,
  limits: (providerId: string, appType: string) =>
    [...usageKeys.all, "limits", providerId, appType] as const,
};

// Hooks
export function useUsageSummary(startDate?: number, endDate?: number) {
  return useQuery({
    queryKey: usageKeys.summary(startDate, endDate),
    queryFn: () => usageApi.getUsageSummary(startDate, endDate),
  });
}

export function useUsageTrends(days: number) {
  return useQuery({
    queryKey: usageKeys.trends(days),
    queryFn: () => usageApi.getUsageTrends(days),
  });
}

export function useProviderStats() {
  return useQuery({
    queryKey: usageKeys.providerStats(),
    queryFn: usageApi.getProviderStats,
  });
}

export function useModelStats() {
  return useQuery({
    queryKey: usageKeys.modelStats(),
    queryFn: usageApi.getModelStats,
  });
}

export function useRequestLogs(
  filters: LogFilters,
  page: number = 0,
  pageSize: number = 20,
) {
  return useQuery({
    queryKey: usageKeys.logs(filters, page, pageSize),
    queryFn: () => usageApi.getRequestLogs(filters, page, pageSize),
  });
}

export function useRequestDetail(requestId: string) {
  return useQuery({
    queryKey: usageKeys.detail(requestId),
    queryFn: () => usageApi.getRequestDetail(requestId),
    enabled: !!requestId,
  });
}

export function useModelPricing() {
  return useQuery({
    queryKey: usageKeys.pricing(),
    queryFn: usageApi.getModelPricing,
  });
}

export function useProviderLimits(providerId: string, appType: string) {
  return useQuery({
    queryKey: usageKeys.limits(providerId, appType),
    queryFn: () => usageApi.checkProviderLimits(providerId, appType),
    enabled: !!providerId && !!appType,
  });
}

export function useUpdateModelPricing() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (params: {
      modelId: string;
      displayName: string;
      inputCost: string;
      outputCost: string;
      cacheReadCost: string;
      cacheCreationCost: string;
    }) =>
      usageApi.updateModelPricing(
        params.modelId,
        params.displayName,
        params.inputCost,
        params.outputCost,
        params.cacheReadCost,
        params.cacheCreationCost,
      ),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: usageKeys.pricing() });
    },
  });
}

export function useDeleteModelPricing() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (modelId: string) => usageApi.deleteModelPricing(modelId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: usageKeys.pricing() });
    },
  });
}
</file>

<file path="src/utils/formatters.ts">
/**
 * 格式化 JSON 字符串
 * @param value - 原始 JSON 字符串
 * @returns 格式化后的 JSON 字符串（2 空格缩进）
 * @throws 如果 JSON 格式无效
 */
export function formatJSON(value: string): string {
  const trimmed = value.trim();
  if (!trimmed) {
    return "";
  }
  const parsed = JSON.parse(trimmed);
  return JSON.stringify(parsed, null, 2);
}

/**
 * 智能解析 MCP JSON 配置
 * 支持两种格式：
 * 1. 纯配置对象：{ "command": "npx", "args": [...], ... }
 * 2. 带键名包装：  "server-name": { "command": "npx", ... }  或  { "server-name": {...} }
 *
 * @param jsonText - JSON 字符串
 * @returns { id?: string, config: object, formattedConfig: string }
 * @throws 如果 JSON 格式无效
 */
export function parseSmartMcpJson(jsonText: string): {
  id?: string;
  config: any;
  formattedConfig: string;
} {
  let trimmed = jsonText.trim();
  if (!trimmed) {
    return { config: {}, formattedConfig: "" };
  }

  // 如果是键值对片段（"key": {...}），包装成完整对象
  if (trimmed.startsWith('"') && !trimmed.startsWith("{")) {
    trimmed = `{${trimmed}}`;
  }

  const parsed = JSON.parse(trimmed);

  // 如果是单键对象且值是对象，提取键名和配置
  const keys = Object.keys(parsed);
  if (
    keys.length === 1 &&
    parsed[keys[0]] &&
    typeof parsed[keys[0]] === "object" &&
    !Array.isArray(parsed[keys[0]])
  ) {
    const id = keys[0];
    const config = parsed[id];
    return {
      id,
      config,
      formattedConfig: JSON.stringify(config, null, 2),
    };
  }

  // 否则直接使用
  return {
    config: parsed,
    formattedConfig: JSON.stringify(parsed, null, 2),
  };
}

/**
 * TOML 格式化功能已禁用
 *
 * 原因：smol-toml 的 parse/stringify 会丢失所有注释和原有排版。
 * 由于 TOML 常用于配置文件，注释是重要的文档说明，丢失注释会造成严重的用户体验问题。
 *
 * 未来可选方案：
 * - 使用 @ltd/j-toml（支持注释保留，但需额外依赖和复杂的 API）
 * - 实现仅格式化缩进/空白的轻量级方案
 * - 使用 toml-eslint-parser + 自定义生成器
 *
 * 暂时建议：依赖现有的 TOML 语法校验（useCodexTomlValidation），不提供格式化功能。
 */
</file>

<file path="src/utils/providerConfigUtils.ts">
// 供应商配置处理工具函数

import type { TemplateValueConfig } from "../config/claudeProviderPresets";
import { normalizeQuotes } from "@/utils/textNormalization";

const isPlainObject = (value: unknown): value is Record<string, any> => {
  return Object.prototype.toString.call(value) === "[object Object]";
};

const deepMerge = (
  target: Record<string, any>,
  source: Record<string, any>,
): Record<string, any> => {
  Object.entries(source).forEach(([key, value]) => {
    if (isPlainObject(value)) {
      if (!isPlainObject(target[key])) {
        target[key] = {};
      }
      deepMerge(target[key], value);
    } else {
      // 直接覆盖非对象字段（数组/基础类型）
      target[key] = value;
    }
  });
  return target;
};

const deepRemove = (
  target: Record<string, any>,
  source: Record<string, any>,
) => {
  Object.entries(source).forEach(([key, value]) => {
    if (!(key in target)) return;

    if (isPlainObject(value) && isPlainObject(target[key])) {
      // 只移除完全匹配的嵌套属性
      deepRemove(target[key], value);
      if (Object.keys(target[key]).length === 0) {
        delete target[key];
      }
    } else if (isSubset(target[key], value)) {
      // 只有当值完全匹配时才删除
      delete target[key];
    }
  });
};

const isSubset = (target: any, source: any): boolean => {
  if (isPlainObject(source)) {
    if (!isPlainObject(target)) return false;
    return Object.entries(source).every(([key, value]) =>
      isSubset(target[key], value),
    );
  }

  if (Array.isArray(source)) {
    if (!Array.isArray(target) || target.length !== source.length) return false;
    return source.every((item, index) => isSubset(target[index], item));
  }

  return target === source;
};

// 深拷贝函数
const deepClone = <T>(obj: T): T => {
  if (obj === null || typeof obj !== "object") return obj;
  if (obj instanceof Date) return new Date(obj.getTime()) as T;
  if (obj instanceof Array) return obj.map((item) => deepClone(item)) as T;
  if (obj instanceof Object) {
    const clonedObj = {} as T;
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        clonedObj[key] = deepClone(obj[key]);
      }
    }
    return clonedObj;
  }
  return obj;
};

export interface UpdateCommonConfigResult {
  updatedConfig: string;
  error?: string;
}

// 验证JSON配置格式
export const validateJsonConfig = (
  value: string,
  fieldName: string = "配置",
): string => {
  if (!value.trim()) {
    return "";
  }
  try {
    const parsed = JSON.parse(value);
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
      return `${fieldName}必须是 JSON 对象`;
    }
    return "";
  } catch {
    return `${fieldName}JSON格式错误，请检查语法`;
  }
};

// 将通用配置片段写入/移除 settingsConfig
export const updateCommonConfigSnippet = (
  jsonString: string,
  snippetString: string,
  enabled: boolean,
): UpdateCommonConfigResult => {
  let config: Record<string, any>;
  try {
    config = jsonString ? JSON.parse(jsonString) : {};
  } catch (err) {
    return {
      updatedConfig: jsonString,
      error: "配置 JSON 解析失败，无法写入通用配置",
    };
  }

  if (!snippetString.trim()) {
    return {
      updatedConfig: JSON.stringify(config, null, 2),
    };
  }

  // 使用统一的验证函数
  const snippetError = validateJsonConfig(snippetString, "通用配置片段");
  if (snippetError) {
    return {
      updatedConfig: JSON.stringify(config, null, 2),
      error: snippetError,
    };
  }

  const snippet = JSON.parse(snippetString) as Record<string, any>;

  if (enabled) {
    const merged = deepMerge(deepClone(config), snippet);
    return {
      updatedConfig: JSON.stringify(merged, null, 2),
    };
  }

  const cloned = deepClone(config);
  deepRemove(cloned, snippet);
  return {
    updatedConfig: JSON.stringify(cloned, null, 2),
  };
};

// 检查当前配置是否已包含通用配置片段
export const hasCommonConfigSnippet = (
  jsonString: string,
  snippetString: string,
): boolean => {
  try {
    if (!snippetString.trim()) return false;
    const config = jsonString ? JSON.parse(jsonString) : {};
    const snippet = JSON.parse(snippetString);
    if (!isPlainObject(snippet)) return false;
    return isSubset(config, snippet);
  } catch (err) {
    return false;
  }
};

// 读取配置中的 API Key（支持 Claude, Codex, Gemini）
export const getApiKeyFromConfig = (
  jsonString: string,
  appType?: string,
): string => {
  try {
    const config = JSON.parse(jsonString);
    const env = config?.env;

    if (!env) return "";

    // Gemini API Key
    if (appType === "gemini") {
      const geminiKey = env.GEMINI_API_KEY;
      return typeof geminiKey === "string" ? geminiKey : "";
    }

    // Codex API Key
    if (appType === "codex") {
      const codexKey = env.CODEX_API_KEY;
      return typeof codexKey === "string" ? codexKey : "";
    }

    // Claude API Key (优先 ANTHROPIC_AUTH_TOKEN，其次 ANTHROPIC_API_KEY)
    const token = env.ANTHROPIC_AUTH_TOKEN;
    const apiKey = env.ANTHROPIC_API_KEY;
    const value =
      typeof token === "string"
        ? token
        : typeof apiKey === "string"
          ? apiKey
          : "";
    return value;
  } catch (err) {
    return "";
  }
};

// 模板变量替换
export const applyTemplateValues = (
  config: any,
  templateValues: Record<string, TemplateValueConfig> | undefined,
): any => {
  const resolvedValues = Object.fromEntries(
    Object.entries(templateValues ?? {}).map(([key, value]) => {
      const resolvedValue =
        value.editorValue !== undefined
          ? value.editorValue
          : (value.defaultValue ?? "");
      return [key, resolvedValue];
    }),
  );

  const replaceInString = (str: string): string => {
    return Object.entries(resolvedValues).reduce((acc, [key, value]) => {
      const placeholder = `\${${key}}`;
      if (!acc.includes(placeholder)) {
        return acc;
      }
      return acc.split(placeholder).join(value ?? "");
    }, str);
  };

  const traverse = (obj: any): any => {
    if (typeof obj === "string") {
      return replaceInString(obj);
    }
    if (Array.isArray(obj)) {
      return obj.map(traverse);
    }
    if (obj && typeof obj === "object") {
      const result: any = {};
      for (const [key, value] of Object.entries(obj)) {
        result[key] = traverse(value);
      }
      return result;
    }
    return obj;
  };

  return traverse(config);
};

// 判断配置中是否存在 API Key 字段
export const hasApiKeyField = (
  jsonString: string,
  appType?: string,
): boolean => {
  try {
    const config = JSON.parse(jsonString);
    const env = config?.env ?? {};

    if (appType === "gemini") {
      return Object.prototype.hasOwnProperty.call(env, "GEMINI_API_KEY");
    }

    if (appType === "codex") {
      return Object.prototype.hasOwnProperty.call(env, "CODEX_API_KEY");
    }

    return (
      Object.prototype.hasOwnProperty.call(env, "ANTHROPIC_AUTH_TOKEN") ||
      Object.prototype.hasOwnProperty.call(env, "ANTHROPIC_API_KEY")
    );
  } catch (err) {
    return false;
  }
};

// 写入/更新配置中的 API Key，默认不新增缺失字段
export const setApiKeyInConfig = (
  jsonString: string,
  apiKey: string,
  options: { createIfMissing?: boolean; appType?: string } = {},
): string => {
  const { createIfMissing = false, appType } = options;
  try {
    const config = JSON.parse(jsonString);
    if (!config.env) {
      if (!createIfMissing) return jsonString;
      config.env = {};
    }
    const env = config.env as Record<string, any>;

    // Gemini API Key
    if (appType === "gemini") {
      if ("GEMINI_API_KEY" in env) {
        env.GEMINI_API_KEY = apiKey;
      } else if (createIfMissing) {
        env.GEMINI_API_KEY = apiKey;
      } else {
        return jsonString;
      }
      return JSON.stringify(config, null, 2);
    }

    // Codex API Key
    if (appType === "codex") {
      if ("CODEX_API_KEY" in env) {
        env.CODEX_API_KEY = apiKey;
      } else if (createIfMissing) {
        env.CODEX_API_KEY = apiKey;
      } else {
        return jsonString;
      }
      return JSON.stringify(config, null, 2);
    }

    // Claude API Key (优先写入已存在的字段；若两者均不存在且允许创建，则默认创建 AUTH_TOKEN 字段)
    if ("ANTHROPIC_AUTH_TOKEN" in env) {
      env.ANTHROPIC_AUTH_TOKEN = apiKey;
    } else if ("ANTHROPIC_API_KEY" in env) {
      env.ANTHROPIC_API_KEY = apiKey;
    } else if (createIfMissing) {
      env.ANTHROPIC_AUTH_TOKEN = apiKey;
    } else {
      return jsonString;
    }
    return JSON.stringify(config, null, 2);
  } catch (err) {
    return jsonString;
  }
};

// ========== TOML Config Utilities ==========

export interface UpdateTomlCommonConfigResult {
  updatedConfig: string;
  error?: string;
}

// 保存之前的通用配置片段，用于替换操作
let previousCommonSnippet = "";

// 将通用配置片段写入/移除 TOML 配置
export const updateTomlCommonConfigSnippet = (
  tomlString: string,
  snippetString: string,
  enabled: boolean,
): UpdateTomlCommonConfigResult => {
  if (!snippetString.trim()) {
    // 如果片段为空，直接返回原始配置
    return {
      updatedConfig: tomlString,
    };
  }

  if (enabled) {
    // 添加通用配置
    // 先移除旧的通用配置（如果有）
    let updatedConfig = tomlString;
    if (previousCommonSnippet && tomlString.includes(previousCommonSnippet)) {
      updatedConfig = tomlString.replace(previousCommonSnippet, "");
    }

    // 在文件末尾添加新的通用配置
    // 确保有适当的换行
    const needsNewline = updatedConfig && !updatedConfig.endsWith("\n");
    updatedConfig =
      updatedConfig + (needsNewline ? "\n\n" : "\n") + snippetString;

    // 保存当前通用配置片段
    previousCommonSnippet = snippetString;

    return {
      updatedConfig: updatedConfig.trim() + "\n",
    };
  } else {
    // 移除通用配置
    if (tomlString.includes(snippetString)) {
      const updatedConfig = tomlString.replace(snippetString, "");
      // 清理多余的空行
      const cleaned = updatedConfig.replace(/\n{3,}/g, "\n\n").trim();

      // 清空保存的状态
      previousCommonSnippet = "";

      return {
        updatedConfig: cleaned ? cleaned + "\n" : "",
      };
    }
    return {
      updatedConfig: tomlString,
    };
  }
};

// 检查 TOML 配置是否已包含通用配置片段
export const hasTomlCommonConfigSnippet = (
  tomlString: string,
  snippetString: string,
): boolean => {
  if (!snippetString.trim()) return false;

  // 简单检查配置是否包含片段内容
  // 去除空白字符后比较，避免格式差异影响
  const normalizeWhitespace = (str: string) => str.replace(/\s+/g, " ").trim();

  return normalizeWhitespace(tomlString).includes(
    normalizeWhitespace(snippetString),
  );
};

// ========== Codex base_url utils ==========

// 从 Codex 的 TOML 配置文本中提取 base_url（支持单/双引号）
export const extractCodexBaseUrl = (
  configText: string | undefined | null,
): string | undefined => {
  try {
    const raw = typeof configText === "string" ? configText : "";
    // 归一化中文/全角引号，避免正则提取失败
    const text = normalizeQuotes(raw);
    if (!text) return undefined;
    const m = text.match(/base_url\s*=\s*(['"])([^'\"]+)\1/);
    return m && m[2] ? m[2] : undefined;
  } catch {
    return undefined;
  }
};

// 从 Provider 对象中提取 Codex base_url（当 settingsConfig.config 为 TOML 字符串时）
export const getCodexBaseUrl = (
  provider: { settingsConfig?: Record<string, any> } | undefined | null,
): string | undefined => {
  try {
    const text =
      typeof provider?.settingsConfig?.config === "string"
        ? (provider as any).settingsConfig.config
        : "";
    return extractCodexBaseUrl(text);
  } catch {
    return undefined;
  }
};

// 在 Codex 的 TOML 配置文本中写入或更新 base_url 字段
export const setCodexBaseUrl = (
  configText: string,
  baseUrl: string,
): string => {
  const trimmed = baseUrl.trim();
  if (!trimmed) {
    return configText;
  }
  // 归一化原文本中的引号（既能匹配，也能输出稳定格式）
  const normalizedText = normalizeQuotes(configText);

  const normalizedUrl = trimmed.replace(/\s+/g, "");
  const replacementLine = `base_url = "${normalizedUrl}"`;
  const pattern = /base_url\s*=\s*(["'])([^"']+)\1/;

  if (pattern.test(normalizedText)) {
    return normalizedText.replace(pattern, replacementLine);
  }

  const prefix =
    normalizedText && !normalizedText.endsWith("\n")
      ? `${normalizedText}\n`
      : normalizedText;
  return `${prefix}${replacementLine}\n`;
};

// ========== Codex model name utils ==========

// 从 Codex 的 TOML 配置文本中提取 model 字段（支持单/双引号）
export const extractCodexModelName = (
  configText: string | undefined | null,
): string | undefined => {
  try {
    const raw = typeof configText === "string" ? configText : "";
    // 归一化中文/全角引号，避免正则提取失败
    const text = normalizeQuotes(raw);
    if (!text) return undefined;

    // 匹配 model = "xxx" 或 model = 'xxx'
    const m = text.match(/^model\s*=\s*(['"])([^'"]+)\1/m);
    return m && m[2] ? m[2] : undefined;
  } catch {
    return undefined;
  }
};

// 在 Codex 的 TOML 配置文本中写入或更新 model 字段
export const setCodexModelName = (
  configText: string,
  modelName: string,
): string => {
  const trimmed = modelName.trim();
  if (!trimmed) {
    return configText;
  }

  // 归一化原文本中的引号（既能匹配，也能输出稳定格式）
  const normalizedText = normalizeQuotes(configText);

  const replacementLine = `model = "${trimmed}"`;
  const pattern = /^model\s*=\s*["']([^"']+)["']/m;

  if (pattern.test(normalizedText)) {
    return normalizedText.replace(pattern, replacementLine);
  }

  // 如果不存在 model 字段，尝试在 model_provider 之后插入
  // 如果 model_provider 也不存在，则插入到开头
  const providerPattern = /^model_provider\s*=\s*["'][^"']+["']/m;
  const match = normalizedText.match(providerPattern);

  if (match && match.index !== undefined) {
    // 在 model_provider 行之后插入
    const endOfLine = normalizedText.indexOf("\n", match.index);
    if (endOfLine !== -1) {
      return (
        normalizedText.slice(0, endOfLine + 1) +
        replacementLine +
        "\n" +
        normalizedText.slice(endOfLine + 1)
      );
    }
  }

  // 在文件开头插入
  const lines = normalizedText.split("\n");
  return `${replacementLine}\n${lines.join("\n")}`;
};
</file>

<file path="src/utils/uuid.ts">
/**
 * 生成 UUID v4
 *
 * 优先使用 crypto.randomUUID()，不可用时使用 crypto.getRandomValues() 实现
 *
 * 兼容性：
 * - crypto.randomUUID(): Chrome 92+, Safari 15.4+, Firefox 95+
 * - crypto.getRandomValues(): Chrome 11+, Safari 5+, Firefox 21+
 */
export function generateUUID(): string {
  const cryptoApi = globalThis.crypto;

  // 优先使用原生 API
  if (typeof cryptoApi?.randomUUID === "function") {
    return cryptoApi.randomUUID();
  }

  // Fallback: 使用 crypto.getRandomValues 实现 UUID v4
  if (!cryptoApi?.getRandomValues) {
    throw new Error(
      "crypto API not available - please update your operating system",
    );
  }

  const bytes = new Uint8Array(16);
  cryptoApi.getRandomValues(bytes);

  // 设置版本 (4) 和变体 (RFC 4122)
  bytes[6] = (bytes[6] & 0x0f) | 0x40;
  bytes[8] = (bytes[8] & 0x3f) | 0x80;

  const hex = Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");

  return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
}
</file>

<file path="src/components/providers/EditProviderDialog.tsx">
import { useCallback, useEffect, useMemo, useState } from "react";
import { useTranslation } from "react-i18next";
import { Save } from "lucide-react";
import { Button } from "@/components/ui/button";
import { FullScreenPanel } from "@/components/common/FullScreenPanel";
import type { Provider } from "@/types";
import {
  ProviderForm,
  type ProviderFormValues,
} from "@/components/providers/forms/ProviderForm";
import { providersApi, vscodeApi, type AppId } from "@/lib/api";

interface EditProviderDialogProps {
  open: boolean;
  provider: Provider | null;
  onOpenChange: (open: boolean) => void;
  onSubmit: (provider: Provider) => Promise<void> | void;
  appId: AppId;
  isProxyTakeover?: boolean; // 代理接管模式下不读取 live（避免显示被接管后的代理配置）
}

export function EditProviderDialog({
  open,
  provider,
  onOpenChange,
  onSubmit,
  appId,
  isProxyTakeover = false,
}: EditProviderDialogProps) {
  const { t } = useTranslation();

  // 默认使用传入的 provider.settingsConfig，若当前编辑对象是"当前生效供应商"，则尝试读取实时配置替换初始值
  const [liveSettings, setLiveSettings] = useState<Record<
    string,
    unknown
  > | null>(null);

  // 使用 ref 标记是否已经加载过，防止重复读取覆盖用户编辑
  const [hasLoadedLive, setHasLoadedLive] = useState(false);

  useEffect(() => {
    let cancelled = false;
    const load = async () => {
      if (!open || !provider) {
        setLiveSettings(null);
        setHasLoadedLive(false);
        return;
      }

      // 关键修复：只在首次打开时加载一次
      if (hasLoadedLive) {
        return;
      }

      // 代理接管模式：Live 配置已被代理改写，读取 live 会导致编辑界面展示代理地址/占位符等内容
      // 因此直接回退到 SSOT（数据库）配置，避免用户困惑与误保存
      if (isProxyTakeover) {
        if (!cancelled) {
          setLiveSettings(null);
          setHasLoadedLive(true);
        }
        return;
      }

      try {
        const currentId = await providersApi.getCurrent(appId);
        if (currentId && provider.id === currentId) {
          try {
            const live = (await vscodeApi.getLiveProviderSettings(
              appId,
            )) as Record<string, unknown>;
            if (!cancelled && live && typeof live === "object") {
              setLiveSettings(live);
              setHasLoadedLive(true);
            }
          } catch {
            // 读取实时配置失败则回退到 SSOT（不打断编辑流程）
            if (!cancelled) {
              setLiveSettings(null);
              setHasLoadedLive(true);
            }
          }
        } else {
          if (!cancelled) {
            setLiveSettings(null);
            setHasLoadedLive(true);
          }
        }
      } finally {
        // no-op
      }
    };
    void load();
    return () => {
      cancelled = true;
    };
  }, [open, provider?.id, appId, hasLoadedLive, isProxyTakeover]); // 只依赖 provider.id，不依赖整个 provider 对象

  const initialSettingsConfig = useMemo(() => {
    return (liveSettings ?? provider?.settingsConfig ?? {}) as Record<
      string,
      unknown
    >;
  }, [liveSettings, provider?.settingsConfig]); // 只依赖 settingsConfig，不依赖整个 provider

  // 固定 initialData，防止 provider 对象更新时重置表单
  const initialData = useMemo(() => {
    if (!provider) return null;
    return {
      name: provider.name,
      notes: provider.notes,
      websiteUrl: provider.websiteUrl,
      settingsConfig: initialSettingsConfig,
      category: provider.category,
      meta: provider.meta,
      icon: provider.icon,
      iconColor: provider.iconColor,
    };
  }, [
    provider?.id, // 只依赖 ID，provider 对象更新不会触发重新计算
    initialSettingsConfig,
    // 注意：不依赖 provider 的其他字段，防止表单重置
  ]);

  const handleSubmit = useCallback(
    async (values: ProviderFormValues) => {
      if (!provider) return;

      // 注意：values.settingsConfig 已经是最终的配置字符串
      // ProviderForm 已经为不同的 app 类型（Claude/Codex/Gemini）正确组装了配置
      const parsedConfig = JSON.parse(values.settingsConfig) as Record<
        string,
        unknown
      >;

      const updatedProvider: Provider = {
        ...provider,
        name: values.name.trim(),
        notes: values.notes?.trim() || undefined,
        websiteUrl: values.websiteUrl?.trim() || undefined,
        settingsConfig: parsedConfig,
        icon: values.icon?.trim() || undefined,
        iconColor: values.iconColor?.trim() || undefined,
        ...(values.presetCategory ? { category: values.presetCategory } : {}),
        // 保留或更新 meta 字段
        ...(values.meta ? { meta: values.meta } : {}),
      };

      await onSubmit(updatedProvider);
      onOpenChange(false);
    },
    [onSubmit, onOpenChange, provider],
  );

  if (!provider || !initialData) {
    return null;
  }

  return (
    <FullScreenPanel
      isOpen={open}
      title={t("provider.editProvider")}
      onClose={() => onOpenChange(false)}
      footer={
        <Button
          type="submit"
          form="provider-form"
          className="bg-primary text-primary-foreground hover:bg-primary/90"
        >
          <Save className="h-4 w-4 mr-2" />
          {t("common.save")}
        </Button>
      }
    >
      <ProviderForm
        appId={appId}
        providerId={provider.id}
        submitLabel={t("common.save")}
        onSubmit={handleSubmit}
        onCancel={() => onOpenChange(false)}
        initialData={initialData}
        showButtons={false}
      />
    </FullScreenPanel>
  );
}
</file>

<file path="src/components/providers/forms/ProviderPresetSelector.tsx">
import { useTranslation } from "react-i18next";
import { FormLabel } from "@/components/ui/form";
import { ClaudeIcon, CodexIcon, GeminiIcon } from "@/components/BrandIcons";
import { Zap, Star } from "lucide-react";
import type { ProviderPreset } from "@/config/claudeProviderPresets";
import type { CodexProviderPreset } from "@/config/codexProviderPresets";
import type { GeminiProviderPreset } from "@/config/geminiProviderPresets";
import type { ProviderCategory } from "@/types";

type PresetEntry = {
  id: string;
  preset: ProviderPreset | CodexProviderPreset | GeminiProviderPreset;
};

interface ProviderPresetSelectorProps {
  selectedPresetId: string | null;
  groupedPresets: Record<string, PresetEntry[]>;
  categoryKeys: string[];
  presetCategoryLabels: Record<string, string>;
  onPresetChange: (value: string) => void;
  category?: ProviderCategory; // 当前选中的分类
}

export function ProviderPresetSelector({
  selectedPresetId,
  groupedPresets,
  categoryKeys,
  presetCategoryLabels,
  onPresetChange,
  category,
}: ProviderPresetSelectorProps) {
  const { t } = useTranslation();

  // 根据分类获取提示文字
  const getCategoryHint = (): React.ReactNode => {
    switch (category) {
      case "official":
        return t("providerForm.officialHint", {
          defaultValue: "💡 官方供应商使用浏览器登录，无需配置 API Key",
        });
      case "cn_official":
        return t("providerForm.cnOfficialApiKeyHint", {
          defaultValue: "💡 国产官方供应商只需填写 API Key，请求地址已预设",
        });
      case "aggregator":
        return t("providerForm.aggregatorApiKeyHint", {
          defaultValue: "💡 聚合服务供应商只需填写 API Key 即可使用",
        });
      case "third_party":
        return t("providerForm.thirdPartyApiKeyHint", {
          defaultValue: "💡 第三方供应商需要填写 API Key 和请求地址",
        });
      case "custom":
        return t("providerForm.customApiKeyHint", {
          defaultValue: "💡 自定义配置需手动填写所有必要字段",
        });
      default:
        return t("providerPreset.hint", {
          defaultValue: "选择预设后可继续调整下方字段。",
        });
    }
  };

  // 渲染预设按钮的图标
  const renderPresetIcon = (
    preset: ProviderPreset | CodexProviderPreset | GeminiProviderPreset,
  ) => {
    const iconType = preset.theme?.icon;
    if (!iconType) return null;

    switch (iconType) {
      case "claude":
        return <ClaudeIcon size={14} />;
      case "codex":
        return <CodexIcon size={14} />;
      case "gemini":
        return <GeminiIcon size={14} />;
      case "generic":
        return <Zap size={14} />;
      default:
        return null;
    }
  };

  // 获取预设按钮的样式类名
  const getPresetButtonClass = (
    isSelected: boolean,
    preset: ProviderPreset | CodexProviderPreset | GeminiProviderPreset,
  ) => {
    const baseClass =
      "inline-flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium transition-colors";

    if (isSelected) {
      // 如果有自定义主题，使用自定义颜色
      if (preset.theme?.backgroundColor) {
        return `${baseClass} text-white`;
      }
      // 默认使用主题蓝色
      return `${baseClass} bg-blue-500 text-white dark:bg-blue-600`;
    }

    return `${baseClass} bg-accent text-muted-foreground hover:bg-accent/80`;
  };

  // 获取预设按钮的内联样式（用于自定义背景色）
  const getPresetButtonStyle = (
    isSelected: boolean,
    preset: ProviderPreset | CodexProviderPreset | GeminiProviderPreset,
  ) => {
    if (!isSelected || !preset.theme?.backgroundColor) {
      return undefined;
    }

    return {
      backgroundColor: preset.theme.backgroundColor,
      color: preset.theme.textColor || "#FFFFFF",
    };
  };

  return (
    <div className="space-y-3">
      <FormLabel>{t("providerPreset.label")}</FormLabel>
      <div className="flex flex-wrap gap-2">
        {/* 预设按钮 */}
        {categoryKeys.map((category) => {
          const entries = groupedPresets[category];
          if (!entries || entries.length === 0) return null;
          return entries.map((entry) => {
            const isSelected = selectedPresetId === entry.id;
            const isPartner = entry.preset.isPartner;
            return (
              <button
                key={entry.id}
                type="button"
                onClick={() => onPresetChange(entry.id)}
                className={`${getPresetButtonClass(isSelected, entry.preset)} relative`}
                style={getPresetButtonStyle(isSelected, entry.preset)}
                title={
                  presetCategoryLabels[category] ?? t("providerPreset.other")
                }
              >
                {renderPresetIcon(entry.preset)}
                {entry.preset.name}
                {isPartner && (
                  <span className="absolute -top-1 -right-1 flex items-center gap-0.5 rounded-full bg-gradient-to-r from-amber-500 to-yellow-500 px-1.5 py-0.5 text-[10px] font-bold text-white shadow-md">
                    <Star className="h-2.5 w-2.5 fill-current" />
                  </span>
                )}
              </button>
            );
          });
        })}

        {/* 自定义按钮 */}
        <button
          type="button"
          onClick={() => onPresetChange("custom")}
          className={`inline-flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium transition-colors ${
            selectedPresetId === "custom"
              ? "bg-blue-500 text-white dark:bg-blue-600"
              : "bg-accent text-muted-foreground hover:bg-accent/80"
          }`}
        >
          {t("providerPreset.custom")}
        </button>
      </div>
      <p className="text-xs text-muted-foreground">{getCategoryHint()}</p>
    </div>
  );
}
</file>

<file path="src/components/providers/HealthStatusIndicator.tsx">
import React from "react";
import { cn } from "@/lib/utils";
import type { HealthStatus } from "@/lib/api/model-test";
import { useTranslation } from "react-i18next";

interface HealthStatusIndicatorProps {
  status: HealthStatus;
  responseTimeMs?: number;
  className?: string;
}

const statusConfig = {
  operational: {
    color: "bg-emerald-500",
    labelKey: "health.operational",
    labelFallback: "正常",
    textColor: "text-emerald-600 dark:text-emerald-400",
  },
  degraded: {
    color: "bg-yellow-500",
    labelKey: "health.degraded",
    labelFallback: "降级",
    textColor: "text-yellow-600 dark:text-yellow-400",
  },
  failed: {
    color: "bg-red-500",
    labelKey: "health.failed",
    labelFallback: "失败",
    textColor: "text-red-600 dark:text-red-400",
  },
};

export const HealthStatusIndicator: React.FC<HealthStatusIndicatorProps> = ({
  status,
  responseTimeMs,
  className,
}) => {
  const { t } = useTranslation();
  const config = statusConfig[status];
  const label = t(config.labelKey, { defaultValue: config.labelFallback });

  return (
    <div className={cn("flex items-center gap-2", className)}>
      <div className={cn("w-2 h-2 rounded-full", config.color)} />
      <span className={cn("text-xs font-medium", config.textColor)}>
        {label}
        {responseTimeMs !== undefined && ` (${responseTimeMs}ms)`}
      </span>
    </div>
  );
};
</file>

<file path="src/lib/api/deeplink.ts">
import { invoke } from "@tauri-apps/api/core";

export type ResourceType = "provider" | "prompt" | "mcp" | "skill";

export interface DeepLinkImportRequest {
  version: string;
  resource: ResourceType;

  // Common fields
  app?: "claude" | "codex" | "gemini";
  name?: string;
  enabled?: boolean;

  // Provider fields
  homepage?: string;
  endpoint?: string;
  apiKey?: string;
  icon?: string;
  model?: string;
  notes?: string;
  haikuModel?: string;
  sonnetModel?: string;
  opusModel?: string;

  // Prompt fields
  content?: string;
  description?: string;

  // MCP fields
  apps?: string; // "claude,codex,gemini"

  // Skill fields
  repo?: string;
  directory?: string;
  branch?: string;

  // Config file fields
  config?: string;
  configFormat?: string;
  configUrl?: string;

  // Usage script fields (v3.9+)
  usageEnabled?: boolean;
  usageScript?: string;
  usageApiKey?: string;
  usageBaseUrl?: string;
  usageAccessToken?: string;
  usageUserId?: string;
  usageAutoInterval?: number;
}

export interface McpImportResult {
  importedCount: number;
  importedIds: string[];
  failed: Array<{
    id: string;
    error: string;
  }>;
}

export type ImportResult =
  | { type: "provider"; id: string }
  | { type: "prompt"; id: string }
  | {
      type: "mcp";
      importedCount: number;
      importedIds: string[];
      failed: Array<{ id: string; error: string }>;
    }
  | { type: "skill"; key: string };

export const deeplinkApi = {
  /**
   * Parse a deep link URL
   * @param url The ccswitch:// URL to parse
   * @returns Parsed deep link request
   */
  parseDeeplink: async (url: string): Promise<DeepLinkImportRequest> => {
    return invoke("parse_deeplink", { url });
  },

  /**
   * Merge configuration from Base64/URL into a deep link request
   * This is used to show the complete configuration in the confirmation dialog
   * @param request The deep link import request
   * @returns Merged deep link request with config fields populated
   */
  mergeDeeplinkConfig: async (
    request: DeepLinkImportRequest,
  ): Promise<DeepLinkImportRequest> => {
    return invoke("merge_deeplink_config", { request });
  },

  /**
   * Import a resource from a deep link request (unified handler)
   * @param request The deep link import request
   * @returns Import result based on resource type
   */
  importFromDeeplink: async (
    request: DeepLinkImportRequest,
  ): Promise<ImportResult> => {
    return invoke("import_from_deeplink_unified", { request });
  },
};
</file>

<file path="src/lib/api/model-test.ts">
import { invoke } from "@tauri-apps/api/core";
import type { AppId } from "./types";

// ===== 流式健康检查类型 =====

export type HealthStatus = "operational" | "degraded" | "failed";

export interface StreamCheckConfig {
  timeoutSecs: number;
  maxRetries: number;
  degradedThresholdMs: number;
  claudeModel: string;
  codexModel: string;
  geminiModel: string;
}

export interface StreamCheckResult {
  status: HealthStatus;
  success: boolean;
  message: string;
  responseTimeMs?: number;
  httpStatus?: number;
  modelUsed: string;
  testedAt: number;
  retryCount: number;
}

// ===== 流式健康检查 API =====

/**
 * 流式健康检查（单个供应商）
 */
export async function streamCheckProvider(
  appType: AppId,
  providerId: string,
): Promise<StreamCheckResult> {
  return invoke("stream_check_provider", { appType, providerId });
}

/**
 * 批量流式健康检查
 */
export async function streamCheckAllProviders(
  appType: AppId,
  proxyTargetsOnly: boolean = false,
): Promise<Array<[string, StreamCheckResult]>> {
  return invoke("stream_check_all_providers", { appType, proxyTargetsOnly });
}

/**
 * 获取流式检查配置
 */
export async function getStreamCheckConfig(): Promise<StreamCheckConfig> {
  return invoke("get_stream_check_config");
}

/**
 * 保存流式检查配置
 */
export async function saveStreamCheckConfig(
  config: StreamCheckConfig,
): Promise<void> {
  return invoke("save_stream_check_config", { config });
}
</file>

<file path="src/lib/api/providers.ts">
import { invoke } from "@tauri-apps/api/core";
import { listen, type UnlistenFn } from "@tauri-apps/api/event";
import type { Provider } from "@/types";
import type { AppId } from "./types";

export interface ProviderSortUpdate {
  id: string;
  sortIndex: number;
}

export interface ProviderSwitchEvent {
  appType: AppId;
  providerId: string;
}

export const providersApi = {
  async getAll(appId: AppId): Promise<Record<string, Provider>> {
    return await invoke("get_providers", { app: appId });
  },

  async getCurrent(appId: AppId): Promise<string> {
    return await invoke("get_current_provider", { app: appId });
  },

  async add(provider: Provider, appId: AppId): Promise<boolean> {
    return await invoke("add_provider", { provider, app: appId });
  },

  async update(provider: Provider, appId: AppId): Promise<boolean> {
    return await invoke("update_provider", { provider, app: appId });
  },

  async delete(id: string, appId: AppId): Promise<boolean> {
    return await invoke("delete_provider", { id, app: appId });
  },

  async switch(id: string, appId: AppId): Promise<boolean> {
    return await invoke("switch_provider", { id, app: appId });
  },

  async importDefault(appId: AppId): Promise<boolean> {
    return await invoke("import_default_config", { app: appId });
  },

  async updateTrayMenu(): Promise<boolean> {
    return await invoke("update_tray_menu");
  },

  async updateSortOrder(
    updates: ProviderSortUpdate[],
    appId: AppId,
  ): Promise<boolean> {
    return await invoke("update_providers_sort_order", { updates, app: appId });
  },

  async onSwitched(
    handler: (event: ProviderSwitchEvent) => void,
  ): Promise<UnlistenFn> {
    return await listen("provider-switched", (event) => {
      const payload = event.payload as ProviderSwitchEvent;
      handler(payload);
    });
  },
};
</file>

<file path="src/lib/api/settings.ts">
import { invoke } from "@tauri-apps/api/core";
import type { Settings } from "@/types";
import type { AppId } from "./types";

export interface ConfigTransferResult {
  success: boolean;
  message: string;
  filePath?: string;
  backupId?: string;
}

export const settingsApi = {
  async get(): Promise<Settings> {
    return await invoke("get_settings");
  },

  async save(settings: Settings): Promise<boolean> {
    return await invoke("save_settings", { settings });
  },

  async restart(): Promise<boolean> {
    return await invoke("restart_app");
  },

  async checkUpdates(): Promise<void> {
    await invoke("check_for_updates");
  },

  async isPortable(): Promise<boolean> {
    return await invoke("is_portable_mode");
  },

  async getConfigDir(appId: AppId): Promise<string> {
    return await invoke("get_config_dir", { app: appId });
  },

  async openConfigFolder(appId: AppId): Promise<void> {
    await invoke("open_config_folder", { app: appId });
  },

  async selectConfigDirectory(defaultPath?: string): Promise<string | null> {
    return await invoke("pick_directory", { defaultPath });
  },

  async getClaudeCodeConfigPath(): Promise<string> {
    return await invoke("get_claude_code_config_path");
  },

  async getAppConfigPath(): Promise<string> {
    return await invoke("get_app_config_path");
  },

  async openAppConfigFolder(): Promise<void> {
    await invoke("open_app_config_folder");
  },

  async getAppConfigDirOverride(): Promise<string | null> {
    return await invoke("get_app_config_dir_override");
  },

  async setAppConfigDirOverride(path: string | null): Promise<boolean> {
    return await invoke("set_app_config_dir_override", { path });
  },

  async applyClaudePluginConfig(options: {
    official: boolean;
  }): Promise<boolean> {
    const { official } = options;
    return await invoke("apply_claude_plugin_config", { official });
  },

  async applyClaudeOnboardingSkip(): Promise<boolean> {
    return await invoke("apply_claude_onboarding_skip");
  },

  async clearClaudeOnboardingSkip(): Promise<boolean> {
    return await invoke("clear_claude_onboarding_skip");
  },

  async saveFileDialog(defaultName: string): Promise<string | null> {
    return await invoke("save_file_dialog", { defaultName });
  },

  async openFileDialog(): Promise<string | null> {
    return await invoke("open_file_dialog");
  },

  async exportConfigToFile(filePath: string): Promise<ConfigTransferResult> {
    return await invoke("export_config_to_file", { filePath });
  },

  async importConfigFromFile(filePath: string): Promise<ConfigTransferResult> {
    return await invoke("import_config_from_file", { filePath });
  },

  async syncCurrentProvidersLive(): Promise<void> {
    const result = (await invoke("sync_current_providers_live")) as {
      success?: boolean;
      message?: string;
    };
    if (!result?.success) {
      throw new Error(result?.message || "Sync current providers failed");
    }
  },

  async openExternal(url: string): Promise<void> {
    try {
      const u = new URL(url);
      const scheme = u.protocol.replace(":", "").toLowerCase();
      if (scheme !== "http" && scheme !== "https") {
        throw new Error("Unsupported URL scheme");
      }
    } catch {
      throw new Error("Invalid URL");
    }
    await invoke("open_external", { url });
  },

  async setAutoLaunch(enabled: boolean): Promise<boolean> {
    return await invoke("set_auto_launch", { enabled });
  },

  async getAutoLaunchStatus(): Promise<boolean> {
    return await invoke("get_auto_launch_status");
  },

  async getToolVersions(): Promise<
    Array<{
      name: string;
      version: string | null;
      latest_version: string | null;
      error: string | null;
    }>
  > {
    return await invoke("get_tool_versions");
  },
};
</file>

<file path="src/components/providers/forms/BasicFormFields.tsx">
import { useTranslation } from "react-i18next";
import { useState } from "react";
import {
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { ArrowLeft } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogTrigger,
  DialogClose,
} from "@/components/ui/dialog";
import { ProviderIcon } from "@/components/ProviderIcon";
import { IconPicker } from "@/components/IconPicker";
import { getIconMetadata } from "@/icons/extracted/metadata";
import type { UseFormReturn } from "react-hook-form";
import type { ProviderFormData } from "@/lib/schemas/provider";

interface BasicFormFieldsProps {
  form: UseFormReturn<ProviderFormData>;
}

export function BasicFormFields({ form }: BasicFormFieldsProps) {
  const { t } = useTranslation();
  const [iconDialogOpen, setIconDialogOpen] = useState(false);

  const currentIcon = form.watch("icon");
  const currentIconColor = form.watch("iconColor");
  const providerName = form.watch("name") || "Provider";
  const effectiveIconColor =
    currentIconColor ||
    (currentIcon ? getIconMetadata(currentIcon)?.defaultColor : undefined);

  const handleIconSelect = (icon: string) => {
    const meta = getIconMetadata(icon);
    form.setValue("icon", icon);
    form.setValue("iconColor", meta?.defaultColor ?? "");
  };

  return (
    <>
      {/* 图标选择区域 - 顶部居中，可选 */}
      <div className="flex justify-center mb-6">
        <Dialog open={iconDialogOpen} onOpenChange={setIconDialogOpen}>
          <DialogTrigger asChild>
            <button
              type="button"
              className="w-20 h-20 p-3 rounded-xl border-2 border-muted hover:border-primary transition-colors cursor-pointer bg-muted/30 hover:bg-muted/50 flex items-center justify-center"
              title={
                currentIcon
                  ? t("providerIcon.clickToChange", {
                      defaultValue: "点击更换图标",
                    })
                  : t("providerIcon.clickToSelect", {
                      defaultValue: "点击选择图标",
                    })
              }
            >
              <ProviderIcon
                icon={currentIcon}
                name={providerName}
                color={effectiveIconColor}
                size={48}
              />
            </button>
          </DialogTrigger>
          <DialogContent
            variant="fullscreen"
            zIndex="top"
            overlayClassName="bg-[hsl(var(--background))] backdrop-blur-0"
            className="p-0 sm:rounded-none"
          >
            <div className="flex h-full flex-col">
              <div className="flex-shrink-0 py-4 border-b border-border-default bg-muted/40">
                <div className="mx-auto max-w-[56rem] px-6 flex items-center gap-4">
                  <DialogClose asChild>
                    <Button type="button" variant="outline" size="icon">
                      <ArrowLeft className="h-4 w-4" />
                    </Button>
                  </DialogClose>
                  <p className="text-lg font-semibold leading-tight">
                    {t("providerIcon.selectIcon", {
                      defaultValue: "选择图标",
                    })}
                  </p>
                </div>
              </div>
              <div className="flex-1 overflow-y-auto">
                <div className="space-y-2 mx-auto max-w-[56rem] px-6 py-6 w-full">
                  <IconPicker
                    value={currentIcon}
                    onValueChange={handleIconSelect}
                    color={effectiveIconColor}
                  />
                  <div className="flex justify-end gap-2">
                    <DialogClose asChild>
                      <Button type="button" variant="outline">
                        {t("common.done", { defaultValue: "完成" })}
                      </Button>
                    </DialogClose>
                  </div>
                </div>
              </div>
            </div>
          </DialogContent>
        </Dialog>
      </div>

      {/* 基础信息 - 网格布局 */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>{t("provider.name")}</FormLabel>
              <FormControl>
                <Input {...field} placeholder={t("provider.namePlaceholder")} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="notes"
          render={({ field }) => (
            <FormItem>
              <FormLabel>{t("provider.notes")}</FormLabel>
              <FormControl>
                <Input
                  {...field}
                  placeholder={t("provider.notesPlaceholder")}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>

      <FormField
        control={form.control}
        name="websiteUrl"
        render={({ field }) => (
          <FormItem>
            <FormLabel>{t("provider.websiteUrl")}</FormLabel>
            <FormControl>
              <Input
                {...field}
                placeholder={t("providerForm.websiteUrlPlaceholder")}
              />
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />
    </>
  );
}
</file>

<file path="src/components/providers/ProviderHealthBadge.tsx">
import { cn } from "@/lib/utils";
import { ProviderHealthStatus } from "@/types/proxy";
import { useTranslation } from "react-i18next";

interface ProviderHealthBadgeProps {
  consecutiveFailures: number;
  className?: string;
}

/**
 * 供应商健康状态徽章
 * 根据连续失败次数显示不同颜色的状态指示器
 */
export function ProviderHealthBadge({
  consecutiveFailures,
  className,
}: ProviderHealthBadgeProps) {
  const { t } = useTranslation();

  // 根据失败次数计算状态
  const getStatus = () => {
    if (consecutiveFailures === 0) {
      return {
        labelKey: "health.operational",
        labelFallback: "正常",
        status: ProviderHealthStatus.Healthy,
        color: "bg-green-500",
        // 使用更深/柔和的背景色，去除可能的白色内容感
        bgColor: "bg-green-500/10",
        textColor: "text-green-600 dark:text-green-400",
      };
    } else if (consecutiveFailures < 5) {
      return {
        labelKey: "health.degraded",
        labelFallback: "降级",
        status: ProviderHealthStatus.Degraded,
        color: "bg-yellow-500",
        bgColor: "bg-yellow-500/10",
        textColor: "text-yellow-600 dark:text-yellow-400",
      };
    } else {
      return {
        labelKey: "health.circuitOpen",
        labelFallback: "熔断",
        status: ProviderHealthStatus.Failed,
        color: "bg-red-500",
        bgColor: "bg-red-500/10",
        textColor: "text-red-600 dark:text-red-400",
      };
    }
  };

  const statusConfig = getStatus();
  const label = t(statusConfig.labelKey, {
    defaultValue: statusConfig.labelFallback,
  });

  return (
    <div
      className={cn(
        "inline-flex items-center gap-1.5 px-2 py-1 rounded-full text-xs font-medium",
        statusConfig.bgColor,
        statusConfig.textColor,
        className,
      )}
      title={t("health.consecutiveFailures", {
        count: consecutiveFailures,
        defaultValue: `连续失败 ${consecutiveFailures} 次`,
      })}
    >
      <div className={cn("w-2 h-2 rounded-full", statusConfig.color)} />
      <span>{label}</span>
    </div>
  );
}
</file>

<file path="src/hooks/useProviderActions.ts">
import { useCallback } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { toast } from "sonner";
import { useTranslation } from "react-i18next";
import { providersApi, settingsApi, type AppId } from "@/lib/api";
import type { Provider, UsageScript } from "@/types";
import {
  useAddProviderMutation,
  useUpdateProviderMutation,
  useDeleteProviderMutation,
  useSwitchProviderMutation,
} from "@/lib/query";
import { extractErrorMessage } from "@/utils/errorUtils";

/**
 * Hook for managing provider actions (add, update, delete, switch)
 * Extracts business logic from App.tsx
 */
export function useProviderActions(activeApp: AppId) {
  const { t } = useTranslation();
  const queryClient = useQueryClient();

  const addProviderMutation = useAddProviderMutation(activeApp);
  const updateProviderMutation = useUpdateProviderMutation(activeApp);
  const deleteProviderMutation = useDeleteProviderMutation(activeApp);
  const switchProviderMutation = useSwitchProviderMutation(activeApp);

  // Claude 插件同步逻辑
  const syncClaudePlugin = useCallback(
    async (provider: Provider) => {
      if (activeApp !== "claude") return;

      try {
        const settings = await settingsApi.get();
        if (!settings?.enableClaudePluginIntegration) {
          return;
        }

        const isOfficial = provider.category === "official";
        await settingsApi.applyClaudePluginConfig({ official: isOfficial });

        // 静默执行，不显示成功通知
      } catch (error) {
        const detail =
          extractErrorMessage(error) ||
          t("notifications.syncClaudePluginFailed", {
            defaultValue: "同步 Claude 插件失败",
          });
        toast.error(detail, { duration: 4200 });
      }
    },
    [activeApp, t],
  );

  // 添加供应商
  const addProvider = useCallback(
    async (provider: Omit<Provider, "id">) => {
      await addProviderMutation.mutateAsync(provider);
    },
    [addProviderMutation],
  );

  // 更新供应商
  const updateProvider = useCallback(
    async (provider: Provider) => {
      await updateProviderMutation.mutateAsync(provider);

      // 更新托盘菜单（失败不影响主操作）
      try {
        await providersApi.updateTrayMenu();
      } catch (trayError) {
        console.error(
          "Failed to update tray menu after updating provider",
          trayError,
        );
      }
    },
    [updateProviderMutation],
  );

  // 切换供应商
  const switchProvider = useCallback(
    async (provider: Provider) => {
      try {
        await switchProviderMutation.mutateAsync(provider.id);
        await syncClaudePlugin(provider);
      } catch {
        // 错误提示由 mutation 与同步函数处理
      }
    },
    [switchProviderMutation, syncClaudePlugin],
  );

  // 删除供应商
  const deleteProvider = useCallback(
    async (id: string) => {
      await deleteProviderMutation.mutateAsync(id);
    },
    [deleteProviderMutation],
  );

  // 保存用量脚本
  const saveUsageScript = useCallback(
    async (provider: Provider, script: UsageScript) => {
      try {
        const updatedProvider: Provider = {
          ...provider,
          meta: {
            ...provider.meta,
            usage_script: script,
          },
        };

        await providersApi.update(updatedProvider, activeApp);
        await queryClient.invalidateQueries({
          queryKey: ["providers", activeApp],
        });
        toast.success(
          t("provider.usageSaved", {
            defaultValue: "用量查询配置已保存",
          }),
          { closeButton: true },
        );
      } catch (error) {
        const detail =
          extractErrorMessage(error) ||
          t("provider.usageSaveFailed", {
            defaultValue: "用量查询配置保存失败",
          });
        toast.error(detail);
      }
    },
    [activeApp, queryClient, t],
  );

  return {
    addProvider,
    updateProvider,
    switchProvider,
    deleteProvider,
    saveUsageScript,
    isLoading:
      addProviderMutation.isPending ||
      updateProviderMutation.isPending ||
      deleteProviderMutation.isPending ||
      switchProviderMutation.isPending,
  };
}
</file>

<file path="src/lib/api/skills.ts">
import { invoke } from "@tauri-apps/api/core";

export interface Skill {
  key: string;
  name: string;
  description: string;
  directory: string;
  readmeUrl?: string;
  installed: boolean;
  repoOwner?: string;
  repoName?: string;
  repoBranch?: string;
}

export interface SkillRepo {
  owner: string;
  name: string;
  branch: string;
  enabled: boolean;
}

export type AppType = "claude" | "codex" | "gemini";

export const skillsApi = {
  async getAll(app: AppType = "claude"): Promise<Skill[]> {
    if (app === "claude") {
      return await invoke("get_skills");
    }
    return await invoke("get_skills_for_app", { app });
  },

  async install(directory: string, app: AppType = "claude"): Promise<boolean> {
    if (app === "claude") {
      return await invoke("install_skill", { directory });
    }
    return await invoke("install_skill_for_app", { app, directory });
  },

  async uninstall(
    directory: string,
    app: AppType = "claude",
  ): Promise<boolean> {
    if (app === "claude") {
      return await invoke("uninstall_skill", { directory });
    }
    return await invoke("uninstall_skill_for_app", { app, directory });
  },

  async getRepos(): Promise<SkillRepo[]> {
    return await invoke("get_skill_repos");
  },

  async addRepo(repo: SkillRepo): Promise<boolean> {
    return await invoke("add_skill_repo", { repo });
  },

  async removeRepo(owner: string, name: string): Promise<boolean> {
    return await invoke("remove_skill_repo", { owner, name });
  },
};
</file>

<file path="src/config/codexProviderPresets.ts">
/**
 * Codex 预设供应商配置模板
 */
import { ProviderCategory } from "../types";
import type { PresetTheme } from "./claudeProviderPresets";

export interface CodexProviderPreset {
  name: string;
  websiteUrl: string;
  // 第三方供应商可提供单独的获取 API Key 链接
  apiKeyUrl?: string;
  auth: Record<string, any>; // 将写入 ~/.codex/auth.json
  config: string; // 将写入 ~/.codex/config.toml（TOML 字符串）
  isOfficial?: boolean; // 标识是否为官方预设
  isPartner?: boolean; // 标识是否为商业合作伙伴
  partnerPromotionKey?: string; // 合作伙伴促销信息的 i18n key
  category?: ProviderCategory; // 新增：分类
  isCustomTemplate?: boolean; // 标识是否为自定义模板
  // 新增：请求地址候选列表（用于地址管理/测速）
  endpointCandidates?: string[];
  // 新增：视觉主题配置
  theme?: PresetTheme;
  // 图标配置
  icon?: string; // 图标名称
  iconColor?: string; // 图标颜色
}

/**
 * 生成第三方供应商的 auth.json
 */
export function generateThirdPartyAuth(apiKey: string): Record<string, any> {
  return {
    OPENAI_API_KEY: apiKey || "",
  };
}

/**
 * 生成第三方供应商的 config.toml
 */
export function generateThirdPartyConfig(
  providerName: string,
  baseUrl: string,
  modelName = "gpt-5.1-codex",
): string {
  // 清理供应商名称，确保符合TOML键名规范
  const cleanProviderName =
    providerName
      .toLowerCase()
      .replace(/[^a-z0-9_]/g, "_")
      .replace(/^_+|_+$/g, "") || "custom";

  return `model_provider = "${cleanProviderName}"
model = "${modelName}"
model_reasoning_effort = "high"
disable_response_storage = true

[model_providers.${cleanProviderName}]
name = "${cleanProviderName}"
base_url = "${baseUrl}"
wire_api = "responses"
requires_openai_auth = true`;
}

export const codexProviderPresets: CodexProviderPreset[] = [
  {
    name: "AI Code With",
    websiteUrl: "https://aicodewith.com",
    category: "aggregator",
    auth: generateThirdPartyAuth(""),
    config: `model_provider = "aicodewith"
model = "gpt-5.2"
model_reasoning_effort = "high"
disable_response_storage = true
preferred_auth_method = "apikey"
requires_openai_auth = true

[model_providers.aicodewith]
name = "aicodewith"
base_url = "https://api.aicodewith.com/chatgpt/v1"
wire_api = "responses"`,
    endpointCandidates: ["https://api.aicodewith.com/chatgpt/v1"],
    icon: "aicodewith",
    iconColor: "#111111",
  },
];
</file>

<file path="src/types.ts">
export type ProviderCategory =
  | "official" // 官方
  | "cn_official" // 开源官方（原"国产官方"）
  | "aggregator" // 聚合网站
  | "third_party" // 第三方供应商
  | "custom"; // 自定义

export interface Provider {
  id: string;
  name: string;
  settingsConfig: Record<string, any>; // 应用配置对象：Claude 为 settings.json；Codex 为 { auth, config }
  websiteUrl?: string;
  // 新增：供应商分类（用于差异化提示/能力开关）
  category?: ProviderCategory;
  createdAt?: number; // 添加时间戳（毫秒）
  sortIndex?: number; // 排序索引（用于自定义拖拽排序）
  // 备注信息
  notes?: string;
  // 新增：是否为商业合作伙伴
  isPartner?: boolean;
  // 可选：供应商元数据（仅存于 ~/.cc-switch/config.json，不写入 live 配置）
  meta?: ProviderMeta;
  // 图标配置
  icon?: string; // 图标名称（如 "openai", "anthropic"）
  iconColor?: string; // 图标颜色（Hex 格式，如 "#00A67E"）
  // 是否加入故障转移队列
  inFailoverQueue?: boolean;
}

export interface AppConfig {
  providers: Record<string, Provider>;
  current: string;
}

// 自定义端点配置
export interface CustomEndpoint {
  url: string;
  addedAt: number;
  lastUsed?: number;
}

// 端点候选项（用于端点测速弹窗）
export interface EndpointCandidate {
  id?: string;
  url: string;
  isCustom?: boolean;
}

// 用量查询脚本配置
export interface UsageScript {
  enabled: boolean; // 是否启用用量查询
  language: "javascript"; // 脚本语言
  code: string; // 脚本代码（JSON 格式配置）
  timeout?: number; // 超时时间（秒，默认 10）
  apiKey?: string; // 用量查询专用的 API Key（通用模板使用）
  baseUrl?: string; // 用量查询专用的 Base URL（通用和 NewAPI 模板使用）
  accessToken?: string; // 访问令牌（NewAPI 模板使用）
  userId?: string; // 用户ID（NewAPI 模板使用）
  autoQueryInterval?: number; // 自动查询间隔（单位：分钟，0 表示禁用）
  autoIntervalMinutes?: number; // 自动查询间隔（分钟）- 别名字段
  request?: {
    // 请求配置
    url?: string; // 请求 URL
    method?: string; // HTTP 方法
    headers?: Record<string, string>; // 请求头
    body?: any; // 请求体
  };
}

// 单个套餐用量数据
export interface UsageData {
  planName?: string; // 套餐名称（可选）
  extra?: string; // 扩展字段，可自由补充需要展示的文本（可选）
  isValid?: boolean; // 套餐是否有效（可选）
  invalidMessage?: string; // 失效原因说明（可选，当 isValid 为 false 时显示）
  total?: number; // 总额度（可选）
  used?: number; // 已用额度（可选）
  remaining?: number; // 剩余额度（可选）
  unit?: string; // 单位（可选）
}

// 用量查询结果（支持多套餐）
export interface UsageResult {
  success: boolean;
  data?: UsageData[]; // 改为数组，支持返回多个套餐
  error?: string;
}

// 供应商元数据（字段名与后端一致，保持 snake_case）
export interface ProviderMeta {
  // 自定义端点：以 URL 为键，值为端点信息
  custom_endpoints?: Record<string, CustomEndpoint>;
  // 用量查询脚本配置
  usage_script?: UsageScript;
  // 是否为官方合作伙伴
  isPartner?: boolean;
  // 合作伙伴促销 key（用于后端识别 PackyCode 等）
  partnerPromotionKey?: string;
}

// 应用设置类型（用于设置对话框与 Tauri API）
// 存储在本地 ~/.cc-switch/settings.json，不随数据库同步
export interface Settings {
  // ===== 设备级 UI 设置 =====
  // 是否在系统托盘（macOS 菜单栏）显示图标
  showInTray: boolean;
  // 点击关闭按钮时是否最小化到托盘而不是关闭应用
  minimizeToTrayOnClose: boolean;
  // 启用 Claude 插件联动（写入 ~/.claude/config.json 的 primaryApiKey）
  enableClaudePluginIntegration?: boolean;
  // 跳过 Claude Code 初次安装确认（写入 ~/.claude.json 的 hasCompletedOnboarding）
  skipClaudeOnboarding?: boolean;
  // 是否开机自启
  launchOnStartup?: boolean;
  // 首选语言（可选，默认中文）
  language?: "en" | "zh" | "ja";

  // ===== 设备级目录覆盖 =====
  // 覆盖 Claude Code 配置目录（可选）
  claudeConfigDir?: string;
  // 覆盖 Codex 配置目录（可选）
  codexConfigDir?: string;
  // 覆盖 Gemini 配置目录（可选）
  geminiConfigDir?: string;

  // ===== 当前供应商 ID（设备级）=====
  // 当前 Claude 供应商 ID（优先于数据库 is_current）
  currentProviderClaude?: string;
  // 当前 Codex 供应商 ID（优先于数据库 is_current）
  currentProviderCodex?: string;
  // 当前 Gemini 供应商 ID（优先于数据库 is_current）
  currentProviderGemini?: string;
}

// MCP 服务器连接参数（宽松：允许扩展字段）
export interface McpServerSpec {
  // 可选：社区常见 .mcp.json 中 stdio 配置可不写 type
  type?: "stdio" | "http" | "sse";
  // stdio 字段
  command?: string;
  args?: string[];
  env?: Record<string, string>;
  cwd?: string;
  // http 和 sse 字段
  url?: string;
  headers?: Record<string, string>;
  // 通用字段
  [key: string]: any;
}

// v3.7.0: MCP 服务器应用启用状态
export interface McpApps {
  claude: boolean;
  codex: boolean;
  gemini: boolean;
}

// MCP 服务器条目（v3.7.0 统一结构）
export interface McpServer {
  id: string;
  name: string;
  server: McpServerSpec;
  apps: McpApps; // v3.7.0: 标记应用到哪些客户端
  description?: string;
  tags?: string[];
  homepage?: string;
  docs?: string;
  // 兼容旧字段（v3.6.x 及以前）
  enabled?: boolean; // 已废弃，v3.7.0 使用 apps 字段
  source?: string;
  [key: string]: any;
}

// MCP 服务器映射（id -> McpServer）
export type McpServersMap = Record<string, McpServer>;

// MCP 配置状态
export interface McpStatus {
  userConfigPath: string;
  userConfigExists: boolean;
  serverCount: number;
}

// 新：来自 config.json 的 MCP 列表响应
export interface McpConfigResponse {
  configPath: string;
  servers: Record<string, McpServer>;
}
</file>

<file path="src/lib/query/failover.ts">
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { failoverApi } from "@/lib/api/failover";

// ========== 熔断器 Hooks ==========

/**
 * 获取供应商健康状态
 */
export function useProviderHealth(providerId: string, appType: string) {
  return useQuery({
    queryKey: ["providerHealth", providerId, appType],
    queryFn: () => failoverApi.getProviderHealth(providerId, appType),
    enabled: !!providerId && !!appType,
    refetchInterval: 5000, // 每 5 秒刷新一次
    retry: false,
  });
}

/**
 * 重置熔断器
 *
 * 重置后后端会检查是否应该切回优先级更高的供应商，
 * 因此需要同时刷新供应商列表和代理状态。
 */
export function useResetCircuitBreaker() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      providerId,
      appType,
    }: {
      providerId: string;
      appType: string;
    }) => failoverApi.resetCircuitBreaker(providerId, appType),
    onSuccess: (_, variables) => {
      // 刷新健康状态
      queryClient.invalidateQueries({
        queryKey: ["providerHealth", variables.providerId, variables.appType],
      });
      // 刷新供应商列表（因为可能发生了自动恢复切换）
      queryClient.invalidateQueries({
        queryKey: ["providers", variables.appType],
      });
      // 刷新代理状态（更新 active_targets）
      queryClient.invalidateQueries({
        queryKey: ["proxyStatus"],
      });
    },
  });
}

/**
 * 获取熔断器配置
 */
export function useCircuitBreakerConfig() {
  return useQuery({
    queryKey: ["circuitBreakerConfig"],
    queryFn: () => failoverApi.getCircuitBreakerConfig(),
  });
}

/**
 * 更新熔断器配置
 */
export function useUpdateCircuitBreakerConfig() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: failoverApi.updateCircuitBreakerConfig,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["circuitBreakerConfig"] });
    },
  });
}

/**
 * 获取熔断器统计信息
 */
export function useCircuitBreakerStats(providerId: string, appType: string) {
  return useQuery({
    queryKey: ["circuitBreakerStats", providerId, appType],
    queryFn: () => failoverApi.getCircuitBreakerStats(providerId, appType),
    enabled: !!providerId && !!appType,
    refetchInterval: 5000, // 每 5 秒刷新一次
  });
}

// ========== 故障转移队列 Hooks（新） ==========

/**
 * 获取故障转移队列
 */
export function useFailoverQueue(appType: string) {
  return useQuery({
    queryKey: ["failoverQueue", appType],
    queryFn: () => failoverApi.getFailoverQueue(appType),
    enabled: !!appType,
  });
}

/**
 * 获取可添加到队列的供应商
 */
export function useAvailableProvidersForFailover(appType: string) {
  return useQuery({
    queryKey: ["availableProvidersForFailover", appType],
    queryFn: () => failoverApi.getAvailableProvidersForFailover(appType),
    enabled: !!appType,
  });
}

/**
 * 添加供应商到故障转移队列
 */
export function useAddToFailoverQueue() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      appType,
      providerId,
    }: {
      appType: string;
      providerId: string;
    }) => failoverApi.addToFailoverQueue(appType, providerId),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: ["failoverQueue", variables.appType],
      });
      queryClient.invalidateQueries({
        queryKey: ["availableProvidersForFailover", variables.appType],
      });
      queryClient.invalidateQueries({
        queryKey: ["providers", variables.appType],
      });
    },
  });
}

/**
 * 从故障转移队列移除供应商
 */
export function useRemoveFromFailoverQueue() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      appType,
      providerId,
    }: {
      appType: string;
      providerId: string;
    }) => failoverApi.removeFromFailoverQueue(appType, providerId),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: ["failoverQueue", variables.appType],
      });
      queryClient.invalidateQueries({
        queryKey: ["availableProvidersForFailover", variables.appType],
      });
      queryClient.invalidateQueries({
        queryKey: ["providers", variables.appType],
      });
      // 清除该供应商的健康状态缓存（退出队列后不再需要健康监控）
      queryClient.invalidateQueries({
        queryKey: ["providerHealth", variables.providerId, variables.appType],
      });
      // 清除该供应商的熔断器统计缓存
      queryClient.invalidateQueries({
        queryKey: [
          "circuitBreakerStats",
          variables.providerId,
          variables.appType,
        ],
      });
    },
  });
}

// ========== 自动故障转移开关 Hooks ==========

/**
 * 获取指定应用的自动故障转移开关状态
 */
export function useAutoFailoverEnabled(appType: string) {
  return useQuery({
    queryKey: ["autoFailoverEnabled", appType],
    queryFn: () => failoverApi.getAutoFailoverEnabled(appType),
    // 默认值为 false（与后端保持一致）
    placeholderData: false,
  });
}

/**
 * 设置指定应用的自动故障转移开关状态
 */
export function useSetAutoFailoverEnabled() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ appType, enabled }: { appType: string; enabled: boolean }) =>
      failoverApi.setAutoFailoverEnabled(appType, enabled),

    // 乐观更新
    onMutate: async ({ appType, enabled }) => {
      await queryClient.cancelQueries({
        queryKey: ["autoFailoverEnabled", appType],
      });
      const previousValue = queryClient.getQueryData<boolean>([
        "autoFailoverEnabled",
        appType,
      ]);

      queryClient.setQueryData(["autoFailoverEnabled", appType], enabled);

      return { previousValue, appType };
    },

    // 错误时回滚
    onError: (_error, _variables, context) => {
      if (context?.previousValue !== undefined) {
        queryClient.setQueryData(
          ["autoFailoverEnabled", context.appType],
          context.previousValue,
        );
      }
    },

    // 无论成功失败，都重新获取
    onSettled: (_, __, variables) => {
      queryClient.invalidateQueries({
        queryKey: ["autoFailoverEnabled", variables.appType],
      });
    },
  });
}
</file>

<file path="src/lib/api/failover.ts">
import { invoke } from "@tauri-apps/api/core";
import type {
  ProviderHealth,
  CircuitBreakerConfig,
  CircuitBreakerStats,
  FailoverQueueItem,
} from "@/types/proxy";

export interface Provider {
  id: string;
  name: string;
  settingsConfig: unknown;
  websiteUrl?: string;
  category?: string;
  createdAt?: number;
  sortIndex?: number;
  notes?: string;
  meta?: unknown;
  icon?: string;
  iconColor?: string;
}

export const failoverApi = {
  // ========== 熔断器 API ==========

  // 获取供应商健康状态
  async getProviderHealth(
    providerId: string,
    appType: string,
  ): Promise<ProviderHealth> {
    return invoke("get_provider_health", { providerId, appType });
  },

  // 重置熔断器
  async resetCircuitBreaker(
    providerId: string,
    appType: string,
  ): Promise<void> {
    return invoke("reset_circuit_breaker", { providerId, appType });
  },

  // 获取熔断器配置
  async getCircuitBreakerConfig(): Promise<CircuitBreakerConfig> {
    return invoke("get_circuit_breaker_config");
  },

  // 更新熔断器配置
  async updateCircuitBreakerConfig(
    config: CircuitBreakerConfig,
  ): Promise<void> {
    return invoke("update_circuit_breaker_config", { config });
  },

  // 获取熔断器统计信息
  async getCircuitBreakerStats(
    providerId: string,
    appType: string,
  ): Promise<CircuitBreakerStats | null> {
    return invoke("get_circuit_breaker_stats", { providerId, appType });
  },

  // ========== 故障转移队列 API（新） ==========

  // 获取故障转移队列
  async getFailoverQueue(appType: string): Promise<FailoverQueueItem[]> {
    return invoke("get_failover_queue", { appType });
  },

  // 获取可添加到队列的供应商（不在队列中的）
  async getAvailableProvidersForFailover(appType: string): Promise<Provider[]> {
    return invoke("get_available_providers_for_failover", { appType });
  },

  // 添加供应商到故障转移队列
  async addToFailoverQueue(appType: string, providerId: string): Promise<void> {
    return invoke("add_to_failover_queue", { appType, providerId });
  },

  // 从故障转移队列移除供应商
  async removeFromFailoverQueue(
    appType: string,
    providerId: string,
  ): Promise<void> {
    return invoke("remove_from_failover_queue", { appType, providerId });
  },

  // 获取指定应用的自动故障转移开关状态
  async getAutoFailoverEnabled(appType: string): Promise<boolean> {
    return invoke("get_auto_failover_enabled", { appType });
  },

  // 设置指定应用的自动故障转移开关状态
  async setAutoFailoverEnabled(
    appType: string,
    enabled: boolean,
  ): Promise<void> {
    return invoke("set_auto_failover_enabled", { appType, enabled });
  },
};
</file>

<file path="src/lib/query/mutations.ts">
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useTranslation } from "react-i18next";
import { toast } from "sonner";
import { providersApi, settingsApi, type AppId } from "@/lib/api";
import type { Provider, Settings } from "@/types";
import { extractErrorMessage } from "@/utils/errorUtils";
import { generateUUID } from "@/utils/uuid";

export const useAddProviderMutation = (appId: AppId) => {
  const queryClient = useQueryClient();
  const { t } = useTranslation();

  return useMutation({
    mutationFn: async (providerInput: Omit<Provider, "id">) => {
      const newProvider: Provider = {
        ...providerInput,
        id: generateUUID(),
        createdAt: Date.now(),
      };
      await providersApi.add(newProvider, appId);
      return newProvider;
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ["providers", appId] });

      // 更新托盘菜单（失败不影响主操作）
      try {
        await providersApi.updateTrayMenu();
      } catch (trayError) {
        console.error(
          "Failed to update tray menu after adding provider",
          trayError,
        );
      }

      toast.success(
        t("notifications.providerAdded", {
          defaultValue: "供应商已添加",
        }),
        {
          closeButton: true,
        },
      );
    },
    onError: (error: Error) => {
      toast.error(
        t("notifications.addFailed", {
          defaultValue: "添加供应商失败: {{error}}",
          error: error.message,
        }),
      );
    },
  });
};

export const useUpdateProviderMutation = (appId: AppId) => {
  const queryClient = useQueryClient();
  const { t } = useTranslation();

  return useMutation({
    mutationFn: async (provider: Provider) => {
      await providersApi.update(provider, appId);
      return provider;
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ["providers", appId] });
      toast.success(
        t("notifications.updateSuccess", {
          defaultValue: "供应商更新成功",
        }),
        {
          closeButton: true,
        },
      );
    },
    onError: (error: Error) => {
      toast.error(
        t("notifications.updateFailed", {
          defaultValue: "更新供应商失败: {{error}}",
          error: error.message,
        }),
      );
    },
  });
};

export const useDeleteProviderMutation = (appId: AppId) => {
  const queryClient = useQueryClient();
  const { t } = useTranslation();

  return useMutation({
    mutationFn: async (providerId: string) => {
      await providersApi.delete(providerId, appId);
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ["providers", appId] });

      // 更新托盘菜单（失败不影响主操作）
      try {
        await providersApi.updateTrayMenu();
      } catch (trayError) {
        console.error(
          "Failed to update tray menu after deleting provider",
          trayError,
        );
      }

      toast.success(
        t("notifications.deleteSuccess", {
          defaultValue: "供应商已删除",
        }),
        {
          closeButton: true,
        },
      );
    },
    onError: (error: Error) => {
      toast.error(
        t("notifications.deleteFailed", {
          defaultValue: "删除供应商失败: {{error}}",
          error: error.message,
        }),
      );
    },
  });
};

export const useSwitchProviderMutation = (appId: AppId) => {
  const queryClient = useQueryClient();
  const { t } = useTranslation();

  return useMutation({
    mutationFn: async (providerId: string) => {
      return await providersApi.switch(providerId, appId);
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ["providers", appId] });

      // 更新托盘菜单（失败不影响主操作）
      try {
        await providersApi.updateTrayMenu();
      } catch (trayError) {
        console.error(
          "Failed to update tray menu after switching provider",
          trayError,
        );
      }

      toast.success(
        t("notifications.switchSuccess", {
          defaultValue: "切换供应商成功",
          appName: t(`apps.${appId}`, { defaultValue: appId }),
        }),
        {
          closeButton: true,
        },
      );
    },
    onError: (error: Error) => {
      const detail = extractErrorMessage(error) || t("common.unknown");

      // 标题与详情分离，便于扫描 + 一键复制
      toast.error(
        t("notifications.switchFailedTitle", { defaultValue: "切换失败" }),
        {
          description: t("notifications.switchFailed", {
            defaultValue: "切换失败：{{error}}",
            error: detail,
          }),
          duration: 6000,
          action: {
            label: t("common.copy", { defaultValue: "复制" }),
            onClick: () => {
              navigator.clipboard?.writeText(detail).catch(() => undefined);
            },
          },
        },
      );
    },
  });
};

export const useSaveSettingsMutation = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (settings: Settings) => {
      await settingsApi.save(settings);
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ["settings"] });
    },
  });
};
</file>

<file path="src/components/providers/ProviderActions.tsx">
import {
  BarChart3,
  Check,
  Copy,
  Edit,
  Loader2,
  Play,
  Plus,
  TestTube2,
  Trash2,
} from "lucide-react";
import { useTranslation } from "react-i18next";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

interface ProviderActionsProps {
  isCurrent: boolean;
  isTesting?: boolean;
  isProxyTakeover?: boolean;
  onSwitch: () => void;
  onEdit: () => void;
  onDuplicate: () => void;
  onTest?: () => void;
  onConfigureUsage: () => void;
  onDelete: () => void;
  // 故障转移相关
  isAutoFailoverEnabled?: boolean;
  isInFailoverQueue?: boolean;
  onToggleFailover?: (enabled: boolean) => void;
}

export function ProviderActions({
  isCurrent,
  isTesting,
  isProxyTakeover = false,
  onSwitch,
  onEdit,
  onDuplicate,
  onTest,
  onConfigureUsage,
  onDelete,
  // 故障转移相关
  isAutoFailoverEnabled = false,
  isInFailoverQueue = false,
  onToggleFailover,
}: ProviderActionsProps) {
  const { t } = useTranslation();
  const iconButtonClass = "h-8 w-8 p-1";

  // 故障转移模式下的按钮逻辑
  const isFailoverMode = isAutoFailoverEnabled && onToggleFailover;

  // 处理主按钮点击
  const handleMainButtonClick = () => {
    if (isFailoverMode) {
      // 故障转移模式：切换队列状态
      onToggleFailover(!isInFailoverQueue);
    } else {
      // 普通模式：切换供应商
      onSwitch();
    }
  };

  // 主按钮的状态和样式
  const getMainButtonState = () => {
    if (isFailoverMode) {
      // 故障转移模式
      if (isInFailoverQueue) {
        return {
          disabled: false,
          variant: "secondary" as const,
          className:
            "bg-blue-100 text-blue-600 hover:bg-blue-200 dark:bg-blue-900/50 dark:text-blue-400 dark:hover:bg-blue-900/70",
          icon: <Check className="h-4 w-4" />,
          text: t("failover.inQueue", { defaultValue: "已加入" }),
        };
      }
      return {
        disabled: false,
        variant: "default" as const,
        className:
          "bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700",
        icon: <Plus className="h-4 w-4" />,
        text: t("failover.addQueue", { defaultValue: "加入" }),
      };
    }

    // 普通模式
    if (isCurrent) {
      return {
        disabled: true,
        variant: "secondary" as const,
        className:
          "bg-gray-200 text-muted-foreground hover:bg-gray-200 hover:text-muted-foreground dark:bg-gray-700 dark:hover:bg-gray-700",
        icon: <Check className="h-4 w-4" />,
        text: t("provider.inUse"),
      };
    }

    return {
      disabled: false,
      variant: "default" as const,
      className: isProxyTakeover
        ? "bg-emerald-500 hover:bg-emerald-600 dark:bg-emerald-600 dark:hover:bg-emerald-700"
        : "",
      icon: <Play className="h-4 w-4" />,
      text: t("provider.enable"),
    };
  };

  const buttonState = getMainButtonState();

  return (
    <div className="flex items-center gap-1.5">
      <Button
        size="sm"
        variant={buttonState.variant}
        onClick={handleMainButtonClick}
        disabled={buttonState.disabled}
        className={cn("w-[4.5rem] px-2.5", buttonState.className)}
      >
        {buttonState.icon}
        {buttonState.text}
      </Button>

      <div className="flex items-center gap-1">
        <Button
          size="icon"
          variant="ghost"
          onClick={onEdit}
          title={t("common.edit")}
          className={iconButtonClass}
        >
          <Edit className="h-4 w-4" />
        </Button>

        <Button
          size="icon"
          variant="ghost"
          onClick={onDuplicate}
          title={t("provider.duplicate")}
          className={iconButtonClass}
        >
          <Copy className="h-4 w-4" />
        </Button>

        {onTest && (
          <Button
            size="icon"
            variant="ghost"
            onClick={onTest}
            disabled={isTesting}
            title={t("modelTest.testProvider", "测试模型")}
            className={iconButtonClass}
          >
            {isTesting ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              <TestTube2 className="h-4 w-4" />
            )}
          </Button>
        )}

        <Button
          size="icon"
          variant="ghost"
          onClick={onConfigureUsage}
          title={t("provider.configureUsage")}
          className={iconButtonClass}
        >
          <BarChart3 className="h-4 w-4" />
        </Button>

        <Button
          size="icon"
          variant="ghost"
          onClick={isCurrent ? undefined : onDelete}
          title={t("common.delete")}
          className={cn(
            iconButtonClass,
            !isCurrent && "hover:text-red-500 dark:hover:text-red-400",
            isCurrent && "opacity-40 cursor-not-allowed text-muted-foreground",
          )}
        >
          <Trash2 className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/providers/ProviderList.tsx">
import { CSS } from "@dnd-kit/utilities";
import { DndContext, closestCenter } from "@dnd-kit/core";
import {
  SortableContext,
  useSortable,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import {
  useEffect,
  useMemo,
  useRef,
  useState,
  type CSSProperties,
} from "react";
import { AnimatePresence, motion } from "framer-motion";
import { Search, X } from "lucide-react";
import { useTranslation } from "react-i18next";
import type { Provider } from "@/types";
import type { AppId } from "@/lib/api";
import { useDragSort } from "@/hooks/useDragSort";
import { useStreamCheck } from "@/hooks/useStreamCheck";
import { ProviderCard } from "@/components/providers/ProviderCard";
import { ProviderEmptyState } from "@/components/providers/ProviderEmptyState";
import {
  useAutoFailoverEnabled,
  useFailoverQueue,
  useAddToFailoverQueue,
  useRemoveFromFailoverQueue,
} from "@/lib/query/failover";
import { useCallback } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";

interface ProviderListProps {
  providers: Record<string, Provider>;
  currentProviderId: string;
  appId: AppId;
  onSwitch: (provider: Provider) => void;
  onEdit: (provider: Provider) => void;
  onDelete: (provider: Provider) => void;
  onDuplicate: (provider: Provider) => void;
  onConfigureUsage?: (provider: Provider) => void;
  onOpenWebsite: (url: string) => void;
  onCreate?: () => void;
  isLoading?: boolean;
  isProxyRunning?: boolean; // 代理服务运行状态
  isProxyTakeover?: boolean; // 代理接管模式（Live配置已被接管）
  activeProviderId?: string; // 代理当前实际使用的供应商 ID（用于故障转移模式下标注绿色边框）
}

export function ProviderList({
  providers,
  currentProviderId,
  appId,
  onSwitch,
  onEdit,
  onDelete,
  onDuplicate,
  onConfigureUsage,
  onOpenWebsite,
  onCreate,
  isLoading = false,
  isProxyRunning = false,
  isProxyTakeover = false,
  activeProviderId,
}: ProviderListProps) {
  const { t } = useTranslation();
  const { sortedProviders, sensors, handleDragEnd } = useDragSort(
    providers,
    appId,
  );

  // 流式健康检查
  const { checkProvider, isChecking } = useStreamCheck(appId);

  // 故障转移相关
  const { data: isAutoFailoverEnabled } = useAutoFailoverEnabled(appId);
  const { data: failoverQueue } = useFailoverQueue(appId);
  const addToQueue = useAddToFailoverQueue();
  const removeFromQueue = useRemoveFromFailoverQueue();

  // 联动状态：只有当前应用开启代理接管且故障转移开启时才启用故障转移模式
  const isFailoverModeActive =
    isProxyTakeover === true && isAutoFailoverEnabled === true;

  // 计算供应商在故障转移队列中的优先级（基于 sortIndex 排序）
  const getFailoverPriority = useCallback(
    (providerId: string): number | undefined => {
      if (!isFailoverModeActive || !failoverQueue) return undefined;
      const index = failoverQueue.findIndex(
        (item) => item.providerId === providerId,
      );
      return index >= 0 ? index + 1 : undefined;
    },
    [isFailoverModeActive, failoverQueue],
  );

  // 判断供应商是否在故障转移队列中
  const isInFailoverQueue = useCallback(
    (providerId: string): boolean => {
      if (!isFailoverModeActive || !failoverQueue) return false;
      return failoverQueue.some((item) => item.providerId === providerId);
    },
    [isFailoverModeActive, failoverQueue],
  );

  // 切换供应商的故障转移队列状态
  const handleToggleFailover = useCallback(
    (providerId: string, enabled: boolean) => {
      if (enabled) {
        addToQueue.mutate({ appType: appId, providerId });
      } else {
        removeFromQueue.mutate({ appType: appId, providerId });
      }
    },
    [appId, addToQueue, removeFromQueue],
  );

  const handleTest = (provider: Provider) => {
    checkProvider(provider.id, provider.name);
  };

  const [searchTerm, setSearchTerm] = useState("");
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const searchInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      const key = event.key.toLowerCase();
      if ((event.metaKey || event.ctrlKey) && key === "f") {
        event.preventDefault();
        setIsSearchOpen(true);
        return;
      }

      if (key === "escape") {
        setIsSearchOpen(false);
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, []);

  useEffect(() => {
    if (isSearchOpen) {
      const frame = requestAnimationFrame(() => {
        searchInputRef.current?.focus();
        searchInputRef.current?.select();
      });
      return () => cancelAnimationFrame(frame);
    }
  }, [isSearchOpen]);

  const filteredProviders = useMemo(() => {
    const keyword = searchTerm.trim().toLowerCase();
    if (!keyword) return sortedProviders;
    return sortedProviders.filter((provider) => {
      const fields = [provider.name, provider.notes, provider.websiteUrl];
      return fields.some((field) =>
        field?.toString().toLowerCase().includes(keyword),
      );
    });
  }, [searchTerm, sortedProviders]);

  if (isLoading) {
    return (
      <div className="space-y-3">
        {[0, 1, 2].map((index) => (
          <div
            key={index}
            className="w-full border border-dashed rounded-lg h-28 border-muted-foreground/40 bg-muted/40"
          />
        ))}
      </div>
    );
  }

  if (sortedProviders.length === 0) {
    return <ProviderEmptyState onCreate={onCreate} />;
  }

  const renderProviderList = () => (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragEnd={handleDragEnd}
    >
      <SortableContext
        items={filteredProviders.map((provider) => provider.id)}
        strategy={verticalListSortingStrategy}
      >
        <div className="space-y-3">
          {filteredProviders.map((provider) => (
            <SortableProviderCard
              key={provider.id}
              provider={provider}
              isCurrent={provider.id === currentProviderId}
              appId={appId}
              onSwitch={onSwitch}
              onEdit={onEdit}
              onDelete={onDelete}
              onDuplicate={onDuplicate}
              onConfigureUsage={onConfigureUsage}
              onOpenWebsite={onOpenWebsite}
              onTest={handleTest}
              isTesting={isChecking(provider.id)}
              isProxyRunning={isProxyRunning}
              isProxyTakeover={isProxyTakeover}
              // 故障转移相关：联动状态
              isAutoFailoverEnabled={isFailoverModeActive}
              failoverPriority={getFailoverPriority(provider.id)}
              isInFailoverQueue={isInFailoverQueue(provider.id)}
              onToggleFailover={(enabled) =>
                handleToggleFailover(provider.id, enabled)
              }
              activeProviderId={activeProviderId}
            />
          ))}
        </div>
      </SortableContext>
    </DndContext>
  );

  return (
    <div className="mt-4 space-y-4">
      <AnimatePresence>
        {isSearchOpen && (
          <motion.div
            key="provider-search"
            initial={{ opacity: 0, y: -8, scale: 0.98 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: -8, scale: 0.98 }}
            transition={{ duration: 0.18, ease: "easeOut" }}
            className="fixed left-1/2 top-[6.5rem] z-40 w-[min(90vw,26rem)] -translate-x-1/2 sm:right-6 sm:left-auto sm:translate-x-0"
          >
            <div className="p-4 space-y-3 border shadow-md rounded-2xl border-white/10 bg-background/95 shadow-black/20 backdrop-blur-md">
              <div className="relative flex items-center gap-2">
                <Search className="absolute w-4 h-4 -translate-y-1/2 pointer-events-none left-3 top-1/2 text-muted-foreground" />
                <Input
                  ref={searchInputRef}
                  value={searchTerm}
                  onChange={(event) => setSearchTerm(event.target.value)}
                  placeholder={t("provider.searchPlaceholder", {
                    defaultValue: "Search name, notes, or URL...",
                  })}
                  aria-label={t("provider.searchAriaLabel", {
                    defaultValue: "Search providers",
                  })}
                  className="pr-16 pl-9"
                />
                {searchTerm && (
                  <Button
                    variant="ghost"
                    size="sm"
                    className="absolute text-xs -translate-y-1/2 right-11 top-1/2"
                    onClick={() => setSearchTerm("")}
                  >
                    {t("common.clear", { defaultValue: "Clear" })}
                  </Button>
                )}
                <Button
                  variant="ghost"
                  size="icon"
                  className="ml-auto"
                  onClick={() => setIsSearchOpen(false)}
                  aria-label={t("provider.searchCloseAriaLabel", {
                    defaultValue: "Close provider search",
                  })}
                >
                  <X className="w-4 h-4" />
                </Button>
              </div>
              <div className="flex flex-wrap items-center justify-between gap-2 text-[11px] text-muted-foreground">
                <span>
                  {t("provider.searchScopeHint", {
                    defaultValue: "Matches provider name, notes, and URL.",
                  })}
                </span>
                <span>
                  {t("provider.searchCloseHint", {
                    defaultValue: "Press Esc to close",
                  })}
                </span>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {filteredProviders.length === 0 ? (
        <div className="px-6 py-8 text-sm text-center border border-dashed rounded-lg border-border text-muted-foreground">
          {t("provider.noSearchResults", {
            defaultValue: "No providers match your search.",
          })}
        </div>
      ) : (
        renderProviderList()
      )}
    </div>
  );
}

interface SortableProviderCardProps {
  provider: Provider;
  isCurrent: boolean;
  appId: AppId;
  onSwitch: (provider: Provider) => void;
  onEdit: (provider: Provider) => void;
  onDelete: (provider: Provider) => void;
  onDuplicate: (provider: Provider) => void;
  onConfigureUsage?: (provider: Provider) => void;
  onOpenWebsite: (url: string) => void;
  onTest: (provider: Provider) => void;
  isTesting: boolean;
  isProxyRunning: boolean;
  isProxyTakeover: boolean;
  // 故障转移相关
  isAutoFailoverEnabled: boolean;
  failoverPriority?: number;
  isInFailoverQueue: boolean;
  onToggleFailover: (enabled: boolean) => void;
  activeProviderId?: string;
}

function SortableProviderCard({
  provider,
  isCurrent,
  appId,
  onSwitch,
  onEdit,
  onDelete,
  onDuplicate,
  onConfigureUsage,
  onOpenWebsite,
  onTest,
  isTesting,
  isProxyRunning,
  isProxyTakeover,
  isAutoFailoverEnabled,
  failoverPriority,
  isInFailoverQueue,
  onToggleFailover,
  activeProviderId,
}: SortableProviderCardProps) {
  const {
    setNodeRef,
    attributes,
    listeners,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: provider.id });

  const style: CSSProperties = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  return (
    <div ref={setNodeRef} style={style}>
      <ProviderCard
        provider={provider}
        isCurrent={isCurrent}
        appId={appId}
        onSwitch={onSwitch}
        onEdit={onEdit}
        onDelete={onDelete}
        onDuplicate={onDuplicate}
        onConfigureUsage={
          onConfigureUsage ? (item) => onConfigureUsage(item) : () => undefined
        }
        onOpenWebsite={onOpenWebsite}
        onTest={onTest}
        isTesting={isTesting}
        isProxyRunning={isProxyRunning}
        isProxyTakeover={isProxyTakeover}
        dragHandleProps={{
          attributes,
          listeners,
          isDragging,
        }}
        // 故障转移相关
        isAutoFailoverEnabled={isAutoFailoverEnabled}
        failoverPriority={failoverPriority}
        isInFailoverQueue={isInFailoverQueue}
        onToggleFailover={onToggleFailover}
        activeProviderId={activeProviderId}
      />
    </div>
  );
}
</file>

<file path="src/config/claudeProviderPresets.ts">
/**
 * 预设供应商配置模板
 */
import { ProviderCategory } from "../types";

export interface TemplateValueConfig {
  label: string;
  placeholder: string;
  defaultValue?: string;
  editorValue: string;
}

/**
 * 预设供应商的视觉主题配置
 */
export interface PresetTheme {
  /** 图标类型：'claude' | 'codex' | 'gemini' | 'generic' */
  icon?: "claude" | "codex" | "gemini" | "generic";
  /** 背景色（选中状态），支持 Tailwind 类名或 hex 颜色 */
  backgroundColor?: string;
  /** 文字色（选中状态），支持 Tailwind 类名或 hex 颜色 */
  textColor?: string;
}

export interface ProviderPreset {
  name: string;
  websiteUrl: string;
  // 新增：第三方/聚合等可单独配置获取 API Key 的链接
  apiKeyUrl?: string;
  settingsConfig: object;
  isOfficial?: boolean; // 标识是否为官方预设
  isPartner?: boolean; // 标识是否为商业合作伙伴
  partnerPromotionKey?: string; // 合作伙伴促销信息的 i18n key
  category?: ProviderCategory; // 新增：分类
  // 新增：指定该预设所使用的 API Key 字段名（默认 ANTHROPIC_AUTH_TOKEN）
  apiKeyField?: "ANTHROPIC_AUTH_TOKEN" | "ANTHROPIC_API_KEY";
  // 新增：模板变量定义，用于动态替换配置中的值
  templateValues?: Record<string, TemplateValueConfig>; // editorValue 存储编辑器中的实时输入值
  // 新增：请求地址候选列表（用于地址管理/测速）
  endpointCandidates?: string[];
  // 新增：视觉主题配置
  theme?: PresetTheme;
  // 图标配置
  icon?: string; // 图标名称
  iconColor?: string; // 图标颜色
}

export const providerPresets: ProviderPreset[] = [
  {
    name: "AI Code With",
    websiteUrl: "https://aicodewith.com",
    settingsConfig: {
      env: {
        ANTHROPIC_BASE_URL: "https://api.aicodewith.com",
        ANTHROPIC_AUTH_TOKEN: "",
      },
    },
    endpointCandidates: ["https://api.aicodewith.com"],
    category: "aggregator",
    icon: "aicodewith",
    iconColor: "#111111",
  },
];
</file>

<file path="src/components/providers/ProviderCard.tsx">
import { useMemo, useState, useEffect } from "react";
import { GripVertical, ChevronDown, ChevronUp } from "lucide-react";
import { useTranslation } from "react-i18next";
import type {
  DraggableAttributes,
  DraggableSyntheticListeners,
} from "@dnd-kit/core";
import type { Provider } from "@/types";
import type { AppId } from "@/lib/api";
import { cn } from "@/lib/utils";
import { ProviderActions } from "@/components/providers/ProviderActions";
import { ProviderIcon } from "@/components/ProviderIcon";
import UsageFooter from "@/components/UsageFooter";
import { ProviderHealthBadge } from "@/components/providers/ProviderHealthBadge";
import { FailoverPriorityBadge } from "@/components/providers/FailoverPriorityBadge";
import { useProviderHealth } from "@/lib/query/failover";
import { useUsageQuery } from "@/lib/query/queries";

interface DragHandleProps {
  attributes: DraggableAttributes;
  listeners: DraggableSyntheticListeners;
  isDragging: boolean;
}

interface ProviderCardProps {
  provider: Provider;
  isCurrent: boolean;
  appId: AppId;
  onSwitch: (provider: Provider) => void;
  onEdit: (provider: Provider) => void;
  onDelete: (provider: Provider) => void;
  onConfigureUsage: (provider: Provider) => void;
  onOpenWebsite: (url: string) => void;
  onDuplicate: (provider: Provider) => void;
  onTest?: (provider: Provider) => void;
  isTesting?: boolean;
  isProxyRunning: boolean;
  isProxyTakeover?: boolean; // 代理接管模式（Live配置已被接管，切换为热切换）
  dragHandleProps?: DragHandleProps;
  // 故障转移相关
  isAutoFailoverEnabled?: boolean; // 是否开启自动故障转移
  failoverPriority?: number; // 故障转移优先级（1 = P1, 2 = P2, ...）
  isInFailoverQueue?: boolean; // 是否在故障转移队列中
  onToggleFailover?: (enabled: boolean) => void; // 切换故障转移队列
  activeProviderId?: string; // 代理当前实际使用的供应商 ID（用于故障转移模式下标注绿色边框）
}

const extractApiUrl = (provider: Provider, fallbackText: string) => {
  // 优先级 1: 备注
  if (provider.notes?.trim()) {
    return provider.notes.trim();
  }

  // 优先级 2: 官网地址
  if (provider.websiteUrl) {
    return provider.websiteUrl;
  }

  // 优先级 3: 从配置中提取请求地址
  const config = provider.settingsConfig;

  if (config && typeof config === "object") {
    const envBase =
      (config as Record<string, any>)?.env?.ANTHROPIC_BASE_URL ||
      (config as Record<string, any>)?.env?.GOOGLE_GEMINI_BASE_URL;
    if (typeof envBase === "string" && envBase.trim()) {
      return envBase;
    }

    const baseUrl = (config as Record<string, any>)?.config;

    if (typeof baseUrl === "string" && baseUrl.includes("base_url")) {
      const match = baseUrl.match(/base_url\s*=\s*['"]([^'"]+)['"]/);
      if (match?.[1]) {
        return match[1];
      }
    }
  }

  return fallbackText;
};

export function ProviderCard({
  provider,
  isCurrent,
  appId,
  onSwitch,
  onEdit,
  onDelete,
  onConfigureUsage,
  onOpenWebsite,
  onDuplicate,
  onTest,
  isTesting,
  isProxyRunning,
  isProxyTakeover = false,
  dragHandleProps,
  // 故障转移相关
  isAutoFailoverEnabled = false,
  failoverPriority,
  isInFailoverQueue = false,
  onToggleFailover,
  activeProviderId,
}: ProviderCardProps) {
  const { t } = useTranslation();

  // 获取供应商健康状态
  const { data: health } = useProviderHealth(provider.id, appId);

  const fallbackUrlText = t("provider.notConfigured", {
    defaultValue: "未配置接口地址",
  });

  const displayUrl = useMemo(() => {
    return extractApiUrl(provider, fallbackUrlText);
  }, [provider, fallbackUrlText]);

  // 判断是否为可点击的 URL（备注不可点击）
  const isClickableUrl = useMemo(() => {
    // 如果有备注，则不可点击
    if (provider.notes?.trim()) {
      return false;
    }
    // 如果显示的是回退文本，也不可点击
    if (displayUrl === fallbackUrlText) {
      return false;
    }
    // 其他情况（官网地址或请求地址）可点击
    return true;
  }, [provider.notes, displayUrl, fallbackUrlText]);

  const usageEnabled = provider.meta?.usage_script?.enabled ?? false;

  // 获取用量数据以判断是否有多套餐
  const autoQueryInterval = isCurrent
    ? provider.meta?.usage_script?.autoQueryInterval || 0
    : 0;

  const { data: usage } = useUsageQuery(provider.id, appId, {
    enabled: usageEnabled,
    autoQueryInterval,
  });

  const hasMultiplePlans =
    usage?.success && usage.data && usage.data.length > 1;

  // 多套餐默认展开
  const [isExpanded, setIsExpanded] = useState(false);

  // 当检测到多套餐时自动展开
  useEffect(() => {
    if (hasMultiplePlans) {
      setIsExpanded(true);
    }
  }, [hasMultiplePlans]);

  const handleOpenWebsite = () => {
    if (!isClickableUrl) {
      return;
    }
    onOpenWebsite(displayUrl);
  };

  // 判断是否是"当前使用中"的供应商
  // - 故障转移模式：代理实际使用的供应商（activeProviderId）
  // - 代理接管模式（非故障转移）：isCurrent
  // - 普通模式：isCurrent
  const isActiveProvider = isAutoFailoverEnabled
    ? activeProviderId === provider.id
    : isCurrent;

  // 判断是否使用绿色（代理接管模式）还是蓝色（普通模式）
  const shouldUseGreen = isProxyTakeover && isActiveProvider;
  const shouldUseBlue = !isProxyTakeover && isActiveProvider;

  return (
    <div
      className={cn(
        "relative overflow-hidden rounded-xl border border-border p-4 transition-all duration-300",
        "bg-card text-card-foreground group",
        // hover 时的边框效果
        isAutoFailoverEnabled || isProxyTakeover
          ? "hover:border-emerald-500/50"
          : "hover:border-border-active",
        // 当前激活的供应商边框样式
        shouldUseGreen &&
          "border-emerald-500/60 shadow-sm shadow-emerald-500/10",
        shouldUseBlue && "border-blue-500/60 shadow-sm shadow-blue-500/10",
        !isActiveProvider && "hover:shadow-sm",
        dragHandleProps?.isDragging &&
          "cursor-grabbing border-primary shadow-lg scale-105 z-10",
      )}
    >
      <div
        className={cn(
          "absolute inset-0 bg-gradient-to-r to-transparent transition-opacity duration-500 pointer-events-none",
          // 代理接管模式使用绿色渐变，普通模式使用蓝色渐变
          shouldUseGreen && "from-emerald-500/10",
          shouldUseBlue && "from-blue-500/10",
          !isActiveProvider && "from-primary/10",
          isActiveProvider ? "opacity-100" : "opacity-0",
        )}
      />
      <div className="relative flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
        <div className="flex flex-1 items-center gap-2">
          <button
            type="button"
            className={cn(
              "-ml-1.5 flex-shrink-0 cursor-grab active:cursor-grabbing p-1.5",
              "text-muted-foreground/50 hover:text-muted-foreground transition-colors",
              dragHandleProps?.isDragging && "cursor-grabbing",
            )}
            aria-label={t("provider.dragHandle")}
            {...(dragHandleProps?.attributes ?? {})}
            {...(dragHandleProps?.listeners ?? {})}
          >
            <GripVertical className="h-4 w-4" />
          </button>

          {/* 供应商图标 */}
          <div className="h-8 w-8 rounded-lg bg-muted flex items-center justify-center border border-border group-hover:scale-105 transition-transform duration-300">
            <ProviderIcon
              icon={provider.icon}
              name={provider.name}
              color={provider.iconColor}
              size={20}
            />
          </div>

          <div className="space-y-1">
            <div className="flex flex-wrap items-center gap-2 min-h-7">
              <h3 className="text-base font-semibold leading-none">
                {provider.name}
              </h3>

              {/* 健康状态徽章 */}
              {isProxyRunning && isInFailoverQueue && health && (
                <ProviderHealthBadge
                  consecutiveFailures={health.consecutive_failures}
                />
              )}

              {/* 故障转移优先级徽章 */}
              {isAutoFailoverEnabled &&
                isInFailoverQueue &&
                failoverPriority && (
                  <FailoverPriorityBadge priority={failoverPriority} />
                )}

              {provider.category === "third_party" &&
                provider.meta?.isPartner && (
                  <span
                    className="text-yellow-500 dark:text-yellow-400"
                    title={t("provider.officialPartner", {
                      defaultValue: "官方合作伙伴",
                    })}
                  >
                    ⭐
                  </span>
                )}
            </div>

            {displayUrl && (
              <button
                type="button"
                onClick={handleOpenWebsite}
                className={cn(
                  "inline-flex items-center text-sm max-w-[280px]",
                  isClickableUrl
                    ? "text-blue-500 transition-colors hover:underline dark:text-blue-400 cursor-pointer"
                    : "text-muted-foreground cursor-default",
                )}
                title={displayUrl}
                disabled={!isClickableUrl}
              >
                <span className="truncate">{displayUrl}</span>
              </button>
            )}
          </div>
        </div>

        <div className="relative flex items-center ml-auto min-w-0">
          {/* 用量信息区域 - hover 时向左移动，为操作按钮腾出空间 */}
          <div className="ml-auto transition-transform duration-200 group-hover:-translate-x-[14.5rem] group-focus-within:-translate-x-[14.5rem] sm:group-hover:-translate-x-[16rem] sm:group-focus-within:-translate-x-[16rem]">
            <div className="flex items-center gap-1">
              {/* 多套餐时显示套餐数量，单套餐时显示详细信息 */}
              {hasMultiplePlans ? (
                <div className="flex items-center gap-2 text-xs text-gray-600 dark:text-gray-400">
                  <span className="font-medium">
                    {t("usage.multiplePlans", {
                      count: usage?.data?.length || 0,
                      defaultValue: `${usage?.data?.length || 0} 个套餐`,
                    })}
                  </span>
                </div>
              ) : (
                <UsageFooter
                  provider={provider}
                  providerId={provider.id}
                  appId={appId}
                  usageEnabled={usageEnabled}
                  isCurrent={isCurrent}
                  inline={true}
                />
              )}
              {/* 展开/折叠按钮 - 仅在有多套餐时显示 */}
              {hasMultiplePlans && (
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    setIsExpanded(!isExpanded);
                  }}
                  className="p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors text-gray-500 dark:text-gray-400 flex-shrink-0"
                  title={
                    isExpanded
                      ? t("usage.collapse", { defaultValue: "收起" })
                      : t("usage.expand", { defaultValue: "展开" })
                  }
                >
                  {isExpanded ? (
                    <ChevronUp size={14} />
                  ) : (
                    <ChevronDown size={14} />
                  )}
                </button>
              )}
            </div>
          </div>

          {/* 操作按钮区域 - 绝对定位在右侧，hover 时滑入 */}
          <div className="absolute right-0 top-1/2 -translate-y-1/2 flex items-center gap-1.5 opacity-0 pointer-events-none group-hover:opacity-100 group-focus-within:opacity-100 group-hover:pointer-events-auto group-focus-within:pointer-events-auto transition-all duration-200 translate-x-2 group-hover:translate-x-0 group-focus-within:translate-x-0">
            <ProviderActions
              isCurrent={isCurrent}
              isTesting={isTesting}
              isProxyTakeover={isProxyTakeover}
              onSwitch={() => onSwitch(provider)}
              onEdit={() => onEdit(provider)}
              onDuplicate={() => onDuplicate(provider)}
              onTest={onTest ? () => onTest(provider) : undefined}
              onConfigureUsage={() => onConfigureUsage(provider)}
              onDelete={() => onDelete(provider)}
              // 故障转移相关
              isAutoFailoverEnabled={isAutoFailoverEnabled}
              isInFailoverQueue={isInFailoverQueue}
              onToggleFailover={onToggleFailover}
            />
          </div>
        </div>
      </div>

      {/* 展开的完整套餐列表 */}
      {isExpanded && hasMultiplePlans && (
        <div className="mt-4 pt-4 border-t border-border-default">
          <UsageFooter
            provider={provider}
            providerId={provider.id}
            appId={appId}
            usageEnabled={usageEnabled}
            isCurrent={isCurrent}
            inline={false}
          />
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/i18n/locales/ja.json">
{
  "app": {
    "title": "CC Switch",
    "description": "Claude Code・Codex・Gemini CLI のためのオールインワンアシスタント"
  },
  "common": {
    "add": "追加",
    "edit": "編集",
    "delete": "削除",
    "save": "保存",
    "saving": "保存中...",
    "cancel": "キャンセル",
    "confirm": "確認",
    "close": "閉じる",
    "done": "完了",
    "settings": "設定",
    "about": "バージョン情報",
    "version": "バージョン",
    "loading": "読み込み中...",
    "notInstalled": "未インストール",
    "success": "成功",
    "error": "エラー",
    "unknown": "不明",
    "enterValidValue": "有効な値を入力してください",
    "clear": "クリア",
    "toggleTheme": "テーマを切り替え",
    "format": "フォーマット",
    "formatSuccess": "整形しました",
    "formatError": "整形に失敗しました: {{error}}",
    "copy": "コピー",
    "view": "表示",
    "back": "戻る",
    "refresh": "更新",
    "refreshing": "更新中...",
    "all": "すべて",
    "search": "検索",
    "reset": "リセット",
    "actions": "操作",
    "deleting": "削除中..."
  },
  "apiKeyInput": {
    "placeholder": "API Key を入力",
    "show": "API Key を表示",
    "hide": "API Key を隠す"
  },
  "jsonEditor": {
    "mustBeObject": "設定はオブジェクト形式の JSON で入力してください（配列や他の型は不可）",
    "invalidJson": "JSON 形式が正しくありません"
  },
  "claudeConfig": {
    "configLabel": "Claude Code settings.json (JSON) *",
    "writeCommonConfig": "共通設定を書き込む",
    "editCommonConfig": "共通設定を編集",
    "editCommonConfigTitle": "共通設定スニペットを編集",
    "commonConfigHint": "「共通設定を書き込む」がオンのとき settings.json にマージされます",
    "fullSettingsHint": "Claude Code の settings.json 全文"
  },
  "header": {
    "viewOnGithub": "GitHub で見る",
    "toggleDarkMode": "ダークモードに切り替え",
    "toggleLightMode": "ライトモードに切り替え",
    "addProvider": "プロバイダーを追加",
    "switchToChinese": "中国語に切り替え",
    "switchToEnglish": "英語に切り替え",
    "enterEditMode": "編集モードに入る",
    "exitEditMode": "編集モードを終了"
  },
  "provider": {
    "noProviders": "まだプロバイダーがありません",
    "noProvidersDescription": "右上の「プロバイダーを追加」を押して最初の API プロバイダーを登録してください",
    "currentlyUsing": "現在使用中",
    "enable": "有効化",
    "inUse": "使用中",
    "editProvider": "プロバイダーを編集",
    "editProviderHint": "保存すると現在のプロバイダーにすぐ反映されます。",
    "deleteProvider": "プロバイダーを削除",
    "addNewProvider": "新しいプロバイダーを追加",
    "addClaudeProvider": "Claude Code プロバイダーを追加",
    "addCodexProvider": "Codex プロバイダーを追加",
    "addGeminiProvider": "Gemini プロバイダーを追加",
    "addProviderHint": "一覧にすばやく切り替えられるよう、ここに情報を入力してください。",
    "editClaudeProvider": "Claude Code プロバイダーを編集",
    "editCodexProvider": "Codex プロバイダーを編集",
    "configError": "設定エラー",
    "notConfigured": "公式サイト用に未設定",
    "applyToClaudePlugin": "Claude プラグインに適用",
    "removeFromClaudePlugin": "Claude プラグインから解除",
    "dragToReorder": "ドラッグで並べ替え",
    "dragHandle": "ドラッグで並べ替え",
    "searchPlaceholder": "名前・メモ・URLで検索...",
    "searchAriaLabel": "プロバイダーを検索",
    "searchScopeHint": "名前・メモ・URL を対象に検索します。",
    "searchCloseHint": "Esc で閉じる",
    "searchCloseAriaLabel": "検索を閉じる",
    "noSearchResults": "一致するプロバイダーがありません。",
    "duplicate": "複製",
    "sortUpdateFailed": "並び順の更新に失敗しました",
    "configureUsage": "利用状況を設定",
    "name": "プロバイダー名",
    "namePlaceholder": "例: Claude Official",
    "websiteUrl": "Web サイト URL",
    "notes": "メモ",
    "notesPlaceholder": "例: 会社用アカウント",
    "configJson": "Config JSON",
    "writeCommonConfig": "共通設定を書き込む",
    "editCommonConfigButton": "共通設定を編集",
    "configJsonHint": "Claude Code の設定をすべて入力してください",
    "editCommonConfigTitle": "共通設定スニペットを編集",
    "editCommonConfigHint": "共通設定スニペットは、この機能をオンにしたすべてのプロバイダーへマージされます",
    "addProvider": "プロバイダーを追加",
    "sortUpdated": "並び順を更新しました",
    "usageSaved": "利用状況の設定を保存しました",
    "usageSaveFailed": "利用状況設定の保存に失敗しました",
    "geminiConfig": "Gemini 設定",
    "geminiConfigHint": ".env 形式で Gemini を設定してください",
    "form": {
      "gemini": {
        "model": "モデル",
        "oauthTitle": "OAuth 認証モード",
        "oauthHint": "Google 公式は OAuth 個人認証を使用するため API Key は不要です。初回利用時にブラウザが開きます。",
        "apiKeyPlaceholder": "Gemini API Key を入力"
      }
    }
  },
  "notifications": {
    "providerAdded": "プロバイダーを追加しました",
    "providerSaved": "プロバイダー設定を保存しました",
    "providerDeleted": "プロバイダーを削除しました",
    "switchSuccess": "切り替え成功！",
    "switchFailedTitle": "切り替えに失敗しました",
    "switchFailed": "切り替えに失敗しました: {{error}}",
    "autoImported": "既存設定からデフォルトプロバイダーを自動作成しました",
    "addFailed": "プロバイダーの追加に失敗しました: {{error}}",
    "saveFailed": "保存に失敗しました: {{error}}",
    "saveFailedGeneric": "保存に失敗しました。もう一度お試しください",
    "appliedToClaudePlugin": "Claude プラグインに適用しました",
    "removedFromClaudePlugin": "Claude プラグインから削除しました",
    "syncClaudePluginFailed": "Claude プラグインとの同期に失敗しました",
    "skipClaudeOnboardingFailed": "Claude Code の初回確認スキップに失敗しました",
    "clearClaudeOnboardingSkipFailed": "Claude Code の初回確認の復元に失敗しました",
    "updateSuccess": "プロバイダーを更新しました",
    "updateFailed": "プロバイダーの更新に失敗しました: {{error}}",
    "deleteSuccess": "プロバイダーを削除しました",
    "deleteFailed": "プロバイダーの削除に失敗しました: {{error}}",
    "settingsSaved": "設定を保存しました",
    "settingsSaveFailed": "設定の保存に失敗しました: {{error}}"
  },
  "confirm": {
    "deleteProvider": "プロバイダーを削除",
    "deleteProviderMessage": "プロバイダー「{{name}}」を削除してもよろしいですか？この操作は元に戻せません。"
  },
  "settings": {
    "title": "設定",
    "general": "一般",
    "tabGeneral": "一般",
    "tabAdvanced": "詳細",
    "advanced": {
      "configDir": {
        "title": "設定ディレクトリ",
        "description": "Claude、Codex、Gemini の設定保存パスを管理"
      },
      "proxy": {
        "title": "ローカルプロキシ",
        "description": "プロキシサービスの切り替え、ステータスとポート情報を表示",
        "running": "実行中",
        "stopped": "停止中"
      },
      "modelTest": {
        "title": "モデルテスト設定",
        "description": "モデルテストで使用するデフォルトモデルとプロンプトを設定"
      },
      "failover": {
        "title": "自動フェイルオーバー",
        "description": "フェイルオーバーキューとサーキットブレーカー戦略を設定"
      },
      "pricing": {
        "title": "コスト計算",
        "description": "各モデルのトークン料金ルールを管理"
      },
      "data": {
        "title": "データ管理",
        "description": "設定のインポート/エクスポートとバックアップ/復元"
      }
    },
    "language": "言語",
    "languageHint": "切り替えるとすぐにプレビューされ、保存後に永続化されます。",
    "theme": "テーマ",
    "themeHint": "アプリのテーマを選択します。すぐに反映されます。",
    "themeLight": "ライト",
    "themeDark": "ダーク",
    "themeSystem": "システム",
    "importExport": "SQL インポート/エクスポート",
    "importExportHint": "移行や復元用にデータベースの SQL バックアップをインポート/エクスポートします（インポートは CC Switch がエクスポートしたバックアップのみ対応）。",
    "exportConfig": "SQL バックアップをエクスポート",
    "selectConfigFile": "SQL ファイルを選択",
    "noFileSelected": "ファイルが選択されていません。",
    "import": "インポート",
    "importing": "インポート中...",
    "importSuccess": "インポート成功！",
    "importFailed": "インポート失敗",
    "syncLiveFailed": "インポートしましたが、現在のプロバイダーへの同期に失敗しました。手動で再選択してください。",
    "importPartialSuccess": "設定はインポートされましたが、現在のプロバイダーへの同期に失敗しました。",
    "importPartialHint": "ライブ設定を更新するため、もう一度プロバイダーを選択してください。",
    "configExported": "設定をエクスポートしました:",
    "exportFailed": "エクスポートに失敗しました",
    "selectFileFailed": "有効な SQL バックアップファイルを選択してください",
    "configCorrupted": "SQL ファイルが壊れているか形式が無効な可能性があります",
    "backupId": "バックアップ ID",
    "autoReload": "データを更新しました",
    "languageOptionChinese": "中文",
    "languageOptionEnglish": "English",
    "languageOptionJapanese": "日本語",
    "windowBehavior": "ウィンドウ動作",
    "windowBehaviorHint": "最小化動作や Claude プラグイン連携を設定します。",
    "launchOnStartup": "起動時に自動実行",
    "launchOnStartupDescription": "システム起動時に CC Switch を自動起動します",
    "autoLaunchFailed": "自動起動の設定に失敗しました",
    "minimizeToTray": "閉じるときトレイへ最小化",
    "minimizeToTrayDescription": "チェックすると閉じるボタンでトレイに隠し、オフならアプリを終了します。",
    "enableClaudePluginIntegration": "Claude Code 拡張に適用",
    "enableClaudePluginIntegrationDescription": "オンにすると VS Code の Claude Code 拡張のプロバイダーも同期します",
    "skipClaudeOnboarding": "Claude Code の初回確認をスキップ",
    "skipClaudeOnboardingDescription": "オンにすると Claude Code の初回インストール確認をスキップします",
    "configDirectoryOverride": "設定ディレクトリの上書き（詳細）",
    "configDirectoryDescription": "WSL などで Claude Code や Codex を使う場合、ここで設定ディレクトリを WSL 側に合わせるとデータを揃えられます。",
    "appConfigDir": "CC Switch 設定ディレクトリ",
    "appConfigDirDescription": "CC Switch の保存場所をカスタマイズします（クラウド同期フォルダを指定すると設定を同期できます）",
    "browsePlaceholderApp": "例: C:\\\\Users\\\\Administrator\\\\.cc-switch",
    "claudeConfigDir": "Claude Code 設定ディレクトリ",
    "claudeConfigDirDescription": "Claude の設定ディレクトリ（settings.json）を上書きし、claude.json（MCP）も同じ場所に置きます。",
    "codexConfigDir": "Codex 設定ディレクトリ",
    "codexConfigDirDescription": "Codex の設定ディレクトリを上書きします。",
    "geminiConfigDir": "Gemini 設定ディレクトリ",
    "geminiConfigDirDescription": "Gemini の設定ディレクトリ（.env）を上書きします。",
    "browsePlaceholderClaude": "例: /home/<your-username>/.claude",
    "browsePlaceholderCodex": "例: /home/<your-username>/.codex",
    "browsePlaceholderGemini": "例: /home/<your-username>/.gemini",
    "browseDirectory": "ディレクトリを選択",
    "resetDefault": "デフォルトに戻す（保存後に反映）",
    "checkForUpdates": "アップデートを確認",
    "updateTo": "v{{version}} に更新",
    "updating": "更新中...",
    "checking": "確認中...",
    "upToDate": "最新バージョンです",
    "aboutHint": "バージョン情報と更新状況を表示します。",
    "portableMode": "ポータブルモード: 更新は手動ダウンロードが必要です。",
    "updateAvailable": "新しいバージョンがあります: {{version}}",
    "updateFailed": "更新のインストールに失敗しました。ダウンロードページを開こうとしました。",
    "checkUpdateFailed": "更新の確認に失敗しました。時間をおいて再試行してください。",
    "openReleaseNotesFailed": "リリースノートの表示に失敗しました",
    "releaseNotes": "リリースノート",
    "viewReleaseNotes": "このバージョンのリリースノートを見る",
    "viewCurrentReleaseNotes": "現在のバージョンのリリースノートを見る",
    "oneClickInstall": "ワンクリックインストール",
    "oneClickInstallHint": "Claude Code / Codex / Gemini CLI をインストール",
    "localEnvCheck": "ローカル環境チェック",
    "installCommandsCopied": "インストールコマンドをコピーしました",
    "installCommandsCopyFailed": "コピーに失敗しました。手動でコピーしてください。",
    "importFailedError": "設定のインポートに失敗しました: {{message}}",
    "exportFailedError": "設定のエクスポートに失敗しました:",
    "restartRequired": "再起動が必要です",
    "restartRequiredMessage": "CC Switch の設定ディレクトリを変更すると再起動が必要です。今すぐ再起動しますか？",
    "restartNow": "今すぐ再起動",
    "restartLater": "後で再起動",
    "restartFailed": "アプリの再起動に失敗しました。手動で閉じて再度開いてください。",
    "devModeRestartHint": "開発モードでは自動再起動をサポートしていません。手動で再起動してください。",
    "saving": "保存中..."
  },
  "apps": {
    "claude": "Claude Code",
    "codex": "Codex",
    "gemini": "Gemini"
  },
  "console": {
    "providerSwitchReceived": "プロバイダー切り替えイベントを受信:",
    "setupListenerFailed": "プロバイダー切り替えリスナーの設定に失敗:",
    "updateProviderFailed": "プロバイダー更新に失敗:",
    "autoImportFailed": "デフォルト設定の自動インポートに失敗:",
    "openLinkFailed": "リンクを開けませんでした:",
    "getVersionFailed": "バージョン情報の取得に失敗:",
    "loadSettingsFailed": "設定の読み込みに失敗:",
    "getConfigPathFailed": "設定パスの取得に失敗:",
    "getConfigDirFailed": "設定ディレクトリの取得に失敗:",
    "detectPortableFailed": "ポータブルモードの検出に失敗:",
    "saveSettingsFailed": "設定の保存に失敗:",
    "updateFailed": "更新に失敗:",
    "checkUpdateFailed": "更新確認に失敗:",
    "openConfigFolderFailed": "設定フォルダを開けませんでした:",
    "selectConfigDirFailed": "設定ディレクトリの選択に失敗:",
    "getDefaultConfigDirFailed": "デフォルト設定ディレクトリの取得に失敗:",
    "openReleaseNotesFailed": "リリースノートを開けませんでした:"
  },
  "providerForm": {
    "supplierName": "プロバイダー名",
    "supplierNameRequired": "プロバイダー名 *",
    "supplierNamePlaceholder": "例: Anthropic Official",
    "websiteUrl": "Web サイト URL",
    "websiteUrlPlaceholder": "https://example.com（任意）",
    "apiEndpoint": "API エンドポイント",
    "apiEndpointPlaceholder": "https://your-api-endpoint.com",
    "codexApiEndpointPlaceholder": "https://your-api-endpoint.com/v1",
    "manageAndTest": "管理・テスト",
    "configContent": "設定内容",
    "officialNoApiKey": "公式ログインは API Key 不要です。そのまま保存できます",
    "codexOfficialNoApiKey": "公式は API Key 不要です。そのまま保存してください",
    "codexApiKeyAutoFill": "ここに入力すれば auth.json も自動で埋まります",
    "apiKeyAutoFill": "ここに入力すれば下の設定も自動で埋まります",
    "cnOfficialApiKeyHint": "💡 API Key のみ入力すれば OK。エンドポイントはプリセット済みです",
    "aggregatorApiKeyHint": "💡 API Key のみ入力すれば OK。エンドポイントはプリセット済みです",
    "thirdPartyApiKeyHint": "💡 API Key のみ入力すれば OK。エンドポイントはプリセット済みです",
    "customApiKeyHint": "💡 カスタム設定では必要な項目をすべて手動で入力してください",
    "officialHint": "💡 公式プロバイダーはブラウザログインで、API Key は不要です",
    "getApiKey": "API Key を取得",
    "partnerPromotion": {
      "zhipu": "Zhipu GLM は CC Switch の公式パートナーです。リンク経由でチャージすると 10% 割引",
      "packycode": "PackyCode は CC Switch の公式パートナーです。登録後チャージ時に \"cc-switch\" を入力すると 10% オフ",
      "minimax_cn": "MiniMax Coding Plan 特別価格、Starter ¥9.9 から",
      "minimax_en": "MiniMax Coding Plan Black Friday、Starter が月額 $2（80% OFF）",
      "dmxapi": "Claude Code 専用モデル 66% OFF 実施中！"
    },
    "parameterConfig": "パラメーター設定 - {{name}} *",
    "mainModel": "メインモデル（任意）",
    "mainModelPlaceholder": "例: GLM-4.6",
    "fastModel": "高速モデル（任意）",
    "fastModelPlaceholder": "例: GLM-4.5-Air",
    "modelHint": "💡 空欄ならプロバイダーのデフォルトモデルを使用します",
    "apiHint": "💡 Claude API 互換サービスのエンドポイントを入力してください。末尾にスラッシュを付けないでください",
    "codexApiHint": "💡 OpenAI Response 互換のサービスエンドポイントを入力してください",
    "fillSupplierName": "プロバイダー名を入力してください",
    "fillConfigContent": "設定内容を入力してください",
    "fillParameter": "{{label}} を入力してください",
    "fillTemplateValue": "{{label}} を入力してください",
    "endpointRequired": "公式以外は API エンドポイントが必須です",
    "apiKeyRequired": "公式以外は API Key が必須です",
    "configJsonError": "Config JSON の形式が正しくありません。構文を確認してください",
    "authJsonRequired": "auth.json は JSON オブジェクトで入力してください",
    "authJsonError": "auth.json の形式が正しくありません。JSON を確認してください",
    "fillAuthJson": "auth.json の設定を入力してください",
    "fillApiKey": "OPENAI_API_KEY を入力してください",
    "visitWebsite": "{{url}} を開く",
    "anthropicModel": "メインモデル",
    "anthropicSmallFastModel": "高速モデル",
    "anthropicDefaultHaikuModel": "既定 Haiku モデル",
    "anthropicDefaultSonnetModel": "既定 Sonnet モデル",
    "anthropicDefaultOpusModel": "既定 Opus モデル",
    "modelPlaceholder": "",
    "smallModelPlaceholder": "",
    "haikuModelPlaceholder": "",
    "modelHelper": "任意: 既定で使いたい Claude モデルを指定。空欄ならシステム既定を使用します。",
    "categoryOfficial": "公式",
    "categoryCnOfficial": "オープンソース公式",
    "categoryAggregation": "アグリゲーター",
    "categoryThirdParty": "サードパーティ"
  },
  "endpointTest": {
    "title": "API エンドポイント管理",
    "endpoints": "エンドポイント",
    "autoSelect": "自動選択",
    "testSpeed": "テスト",
    "testing": "テスト中",
    "addEndpointPlaceholder": "https://api.example.com",
    "done": "完了",
    "noEndpoints": "エンドポイントがありません",
    "failed": "失敗",
    "enterValidUrl": "有効な URL を入力してください",
    "invalidUrlFormat": "URL 形式が正しくありません",
    "onlyHttps": "HTTP/HTTPS のみサポートします",
    "urlExists": "この URL はすでに存在します",
    "saveFailed": "保存に失敗しました。もう一度お試しください",
    "loadEndpointsFailed": "カスタムエンドポイントの読み込みに失敗:",
    "addEndpointFailed": "カスタムエンドポイントの追加に失敗:",
    "removeEndpointFailed": "カスタムエンドポイントの削除に失敗:",
    "removeFailed": "削除に失敗しました: {{error}}",
    "updateLastUsedFailed": "エンドポイントの最終使用時間の更新に失敗しました",
    "pleaseAddEndpoint": "まずエンドポイントを追加してください",
    "testUnavailable": "速度テストを実行できません",
    "noResult": "結果がありません",
    "testFailed": "速度テストに失敗しました: {{error}}",
    "status": "ステータス: {{code}}"
  },
  "codexConfig": {
    "authJson": "auth.json (JSON) *",
    "authJsonPlaceholder": "{\n  \"OPENAI_API_KEY\": \"sk-your-api-key-here\"\n}",
    "authJsonHint": "Codex の auth.json 設定内容",
    "configToml": "config.toml (TOML)",
    "configTomlHint": "Codex の config.toml 設定内容",
    "writeCommonConfig": "共通設定を書き込む",
    "editCommonConfig": "共通設定を編集",
    "editCommonConfigTitle": "Codex 共通設定スニペットを編集",
    "commonConfigHint": "「共通設定を書き込む」がオンの場合、config.toml の末尾に追記されます",
    "apiUrlLabel": "API リクエスト URL"
  },
  "geminiConfig": {
    "envFile": "環境変数 (.env)",
    "envFileHint": ".env 形式で Gemini の環境変数を設定",
    "configJson": "設定ファイル (config.json)",
    "configJsonHint": "Gemini 拡張パラメーターを JSON 形式で設定（任意）",
    "writeCommonConfig": "共通設定を書き込む",
    "editCommonConfig": "共通設定を編集",
    "editCommonConfigTitle": "Gemini 共通設定スニペットを編集",
    "commonConfigHint": "共通設定スニペットは、この機能をオンにしたすべての Gemini プロバイダーへマージされます"
  },
  "providerPreset": {
    "label": "プロバイダータイプ",
    "custom": "カスタム設定",
    "other": "その他",
    "hint": "プリセットを選んだ後でも、下のフィールドで調整できます。"
  },
  "usage": {
    "title": "利用統計",
    "subtitle": "AI モデルの利用状況とコスト統計を表示",
    "today": "24時間",
    "last7days": "7日間",
    "last30days": "30日間",
    "totalRequests": "総リクエスト数",
    "totalCost": "総コスト",
    "cost": "コスト",
    "perMillion": "(100万あたり)",
    "trends": "利用トレンド",
    "rangeToday": "今日 (時間別)",
    "rangeLast7Days": "過去7日間",
    "rangeLast30Days": "過去30日間",
    "totalTokens": "総トークン数",
    "cacheTokens": "キャッシュトークン",
    "requestLogs": "リクエストログ",
    "providerStats": "プロバイダー統計",
    "modelStats": "モデル統計",
    "time": "時間",
    "provider": "プロバイダー",
    "billingModel": "課金モデル",
    "inputTokens": "入力",
    "outputTokens": "出力",
    "cacheReadTokens": "キャッシュ読取",
    "cacheCreationTokens": "キャッシュ書込",
    "timingInfo": "応答時間/TTFT",
    "status": "ステータス",
    "noData": "データなし",
    "unknownProvider": "不明なプロバイダー",
    "stream": "ストリーム",
    "nonStream": "非ストリーム",
    "totalRecords": "全 {{total}} 件",
    "modelPricing": "モデル料金",
    "loadPricingError": "料金データの読み込みに失敗しました",
    "modelPricingDesc": "各モデルのトークンコストを設定",
    "noPricingData": "料金データがありません。「追加」をクリックしてモデル料金を設定してください。",
    "model": "モデル",
    "displayName": "表示名",
    "inputCost": "入力コスト",
    "outputCost": "出力コスト",
    "cacheReadCost": "キャッシュ読取",
    "cacheWriteCost": "キャッシュ書込",
    "deleteConfirmTitle": "削除の確認",
    "deleteConfirmDesc": "このモデル料金を削除しますか？この操作は元に戻せません。",
    "queryFailed": "照会に失敗しました",
    "refreshUsage": "利用状況を更新",
    "planUsage": "プラン利用状況",
    "invalid": "期限切れ",
    "total": "合計:",
    "used": "使用:",
    "remaining": "残り:",
    "justNow": "たった今",
    "minutesAgo": "{{count}} 分前",
    "hoursAgo": "{{count}} 時間前",
    "daysAgo": "{{count}} 日前",
    "multiplePlans": "{{count}} プラン",
    "expand": "展開",
    "collapse": "折りたたむ",
    "modelIdPlaceholder": "例: claude-3-5-sonnet-20241022",
    "displayNamePlaceholder": "例: Claude 3.5 Sonnet",
    "appType": "アプリ種別",
    "allApps": "すべてのアプリ",
    "statusCode": "ステータスコード",
    "searchProviderPlaceholder": "プロバイダーを検索...",
    "searchModelPlaceholder": "モデルを検索...",
    "timeRange": "期間",
    "input": "Input",
    "output": "Output",
    "cacheWrite": "Write",
    "cacheRead": "Read"
  },
  "usageScript": {
    "title": "利用状況を設定",
    "enableUsageQuery": "利用状況照会を有効にする",
    "presetTemplate": "プリセットテンプレート",
    "requestUrl": "リクエスト URL",
    "requestUrlPlaceholder": "例: https://api.example.com",
    "method": "HTTP メソッド",
    "templateCustom": "カスタム",
    "templateGeneral": "General",
    "templateNewAPI": "NewAPI",
    "credentialsConfig": "認証情報",
    "credentialsHint": "空欄の場合はプロバイダー設定を使用",
    "optional": "オプション",
    "apiKeyPlaceholder": "空欄の場合はプロバイダーの API Key を使用",
    "baseUrlPlaceholder": "空欄の場合はプロバイダーの Base URL を使用",
    "baseUrl": "Base URL",
    "accessToken": "Access Token",
    "accessTokenPlaceholder": "「Security Settings」で生成",
    "userId": "ユーザー ID",
    "userIdPlaceholder": "例: 114514",
    "defaultPlan": "デフォルトプラン",
    "queryFailedMessage": "照会に失敗しました",
    "queryScript": "照会スクリプト (JavaScript)",
    "timeoutSeconds": "タイムアウト（秒）",
    "headers": "ヘッダー",
    "body": "ボディ",
    "timeoutHint": "範囲: 2〜30 秒",
    "timeoutMustBeInteger": "タイムアウトは整数で入力してください（小数は切り捨て）",
    "timeoutCannotBeNegative": "タイムアウトは負の値にできません",
    "autoIntervalMinutes": "自動照会間隔（分、0 で無効）",
    "autoQueryInterval": "自動照会間隔（分）",
    "autoQueryIntervalHint": "0 で無効。推奨 5〜60 分",
    "intervalMustBeInteger": "間隔は整数で入力してください（小数は切り捨て）",
    "intervalCannotBeNegative": "間隔は負の値にできません",
    "intervalAdjusted": "間隔を {{value}} 分に調整しました",
    "scriptHelp": "スクリプトの書き方:",
    "configFormat": "設定の形式:",
    "commentOptional": "任意",
    "commentResponseIsJson": "response は API から返る JSON データです",
    "extractorFormat": "抽出関数の返却形式（すべて任意）:",
    "tips": "💡 ヒント:",
    "testing": "テスト中...",
    "testScript": "スクリプトをテスト",
    "format": "整形",
    "saveConfig": "設定を保存",
    "scriptEmpty": "スクリプト設定は空にできません",
    "mustHaveReturn": "スクリプトには return 文が必要です",
    "testSuccess": "テスト成功！",
    "testFailed": "テストに失敗しました",
    "formatSuccess": "整形に成功しました",
    "formatFailed": "整形に失敗しました",
    "variablesHint": "使用可能な変数: {{apiKey}}, {{baseUrl}} | extractor 関数には API 応答の JSON オブジェクトが渡されます",
    "scriptConfig": "リクエスト設定",
    "extractorCode": "抽出コード",
    "extractorHint": "戻り値のオブジェクトに残り枠の項目を含めてください",
    "fieldIsValid": "• isValid: Boolean。プランが有効かどうか",
    "fieldInvalidMessage": "• invalidMessage: String。無効時の理由（isValid が false のとき表示）",
    "fieldRemaining": "• remaining: Number。残り枠",
    "fieldUnit": "• unit: String。単位（例: \"USD\"）",
    "fieldPlanName": "• planName: String。プラン名",
    "fieldTotal": "• total: Number。総枠",
    "fieldUsed": "• used: Number。使用量",
    "fieldExtra": "• extra: String。自由記述の追加テキスト",
    "tip1": "• 変数 {{apiKey}} と {{baseUrl}} は自動で置換されます",
    "tip2": "• 抽出関数はサンドボックスで実行され、ES2020+ の構文を使えます",
    "tip3": "• 全体を () で囲み、オブジェクトリテラル式にしてください"
  },
  "errors": {
    "usage_query_failed": "利用状況の取得に失敗しました",
    "configLoadFailedTitle": "設定の読み込みに失敗しました",
    "configLoadFailedMessage": "設定ファイルを読み込めません:\n{{path}}\n\nエラー詳細:\n{{detail}}\n\nJSON が正しいか確認するか、同じディレクトリのバックアップファイル（config.json.bak など）から復元してください。\n\nアプリを終了して修正してください。"
  },
  "presetSelector": {
    "title": "設定タイプを選択",
    "custom": "カスタム",
    "customDescription": "手動で設定。完全な構成が必要",
    "officialDescription": "公式ログイン。API Key 不要",
    "presetDescription": "プリセットを使用。API Key だけ入力すれば OK"
  },
  "mcp": {
    "title": "MCP 管理",
    "claudeTitle": "Claude Code MCP 管理",
    "codexTitle": "Codex MCP 管理",
    "geminiTitle": "Gemini MCP 管理",
    "unifiedPanel": {
      "title": "MCP サーバー管理",
      "addServer": "サーバーを追加",
      "editServer": "サーバーを編集",
      "deleteServer": "サーバーを削除",
      "deleteConfirm": "サーバー「{{id}}」を削除しますか？この操作は元に戻せません。",
      "noServers": "まだサーバーがありません",
      "enabledApps": "有効なアプリ",
      "apps": {
        "claude": "Claude",
        "codex": "Codex",
        "gemini": "Gemini"
      }
    },
    "userLevelPath": "ユーザーレベルの MCP パス",
    "serverList": "サーバー一覧",
    "loading": "読み込み中...",
    "empty": "MCP サーバーがありません",
    "emptyDescription": "右上のボタンから最初の MCP サーバーを追加してください",
    "add": "MCP を追加",
    "addServer": "MCP を追加",
    "editServer": "MCP を編集",
    "addClaudeServer": "Claude Code MCP を追加",
    "editClaudeServer": "Claude Code MCP を編集",
    "addCodexServer": "Codex MCP を追加",
    "editCodexServer": "Codex MCP を編集",
    "configPath": "設定パス",
    "serverCount": "MCP サーバー: {{count}} 件",
    "enabledCount": "{{count}} 件が有効",
    "template": {
      "fetch": "クイックテンプレート: mcp-fetch"
    },
    "form": {
      "title": "MCP ID（ユニーク）",
      "titlePlaceholder": "my-mcp-server",
      "name": "表示名",
      "namePlaceholder": "例: @modelcontextprotocol/server-time",
      "enabledApps": "適用するアプリ",
      "noAppsWarning": "少なくとも 1 つ選択してください",
      "description": "説明",
      "descriptionPlaceholder": "任意の説明",
      "tags": "タグ（カンマ区切り）",
      "tagsPlaceholder": "stdio, time, utility",
      "homepage": "ホームページ",
      "homepagePlaceholder": "https://example.com",
      "docs": "ドキュメント",
      "docsPlaceholder": "https://example.com/docs",
      "additionalInfo": "追加情報",
      "jsonConfig": "JSON 全設定",
      "jsonConfigOrPrefix": "JSON 全設定、または",
      "tomlConfigOrPrefix": "TOML 全設定、または",
      "jsonPlaceholder": "{\n  \"type\": \"stdio\",\n  \"command\": \"uvx\",\n  \"args\": [\"mcp-server-fetch\"]\n}",
      "tomlConfig": "TOML 全設定",
      "tomlPlaceholder": "type = \"stdio\"\ncommand = \"uvx\"\nargs = [\"mcp-server-fetch\"]",
      "useWizard": "設定ウィザード",
      "syncOtherSide": "{{target}} にも反映",
      "syncOtherSideHint": "{{target}} に同じ設定を書き込みます。既存の同一 ID は上書きされます。",
      "willOverwriteWarning": "{{target}} の既存設定を上書きします"
    },
    "wizard": {
      "title": "MCP 設定ウィザード",
      "hint": "MCP サーバーを素早く設定し JSON を自動生成します",
      "type": "タイプ",
      "typeStdio": "stdio",
      "typeHttp": "http",
      "typeSse": "sse",
      "command": "コマンド",
      "commandPlaceholder": "npx または uvx",
      "args": "引数",
      "argsPlaceholder": "arg1\narg2",
      "env": "環境変数",
      "envPlaceholder": "KEY1=value1\nKEY2=value2",
      "url": "URL",
      "urlPlaceholder": "https://api.example.com/mcp",
      "urlRequired": "URL を入力してください",
      "headers": "ヘッダー（任意）",
      "headersPlaceholder": "Authorization: Bearer your_token_here\nContent-Type: application/json",
      "preview": "設定プレビュー",
      "apply": "設定を反映"
    },
    "id": "識別子（ユニーク）",
    "type": "タイプ",
    "command": "コマンド",
    "validateCommand": "コマンドを検証",
    "args": "引数",
    "argsPlaceholder": "例: mcp-server-fetch --help",
    "env": "環境変数（1 行に 1 件、KEY=VALUE）",
    "envPlaceholder": "FOO=bar\nHELLO=world",
    "reset": "リセット",
    "msg": {
      "saved": "保存しました",
      "deleted": "削除しました",
      "enabled": "有効化しました",
      "disabled": "無効化しました",
      "templateAdded": "テンプレートを追加しました"
    },
    "error": {
      "idRequired": "識別子を入力してください",
      "idExists": "この識別子は既に存在します。別のものを選んでください。",
      "jsonInvalid": "JSON 形式が無効です",
      "tomlInvalid": "TOML 形式が無効です",
      "commandRequired": "コマンドを入力してください",
      "singleServerObjectRequired": "単一の MCP サーバーオブジェクトを貼り付けてください（トップレベルの mcpServers は不要）",
      "saveFailed": "保存に失敗しました",
      "deleteFailed": "削除に失敗しました"
    },
    "validation": {
      "ok": "コマンドが見つかりました",
      "fail": "コマンドが見つかりません"
    },
    "confirm": {
      "deleteTitle": "MCP サーバーを削除",
      "deleteMessage": "MCP サーバー「{{id}}」を削除してもよろしいですか？この操作は元に戻せません。"
    },
    "presets": {
      "title": "MCP タイプを選択",
      "enable": "有効化",
      "enabled": "有効",
      "installed": "インストール済み",
      "docs": "ドキュメント",
      "requiresEnv": "環境変数が必要",
      "fetch": {
        "name": "mcp-server-fetch",
        "description": "汎用 HTTP リクエストツール。GET/POST などに対応し、API テストや Web データ取得に最適です"
      },
      "time": {
        "name": "@modelcontextprotocol/server-time",
        "description": "現在時刻、タイムゾーン変換、日付計算を提供する時間クエリツール"
      },
      "memory": {
        "name": "@modelcontextprotocol/server-memory",
        "description": "エンティティ・関係・観測を扱うナレッジグラフ型メモリ。会話の重要情報を AI に記憶させます"
      },
      "sequential-thinking": {
        "name": "@modelcontextprotocol/server-sequential-thinking",
        "description": "複雑な問題をステップに分解して深く考えるためのシーケンシャル思考ツール"
      },
      "context7": {
        "name": "@upstash/context7-mcp",
        "description": "最新のライブラリドキュメントとコード例を提供する Context7 ドキュメント検索ツール。キー設定で上限が拡張されます"
      }
    }
  },
  "prompts": {
    "manage": "プロンプト",
    "title": "{{appName}} プロンプト管理",
    "claudeTitle": "Claude プロンプト管理",
    "codexTitle": "Codex プロンプト管理",
    "add": "プロンプトを追加",
    "edit": "プロンプトを編集",
    "addTitle": "{{appName}} プロンプトを追加",
    "editTitle": "{{appName}} プロンプトを編集",
    "import": "既存をインポート",
    "count": "{{count}} 件のプロンプト",
    "enabled": "有効",
    "enable": "有効化",
    "enabledName": "有効: {{name}}",
    "noneEnabled": "有効なプロンプトがありません",
    "currentFile": "現在の {{filename}} の内容",
    "empty": "まだプロンプトがありません",
    "emptyDescription": "上のボタンからプロンプトを追加またはインポートしてください",
    "loading": "読み込み中...",
    "name": "名前",
    "namePlaceholder": "例: デフォルトプロジェクトプロンプト",
    "description": "説明",
    "descriptionPlaceholder": "任意の説明",
    "content": "内容",
    "contentPlaceholder": "# {{filename}}\n\nここにプロンプト内容を入力...",
    "loadFailed": "プロンプトの読み込みに失敗しました",
    "saveSuccess": "保存しました",
    "saveFailed": "保存に失敗しました",
    "deleteSuccess": "削除しました",
    "deleteFailed": "削除に失敗しました",
    "enableSuccess": "有効化しました",
    "enableFailed": "有効化に失敗しました",
    "disableSuccess": "無効化しました",
    "disableFailed": "無効化に失敗しました",
    "importSuccess": "インポートしました",
    "importFailed": "インポートに失敗しました",
    "confirm": {
      "deleteTitle": "削除の確認",
      "deleteMessage": "プロンプト「{{name}}」を削除してもよろしいですか？"
    }
  },
  "env": {
    "warning": {
      "title": "競合する環境変数を検出しました",
      "description": "設定を上書きする可能性のある環境変数を {{count}} 件見つけました"
    },
    "actions": {
      "expand": "詳細を表示",
      "collapse": "折りたたむ",
      "selectAll": "すべて選択",
      "clearSelection": "選択を解除",
      "deleteSelected": "選択 {{count}} 件を削除",
      "deleting": "削除中..."
    },
    "field": {
      "value": "値",
      "source": "ソース"
    },
    "source": {
      "userRegistry": "ユーザー環境変数（レジストリ）",
      "systemRegistry": "システム環境変数（レジストリ）",
      "systemEnv": "システム環境変数"
    },
    "delete": {
      "success": "環境変数を削除しました",
      "error": "環境変数の削除に失敗しました"
    },
    "backup": {
      "location": "バックアップ場所: {{path}}"
    },
    "confirm": {
      "title": "環境変数を削除しますか？",
      "message": "{{count}} 件の環境変数を削除してもよろしいですか？",
      "backupNotice": "削除前に自動バックアップを作成します。後で復元できます。再起動またはターミナル再起動後に反映されます。",
      "confirm": "削除を確認"
    },
    "error": {
      "noSelection": "削除する環境変数を選択してください"
    }
  },
  "skills": {
    "manage": "Skills",
    "title": "Claude スキル管理",
    "description": "人気リポジトリから Claude Skills を探してインストールし、Claude Code/Codex を拡張",
    "refresh": "更新",
    "refreshing": "更新中...",
    "repoManager": "リポジトリ管理",
    "count": "{{count}} 個のスキル",
    "empty": "スキルがありません",
    "emptyDescription": "スキルリポジトリを追加して探索してください",
    "addRepo": "スキルリポジトリを追加",
    "loading": "読み込み中...",
    "installed": "インストール済み",
    "install": "インストール",
    "installing": "インストール中...",
    "uninstall": "アンインストール",
    "uninstalling": "アンインストール中...",
    "view": "表示",
    "noDescription": "説明なし",
    "loadFailed": "読み込みに失敗しました",
    "installSuccess": "スキル {{name}} をインストールしました",
    "installFailed": "インストールに失敗しました",
    "uninstallSuccess": "スキル {{name}} をアンインストールしました",
    "uninstallFailed": "アンインストールに失敗しました",
    "error": {
      "skillNotFound": "スキルが見つかりません: {{directory}}",
      "missingRepoInfo": "リポジトリ情報（owner または name）が不足しています",
      "downloadTimeout": "リポジトリ {{owner}}/{{name}} のダウンロードがタイムアウトしました（{{timeout}} 秒）",
      "downloadTimeoutHint": "ネットワークを確認するか、時間をおいて再試行してください",
      "skillPathNotFound": "リポジトリ {{owner}}/{{name}} にスキルパス '{{path}}' がありません",
      "skillDirNotFound": "スキルディレクトリが見つかりません: {{path}}",
      "emptyArchive": "ダウンロードしたアーカイブが空です",
      "downloadFailed": "ダウンロードに失敗しました: HTTP {{status}}",
      "allBranchesFailed": "すべてのブランチで失敗しました。試行: {{branches}}",
      "httpError": "HTTP エラー {{status}}",
      "http403": "GitHub へのアクセスが制限されています（レート制限の可能性）",
      "http404": "リポジトリまたはブランチが見つかりません。URL を確認してください",
      "http429": "リクエストが多すぎます。時間をおいて再試行してください",
      "parseMetadataFailed": "スキルメタデータの解析に失敗しました",
      "getHomeDirFailed": "ユーザーのホームディレクトリを取得できません",
      "networkError": "ネットワークエラー",
      "fsError": "ファイルシステムエラー",
      "unknownError": "不明なエラー",
      "suggestion": {
        "checkNetwork": "ネットワーク接続を確認してください",
        "checkProxy": "HTTP プロキシの設定を検討してください",
        "retryLater": "時間をおいて再試行してください",
        "checkRepoUrl": "リポジトリ URL とブランチ名を確認してください",
        "checkDiskSpace": "ディスク容量を確認してください",
        "checkPermission": "ディレクトリの権限を確認してください"
      }
    },
    "repo": {
      "title": "スキルリポジトリを管理",
      "description": "GitHub のスキルリポジトリソースを追加または削除します",
      "url": "リポジトリ URL",
      "urlPlaceholder": "owner/name または https://github.com/owner/name",
      "branch": "ブランチ",
      "branchPlaceholder": "main",
      "path": "スキルパス",
      "pathPlaceholder": "skills（任意。空欄はルート）",
      "add": "リポジトリを追加",
      "list": "追加済みリポジトリ",
      "empty": "リポジトリがありません",
      "invalidUrl": "リポジトリ URL の形式が無効です",
      "addSuccess": "リポジトリ {{owner}}/{{name}} を追加しました。検出スキル: {{count}} 件",
      "addFailed": "追加に失敗しました",
      "removeSuccess": "リポジトリ {{owner}}/{{name}} を削除しました",
      "removeFailed": "削除に失敗しました",
      "skillCount": "{{count}} 件のスキルを検出"
    },
    "search": "スキルを検索",
    "searchPlaceholder": "スキル名または説明で検索...",
    "filter": {
      "placeholder": "状態で絞り込み",
      "all": "すべて",
      "installed": "インストール済み",
      "uninstalled": "未インストール"
    },
    "noResults": "一致するスキルが見つかりませんでした"
  },
  "deeplink": {
    "confirmImport": "プロバイダーのインポートを確認",
    "confirmImportDescription": "次の設定をディープリンクから CC Switch へインポートします",
    "importPrompt": "プロンプトをインポート",
    "importPromptDescription": "このシステムプロンプトをインポートするか確認してください",
    "importMcp": "MCP サーバーをインポート",
    "importMcpDescription": "これらの MCP サーバーをインポートするか確認してください",
    "importSkill": "スキルリポジトリを追加",
    "importSkillDescription": "このスキルリポジトリを追加するか確認してください",
    "promptImportSuccess": "プロンプトをインポートしました",
    "promptImportSuccessDescription": "インポートされたプロンプト: {{name}}",
    "mcpImportSuccess": "MCP サーバーをインポートしました",
    "mcpImportSuccessDescription": "{{count}} 件のサーバーをインポートしました",
    "mcpPartialSuccess": "一部のみインポート成功",
    "mcpPartialSuccessDescription": "成功: {{success}}、失敗: {{failed}}",
    "skillImportSuccess": "スキルリポジトリを追加しました",
    "skillImportSuccessDescription": "追加したリポジトリ: {{repo}}",
    "app": "アプリ種別",
    "providerName": "プロバイダー名",
    "homepage": "ホームページ",
    "endpoint": "API エンドポイント",
    "apiKey": "API Key",
    "icon": "アイコン",
    "model": "モデル",
    "haikuModel": "Haiku モデル",
    "sonnetModel": "Sonnet モデル",
    "opusModel": "Opus モデル",
    "multiModel": "マルチモーダルモデル",
    "notes": "メモ",
    "import": "インポート",
    "importing": "インポート中...",
    "warning": "インポート前に内容を確認してください。後から一覧で編集・削除できます。",
    "parseError": "ディープリンクの解析に失敗しました",
    "importSuccess": "インポート成功",
    "importSuccessDescription": "プロバイダー「{{name}}」をインポートしました",
    "importError": "インポートに失敗しました",
    "configSource": "設定ソース",
    "configEmbedded": "埋め込み設定",
    "configRemote": "リモート設定",
    "configDetails": "設定の詳細",
    "configUrl": "設定ファイル URL",
    "configMergeError": "設定ファイルのマージに失敗しました",
    "mcp": {
      "title": "MCP サーバーを一括インポート",
      "targetApps": "ターゲットアプリ",
      "serverCount": "MCP サーバー（{{count}} 件）",
      "enabledWarning": "インポート後、指定したすべてのアプリに即座に書き込まれます"
    },
    "prompt": {
      "title": "システムプロンプトをインポート",
      "app": "アプリ",
      "name": "名前",
      "description": "説明",
      "contentPreview": "内容プレビュー",
      "enabledWarning": "インポート後すぐにこのプロンプトが有効になり、他は無効になります"
    },
    "skill": {
      "title": "Claude スキルリポジトリを追加",
      "repo": "GitHub リポジトリ",
      "directory": "対象ディレクトリ",
      "branch": "ブランチ",
      "skillsPath": "スキルパス",
      "hint": "この操作でスキルリポジトリが一覧に追加されます。",
      "hintDetail": "追加後、スキル管理ページから個別のスキルをインストールできます。"
    }
  },
  "iconPicker": {
    "search": "アイコンを検索",
    "searchPlaceholder": "アイコン名を入力...",
    "noResults": "一致するアイコンが見つかりません",
    "category": {
      "aiProvider": "AI プロバイダー",
      "cloud": "クラウドプラットフォーム",
      "tool": "開発ツール",
      "other": "その他"
    }
  },
  "providerIcon": {
    "label": "アイコン",
    "colorLabel": "アイコンカラー",
    "selectIcon": "アイコンを選択",
    "preview": "プレビュー",
    "clickToChange": "クリックでアイコンを変更",
    "clickToSelect": "クリックでアイコンを選択"
  },
  "migration": {
    "success": "設定の移行が完了しました"
  },
  "agents": {
    "title": "エージェント"
  },
  "health": {
    "operational": "正常",
    "degraded": "低下",
    "failed": "失敗",
    "circuitOpen": "サーキットオープン",
    "consecutiveFailures": "{{count}} 回連続失敗"
  },
  "proxy": {
    "panel": {
      "serviceAddress": "サービスアドレス",
      "addressCopied": "アドレスをコピーしました",
      "currentProvider": "現在のプロバイダー:",
      "waitingFirstRequest": "現在のプロバイダー: 最初のリクエスト待ち...",
      "stoppedTitle": "プロキシサービス停止中",
      "stoppedDescription": "右上のトグルでサービスを開始できます",
      "openSettings": "プロキシサービスを設定",
      "stats": {
        "activeConnections": "アクティブ接続",
        "totalRequests": "総リクエスト数",
        "successRate": "成功率",
        "uptime": "稼働時間"
      }
    },
    "settings": {
      "toast": {
        "saved": "プロキシ設定を保存しました",
        "saveFailed": "保存に失敗しました: {{error}}"
      }
    },
    "switchFailed": "切り替えに失敗しました: {{error}}",
    "failoverQueue": {
      "title": "フェイルオーバーキュー",
      "description": "各アプリのプロバイダーのフェイルオーバー順序を管理します",
      "info": "現在アクティブなプロバイダーが常に優先されます。リクエストが失敗すると、システムはキュー順に他のプロバイダーを試行します。",
      "selectProvider": "キューに追加するプロバイダーを選択",
      "noAvailableProviders": "追加できるプロバイダーがありません",
      "empty": "フェイルオーバーキューが空です。自動フェイルオーバーを有効にするにはプロバイダーを追加してください。",
      "dragHint": "ドラッグでフェイルオーバー順序を調整します。番号が小さいほど優先度が高くなります。",
      "toggleEnabled": "有効/無効",
      "addSuccess": "フェイルオーバーキューに追加しました",
      "addFailed": "追加に失敗しました",
      "removeSuccess": "フェイルオーバーキューから削除しました",
      "removeFailed": "削除に失敗しました",
      "reorderSuccess": "キュー順序を更新しました",
      "reorderFailed": "順序の更新に失敗しました",
      "toggleFailed": "状態の更新に失敗しました"
    },
    "autoFailover": {
      "info": "フェイルオーバーキューに複数のプロバイダーが設定されている場合、リクエストが失敗すると優先度順に試行します。プロバイダーが連続失敗のしきい値に達すると、サーキットブレーカーが開き、一時的にスキップされます。",
      "configSaved": "自動フェイルオーバー設定を保存しました",
      "configSaveFailed": "保存に失敗しました",
      "retrySettings": "リトライとタイムアウト設定",
      "failureThreshold": "失敗しきい値",
      "failureThresholdHint": "この回数連続で失敗するとサーキットブレーカーが開きます（推奨: 3-10）",
      "timeout": "回復待ち時間（秒）",
      "timeoutHint": "サーキットが開いた後、回復を試みるまでの待ち時間（推奨: 30-120）",
      "circuitBreakerSettings": "サーキットブレーカー詳細設定",
      "successThreshold": "回復成功しきい値",
      "successThresholdHint": "半開状態でこの回数成功するとサーキットブレーカーが閉じます",
      "errorRate": "エラー率しきい値 (%)",
      "errorRateHint": "この値を超えるとサーキットブレーカーが開きます",
      "minRequests": "最小リクエスト数",
      "minRequestsHint": "エラー率を計算する前の最小リクエスト数",
      "explanationTitle": "仕組み",
      "failureThresholdLabel": "失敗しきい値",
      "failureThresholdExplain": "この回数連続で失敗すると、サーキットブレーカーが開き、プロバイダーは一時的に利用不可になります",
      "timeoutLabel": "回復待ち時間",
      "timeoutExplain": "サーキットが開いた後、半開状態を試みるまでの待ち時間",
      "successThresholdLabel": "回復成功しきい値",
      "successThresholdExplain": "半開状態でこの回数成功するとサーキットブレーカーが閉じ、プロバイダーが再び利用可能になります",
      "errorRateLabel": "エラー率しきい値",
      "errorRateExplain": "失敗しきい値に達していなくても、エラー率がこの値を超えるとサーキットブレーカーが開きます"
    }
  },
  "streamCheck": {
    "configSaved": "ヘルスチェック設定を保存しました",
    "configSaveFailed": "保存に失敗しました",
    "testModels": "テストモデル",
    "claudeModel": "Claude モデル",
    "codexModel": "Codex モデル",
    "geminiModel": "Gemini モデル",
    "checkParams": "チェックパラメーター",
    "timeout": "タイムアウト（秒）",
    "maxRetries": "最大リトライ回数",
    "degradedThreshold": "劣化しきい値（ミリ秒）"
  }
}
</file>

<file path="src/i18n/locales/en.json">
{
  "app": {
    "title": "CC Switch",
    "description": "All-in-One Assistant for Claude Code, Codex & Gemini CLI"
  },
  "common": {
    "add": "Add",
    "edit": "Edit",
    "delete": "Delete",
    "save": "Save",
    "saving": "Saving...",
    "cancel": "Cancel",
    "confirm": "Confirm",
    "close": "Close",
    "done": "Done",
    "settings": "Settings",
    "about": "About",
    "version": "Version",
    "loading": "Loading...",
    "notInstalled": "Not installed",
    "success": "Success",
    "error": "Error",
    "unknown": "Unknown",
    "enterValidValue": "Please enter a valid value",
    "clear": "Clear",
    "toggleTheme": "Toggle theme",
    "format": "Format",
    "formatSuccess": "Formatted successfully",
    "formatError": "Format failed: {{error}}",
    "copy": "Copy",
    "view": "View",
    "back": "Back",
    "refresh": "Refresh",
    "refreshing": "Refreshing...",
    "all": "All",
    "search": "Search",
    "reset": "Reset",
    "actions": "Actions",
    "deleting": "Deleting..."
  },
  "apiKeyInput": {
    "placeholder": "Enter API Key",
    "show": "Show API Key",
    "hide": "Hide API Key"
  },
  "jsonEditor": {
    "mustBeObject": "Configuration must be a JSON object, not an array or other type",
    "invalidJson": "Invalid JSON format"
  },
  "claudeConfig": {
    "configLabel": "Claude Code settings.json (JSON) *",
    "writeCommonConfig": "Write Common Config",
    "editCommonConfig": "Edit Common Config",
    "editCommonConfigTitle": "Edit Common Config Snippet",
    "commonConfigHint": "This snippet will be merged into settings.json when 'Write Common Config' is checked",
    "fullSettingsHint": "Full Claude Code settings.json content"
  },
  "header": {
    "viewOnGithub": "View on GitHub",
    "toggleDarkMode": "Switch to Dark Mode",
    "toggleLightMode": "Switch to Light Mode",
    "addProvider": "Add Provider",
    "switchToChinese": "Switch to Chinese",
    "switchToEnglish": "Switch to English",
    "enterEditMode": "Enter Edit Mode",
    "exitEditMode": "Exit Edit Mode"
  },
  "provider": {
    "noProviders": "No providers added yet",
    "noProvidersDescription": "Click the \"Add Provider\" button in the top right to configure your first API provider",
    "currentlyUsing": "Currently Using",
    "enable": "Enable",
    "inUse": "In Use",
    "editProvider": "Edit Provider",
    "editProviderHint": "Configuration will be applied to the current provider immediately after update.",
    "deleteProvider": "Delete Provider",
    "addNewProvider": "Add New Provider",
    "addClaudeProvider": "Add Claude Code Provider",
    "addCodexProvider": "Add Codex Provider",
    "addGeminiProvider": "Add Gemini Provider",
    "addProviderHint": "Fill in the information to quickly switch providers in the list.",
    "editClaudeProvider": "Edit Claude Code Provider",
    "editCodexProvider": "Edit Codex Provider",
    "configError": "Configuration Error",
    "notConfigured": "Not configured for official website",
    "applyToClaudePlugin": "Apply to Claude plugin",
    "removeFromClaudePlugin": "Remove from Claude plugin",
    "dragToReorder": "Drag to reorder",
    "dragHandle": "Drag to reorder",
    "searchPlaceholder": "Search name, notes, or URL...",
    "searchAriaLabel": "Search providers",
    "searchScopeHint": "Matches provider name, notes, and URL.",
    "searchCloseHint": "Press Esc to close",
    "searchCloseAriaLabel": "Close provider search",
    "noSearchResults": "No providers match your search.",
    "duplicate": "Duplicate",
    "sortUpdateFailed": "Failed to update sort order",
    "configureUsage": "Configure usage query",
    "name": "Provider Name",
    "namePlaceholder": "e.g., Claude Official",
    "websiteUrl": "Website URL",
    "notes": "Notes",
    "notesPlaceholder": "e.g., Company dedicated account",
    "configJson": "Config JSON",
    "writeCommonConfig": "Write common config",
    "editCommonConfigButton": "Edit common config",
    "configJsonHint": "Please fill in complete Claude Code configuration",
    "editCommonConfigTitle": "Edit common config snippet",
    "editCommonConfigHint": "Common config snippet will be merged into all providers that enable it",
    "addProvider": "Add Provider",
    "sortUpdated": "Sort order updated",
    "usageSaved": "Usage query configuration saved",
    "usageSaveFailed": "Failed to save usage query configuration",
    "geminiConfig": "Gemini Configuration",
    "geminiConfigHint": "Use .env format to configure Gemini",
    "form": {
      "gemini": {
        "model": "Model",
        "oauthTitle": "OAuth Authentication Mode",
        "oauthHint": "Google official uses OAuth personal authentication, no need to fill in API Key. The browser will automatically open for login on first use.",
        "apiKeyPlaceholder": "Enter Gemini API Key"
      }
    }
  },
  "notifications": {
    "providerAdded": "Provider added",
    "providerSaved": "Provider configuration saved",
    "providerDeleted": "Provider deleted successfully",
    "switchSuccess": "Switch successful!",
    "switchFailedTitle": "Switch failed",
    "switchFailed": "Switch failed: {{error}}",
    "autoImported": "Default provider created from existing configuration",
    "addFailed": "Failed to add provider: {{error}}",
    "saveFailed": "Save failed: {{error}}",
    "saveFailedGeneric": "Save failed, please try again",
    "appliedToClaudePlugin": "Applied to Claude plugin",
    "removedFromClaudePlugin": "Removed from Claude plugin",
    "syncClaudePluginFailed": "Sync Claude plugin failed",
    "skipClaudeOnboardingFailed": "Failed to skip Claude Code first-run confirmation",
    "clearClaudeOnboardingSkipFailed": "Failed to restore Claude Code first-run confirmation",
    "updateSuccess": "Provider updated successfully",
    "updateFailed": "Failed to update provider: {{error}}",
    "deleteSuccess": "Provider deleted",
    "deleteFailed": "Failed to delete provider: {{error}}",
    "settingsSaved": "Settings saved",
    "settingsSaveFailed": "Failed to save settings: {{error}}"
  },
  "confirm": {
    "deleteProvider": "Delete Provider",
    "deleteProviderMessage": "Are you sure you want to delete provider \"{{name}}\"? This action cannot be undone."
  },
  "settings": {
    "title": "Settings",
    "general": "General",
    "tabGeneral": "General",
    "tabAdvanced": "Advanced",
    "advanced": {
      "configDir": {
        "title": "Configuration Directory",
        "description": "Manage storage paths for Claude, Codex and Gemini configurations"
      },
      "proxy": {
        "title": "Local Proxy",
        "description": "Control proxy service toggle, view status and port info",
        "running": "Running",
        "stopped": "Stopped"
      },
      "modelTest": {
        "title": "Model Test Config",
        "description": "Configure default models and prompts for model testing"
      },
      "failover": {
        "title": "Auto Failover",
        "description": "Configure failover queue and circuit breaker strategy"
      },
      "pricing": {
        "title": "Cost Pricing",
        "description": "Manage token pricing rules for each model"
      },
      "data": {
        "title": "Data Management",
        "description": "Import/export configurations and backup/restore"
      }
    },
    "language": "Language",
    "languageHint": "Preview interface language immediately after switching, takes effect permanently after saving.",
    "theme": "Theme",
    "themeHint": "Choose the appearance theme for the app, takes effect immediately.",
    "themeLight": "Light",
    "themeDark": "Dark",
    "themeSystem": "System",
    "importExport": "SQL Import/Export",
    "importExportHint": "Import or export database SQL backups for migration or restore (import supports only backups exported by CC Switch).",
    "exportConfig": "Export SQL Backup",
    "selectConfigFile": "Select SQL File",
    "noFileSelected": "No configuration file selected.",
    "import": "Import",
    "importing": "Importing...",
    "importSuccess": "Import Successful!",
    "importFailed": "Import Failed",
    "syncLiveFailed": "Imported, but failed to sync to the current provider. Please reselect the provider manually.",
    "importPartialSuccess": "Config imported, but failed to sync to the current provider.",
    "importPartialHint": "Please manually reselect the provider to refresh the live configuration.",
    "configExported": "Config exported to:",
    "exportFailed": "Export failed",
    "selectFileFailed": "Please choose a valid SQL backup file",
    "configCorrupted": "SQL file may be corrupted or invalid",
    "backupId": "Backup ID",
    "autoReload": "Data refreshed",
    "languageOptionChinese": "中文",
    "languageOptionEnglish": "English",
    "languageOptionJapanese": "日本語",
    "windowBehavior": "Window Behavior",
    "windowBehaviorHint": "Configure window minimize and Claude plugin integration policies.",
    "launchOnStartup": "Launch on Startup",
    "launchOnStartupDescription": "Automatically run CC Switch when system starts",
    "autoLaunchFailed": "Failed to set auto-launch",
    "minimizeToTray": "Minimize to tray on close",
    "minimizeToTrayDescription": "When checked, clicking the close button will hide to system tray, otherwise the app will exit directly.",
    "enableClaudePluginIntegration": "Apply to Claude Code extension",
    "enableClaudePluginIntegrationDescription": "When enabled, the VS Code Claude Code extension provider will switch with this app",
    "skipClaudeOnboarding": "Skip Claude Code first-run confirmation",
    "skipClaudeOnboardingDescription": "When enabled, Claude Code will skip the first-run confirmation",
    "configDirectoryOverride": "Configuration Directory Override (Advanced)",
    "configDirectoryDescription": "When using Claude Code or Codex in environments like WSL, you can manually specify the configuration directory to the one in WSL to keep provider data consistent with the main environment.",
    "appConfigDir": "CC Switch Configuration Directory",
    "appConfigDirDescription": "Customize the storage location for CC Switch configuration (point to cloud sync folder to enable config sync)",
    "browsePlaceholderApp": "e.g., C:\\Users\\Administrator\\.cc-switch",
    "claudeConfigDir": "Claude Code Configuration Directory",
    "claudeConfigDirDescription": "Override Claude configuration directory (settings.json) and keep claude.json (MCP) alongside it.",
    "codexConfigDir": "Codex Configuration Directory",
    "codexConfigDirDescription": "Override Codex configuration directory.",
    "geminiConfigDir": "Gemini Configuration Directory",
    "geminiConfigDirDescription": "Override Gemini configuration directory (.env).",
    "browsePlaceholderClaude": "e.g., /home/<your-username>/.claude",
    "browsePlaceholderCodex": "e.g., /home/<your-username>/.codex",
    "browsePlaceholderGemini": "e.g., /home/<your-username>/.gemini",
    "browseDirectory": "Browse Directory",
    "resetDefault": "Reset to default directory (takes effect after saving)",
    "checkForUpdates": "Check for Updates",
    "updateTo": "Update to v{{version}}",
    "updating": "Updating...",
    "checking": "Checking...",
    "upToDate": "Up to Date",
    "aboutHint": "View version information and update status.",
    "portableMode": "Portable mode: updates require manual download.",
    "updateAvailable": "New version available: {{version}}",
    "updateFailed": "Update installation failed, attempted to open download page.",
    "checkUpdateFailed": "Failed to check for updates, please try again later.",
    "openReleaseNotesFailed": "Failed to open release notes",
    "releaseNotes": "Release Notes",
    "viewReleaseNotes": "View release notes for this version",
    "viewCurrentReleaseNotes": "View current version release notes",
    "oneClickInstall": "One-click Install",
    "oneClickInstallHint": "Install Claude Code / Codex / Gemini CLI",
    "localEnvCheck": "Local environment check",
    "installCommandsCopied": "Install commands copied",
    "installCommandsCopyFailed": "Copy failed, please copy manually.",
    "importFailedError": "Import config failed: {{message}}",
    "exportFailedError": "Export config failed:",
    "restartRequired": "Restart Required",
    "restartRequiredMessage": "Modifying the CC Switch configuration directory requires restarting the application to take effect. Restart now?",
    "restartNow": "Restart Now",
    "restartLater": "Restart Later",
    "restartFailed": "Application restart failed, please manually close and reopen.",
    "devModeRestartHint": "Dev Mode: Automatic restart not supported, please manually restart the application.",
    "saving": "Saving..."
  },
  "apps": {
    "claude": "Claude Code",
    "codex": "Codex",
    "gemini": "Gemini"
  },
  "console": {
    "providerSwitchReceived": "Received provider switch event:",
    "setupListenerFailed": "Failed to setup provider switch listener:",
    "updateProviderFailed": "Update provider failed:",
    "autoImportFailed": "Auto import default configuration failed:",
    "openLinkFailed": "Failed to open link:",
    "getVersionFailed": "Failed to get version info:",
    "loadSettingsFailed": "Failed to load settings:",
    "getConfigPathFailed": "Failed to get config path:",
    "getConfigDirFailed": "Failed to get config directory:",
    "detectPortableFailed": "Failed to detect portable mode:",
    "saveSettingsFailed": "Failed to save settings:",
    "updateFailed": "Update failed:",
    "checkUpdateFailed": "Check for updates failed:",
    "openConfigFolderFailed": "Failed to open config folder:",
    "selectConfigDirFailed": "Failed to select config directory:",
    "getDefaultConfigDirFailed": "Failed to get default config directory:",
    "openReleaseNotesFailed": "Failed to open release notes:"
  },
  "providerForm": {
    "supplierName": "Provider Name",
    "supplierNameRequired": "Provider Name *",
    "supplierNamePlaceholder": "e.g., Anthropic Official",
    "websiteUrl": "Website URL",
    "websiteUrlPlaceholder": "https://example.com (optional)",
    "apiEndpoint": "API Endpoint",
    "apiEndpointPlaceholder": "https://your-api-endpoint.com",
    "codexApiEndpointPlaceholder": "https://your-api-endpoint.com/v1",
    "manageAndTest": "Manage & Test",
    "configContent": "Config Content",
    "officialNoApiKey": "Official login does not require API Key, save directly",
    "codexOfficialNoApiKey": "Official does not require API Key, save directly",
    "codexApiKeyAutoFill": "Just fill in here, auth.json below will be auto-filled",
    "apiKeyAutoFill": "Just fill in here, config below will be auto-filled",
    "cnOfficialApiKeyHint": "💡 Only need to fill in API Key, endpoint is preset",
    "aggregatorApiKeyHint": "💡 Only need to fill in API Key, endpoint is preset",
    "thirdPartyApiKeyHint": "💡 Only need to fill in API Key, endpoint is preset",
    "customApiKeyHint": "💡 Custom configuration requires manually filling all necessary fields",
    "officialHint": "💡 Official provider uses browser login, no API Key needed",
    "getApiKey": "Get API Key",
    "partnerPromotion": {
      "zhipu": "Zhipu GLM is an official partner of CC Switch. Use this link to top up and get a 10% discount",
      "packycode": "PackyCode is an official partner of CC Switch. Register using this link and enter \"cc-switch\" promo code during recharge to get 10% off",
      "minimax_cn": "MiniMax Coding Plan Special Offer, Starter from ¥9.9",
      "minimax_en": "MiniMax Coding Plan Black Friday, Starter is now $2/mo (80% OFF!)",
      "dmxapi": "Claude Code exclusive model 66% OFF now!"
    },
    "parameterConfig": "Parameter Config - {{name}} *",
    "mainModel": "Main Model (optional)",
    "mainModelPlaceholder": "e.g., GLM-4.6",
    "fastModel": "Fast Model (optional)",
    "fastModelPlaceholder": "e.g., GLM-4.5-Air",
    "modelHint": "💡 Leave blank to use provider's default model",
    "apiHint": "💡 Fill in Claude API compatible service endpoint, avoid trailing slash",
    "codexApiHint": "💡 Fill in service endpoint compatible with OpenAI Response format",
    "fillSupplierName": "Please fill in provider name",
    "fillConfigContent": "Please fill in configuration content",
    "fillParameter": "Please fill in {{label}}",
    "fillTemplateValue": "Please fill in {{label}}",
    "endpointRequired": "API endpoint is required for non-official providers",
    "apiKeyRequired": "API Key is required for non-official providers",
    "configJsonError": "Config JSON format error, please check syntax",
    "authJsonRequired": "auth.json must be a JSON object",
    "authJsonError": "auth.json format error, please check JSON syntax",
    "fillAuthJson": "Please fill in auth.json configuration",
    "fillApiKey": "Please fill in OPENAI_API_KEY",
    "visitWebsite": "Visit {{url}}",
    "anthropicModel": "Main Model",
    "anthropicSmallFastModel": "Fast Model",
    "anthropicDefaultHaikuModel": "Default Haiku Model",
    "anthropicDefaultSonnetModel": "Default Sonnet Model",
    "anthropicDefaultOpusModel": "Default Opus Model",
    "modelPlaceholder": "",
    "smallModelPlaceholder": "",
    "haikuModelPlaceholder": "",
    "modelHelper": "Optional: Specify default Claude model to use, leave blank to use system default.",
    "categoryOfficial": "Official",
    "categoryCnOfficial": "Opensource Official",
    "categoryAggregation": "Aggregation",
    "categoryThirdParty": "Third Party"
  },
  "endpointTest": {
    "title": "API Endpoint Management",
    "endpoints": "endpoints",
    "autoSelect": "Auto Select",
    "testSpeed": "Test",
    "testing": "Testing",
    "addEndpointPlaceholder": "https://api.example.com",
    "done": "Done",
    "noEndpoints": "No endpoints",
    "failed": "Failed",
    "enterValidUrl": "Please enter a valid URL",
    "invalidUrlFormat": "Invalid URL format",
    "onlyHttps": "Only HTTP/HTTPS supported",
    "urlExists": "This URL already exists",
    "saveFailed": "Save failed, please try again",
    "loadEndpointsFailed": "Failed to load custom endpoints:",
    "addEndpointFailed": "Failed to add custom endpoint:",
    "removeEndpointFailed": "Failed to remove custom endpoint:",
    "removeFailed": "Remove failed: {{error}}",
    "updateLastUsedFailed": "Failed to update endpoint last used time",
    "pleaseAddEndpoint": "Please add an endpoint first",
    "testUnavailable": "Speed test unavailable",
    "noResult": "No result returned",
    "testFailed": "Speed test failed: {{error}}",
    "status": "Status: {{code}}"
  },
  "codexConfig": {
    "authJson": "auth.json (JSON) *",
    "authJsonPlaceholder": "{\n  \"OPENAI_API_KEY\": \"sk-your-api-key-here\"\n}",
    "authJsonHint": "Codex auth.json configuration content",
    "configToml": "config.toml (TOML)",
    "configTomlHint": "Codex config.toml configuration content",
    "writeCommonConfig": "Write Common Config",
    "editCommonConfig": "Edit Common Config",
    "editCommonConfigTitle": "Edit Codex Common Config Snippet",
    "commonConfigHint": "This snippet will be appended to the end of config.toml when 'Write Common Config' is checked",
    "apiUrlLabel": "API Request URL"
  },
  "geminiConfig": {
    "envFile": "Environment Variables (.env)",
    "envFileHint": "Configure Gemini environment variables in .env format",
    "configJson": "Configuration File (config.json)",
    "configJsonHint": "Configure Gemini extended parameters in JSON format (optional)",
    "writeCommonConfig": "Write Common Config",
    "editCommonConfig": "Edit Common Config",
    "editCommonConfigTitle": "Edit Gemini Common Config Snippet",
    "commonConfigHint": "Common config snippet will be merged into all Gemini providers with it enabled"
  },
  "providerPreset": {
    "label": "Provider Preset",
    "custom": "Custom Configuration",
    "other": "Other",
    "hint": "You can continue to adjust the fields below after selecting a preset."
  },
  "usage": {
    "title": "Usage Statistics",
    "subtitle": "View AI model usage and cost statistics",
    "today": "24 Hours",
    "last7days": "7 Days",
    "last30days": "30 Days",
    "totalRequests": "Total Requests",
    "totalCost": "Total Cost",
    "cost": "Cost",
    "perMillion": "(per million)",
    "trends": "Usage Trends",
    "rangeToday": "Today (hourly)",
    "rangeLast7Days": "Last 7 days",
    "rangeLast30Days": "Last 30 days",
    "totalTokens": "Total Tokens",
    "cacheTokens": "Cache Tokens",
    "requestLogs": "Request Logs",
    "providerStats": "Provider Stats",
    "modelStats": "Model Stats",
    "time": "Time",
    "provider": "Provider",
    "billingModel": "Billing Model",
    "inputTokens": "Input",
    "outputTokens": "Output",
    "cacheReadTokens": "Cache Read",
    "cacheCreationTokens": "Cache Write",
    "timingInfo": "Duration/TTFT",
    "status": "Status",
    "noData": "No data",
    "unknownProvider": "Unknown Provider",
    "stream": "Stream",
    "nonStream": "Non-stream",
    "totalRecords": "{{total}} records total",
    "modelPricing": "Model Pricing",
    "loadPricingError": "Failed to load pricing data",
    "modelPricingDesc": "Configure token costs for each model",
    "noPricingData": "No pricing data. Click \"Add\" to add model pricing configuration.",
    "model": "Model",
    "displayName": "Display Name",
    "inputCost": "Input Cost",
    "outputCost": "Output Cost",
    "cacheReadCost": "Cache Read",
    "cacheWriteCost": "Cache Write",
    "deleteConfirmTitle": "Confirm Delete",
    "deleteConfirmDesc": "Are you sure you want to delete this model pricing? This action cannot be undone.",
    "queryFailed": "Query failed",
    "refreshUsage": "Refresh usage",
    "planUsage": "Plan usage",
    "invalid": "Expired",
    "total": "Total:",
    "used": "Used:",
    "remaining": "Remaining:",
    "justNow": "Just now",
    "minutesAgo": "{{count}} min ago",
    "hoursAgo": "{{count}} hr ago",
    "daysAgo": "{{count}} day ago",
    "multiplePlans": "{{count}} plans",
    "expand": "Expand",
    "collapse": "Collapse",
    "modelIdPlaceholder": "e.g., claude-3-5-sonnet-20241022",
    "displayNamePlaceholder": "e.g., Claude 3.5 Sonnet",
    "appType": "App Type",
    "allApps": "All Apps",
    "statusCode": "Status Code",
    "searchProviderPlaceholder": "Search provider...",
    "searchModelPlaceholder": "Search model...",
    "timeRange": "Time Range",
    "input": "Input",
    "output": "Output",
    "cacheWrite": "Write",
    "cacheRead": "Read"
  },
  "usageScript": {
    "title": "Configure Usage Query",
    "enableUsageQuery": "Enable usage query",
    "presetTemplate": "Preset template",
    "requestUrl": "Request URL",
    "requestUrlPlaceholder": "e.g. https://api.example.com",
    "method": "HTTP method",
    "templateCustom": "Custom",
    "templateGeneral": "General",
    "templateNewAPI": "NewAPI",
    "credentialsConfig": "Credentials",
    "credentialsHint": "Leave empty to use provider config",
    "optional": "optional",
    "apiKeyPlaceholder": "Leave empty to use provider's API Key",
    "baseUrlPlaceholder": "Leave empty to use provider's base URL",
    "baseUrl": "Base URL",
    "accessToken": "Access Token",
    "accessTokenPlaceholder": "Generate in 'Security Settings'",
    "userId": "User ID",
    "userIdPlaceholder": "e.g., 114514",
    "defaultPlan": "Default Plan",
    "queryFailedMessage": "Query failed",
    "queryScript": "Query script (JavaScript)",
    "timeoutSeconds": "Timeout (seconds)",
    "headers": "Headers",
    "body": "Body",
    "timeoutHint": "Range: 2-30 seconds",
    "timeoutMustBeInteger": "Timeout must be an integer, decimal part ignored",
    "timeoutCannotBeNegative": "Timeout cannot be negative",
    "autoIntervalMinutes": "Auto query interval (minutes, 0 to disable)",
    "autoQueryInterval": "Auto Query Interval (minutes)",
    "autoQueryIntervalHint": "0 to disable; recommend 5-60 minutes",
    "intervalMustBeInteger": "Interval must be an integer, decimal part ignored",
    "intervalCannotBeNegative": "Interval cannot be negative",
    "intervalAdjusted": "Interval adjusted to {{value}} minutes",
    "scriptHelp": "Script writing instructions:",
    "configFormat": "Configuration format:",
    "commentOptional": "optional",
    "commentResponseIsJson": "response is the JSON data returned by the API",
    "extractorFormat": "Extractor return format (all fields optional):",
    "tips": "💡 Tips:",
    "testing": "Testing...",
    "testScript": "Test script",
    "format": "Format",
    "saveConfig": "Save config",
    "scriptEmpty": "Script configuration cannot be empty",
    "mustHaveReturn": "Script must contain return statement",
    "testSuccess": "Test successful!",
    "testFailed": "Test failed",
    "formatSuccess": "Format successful",
    "formatFailed": "Format failed",
    "variablesHint": "Supported variables: {{apiKey}}, {{baseUrl}} | extractor function receives API response JSON object",
    "scriptConfig": "Request configuration",
    "extractorCode": "Extractor code",
    "extractorHint": "Return object should include remaining quota fields",
    "fieldIsValid": "• isValid: Boolean, whether plan is valid",
    "fieldInvalidMessage": "• invalidMessage: String, reason for expiration (shown when isValid is false)",
    "fieldRemaining": "• remaining: Number, remaining quota",
    "fieldUnit": "• unit: String, unit (e.g., \"USD\")",
    "fieldPlanName": "• planName: String, plan name",
    "fieldTotal": "• total: Number, total quota",
    "fieldUsed": "• used: Number, used quota",
    "fieldExtra": "• extra: String, custom display text",
    "tip1": "• Variables {{apiKey}} and {{baseUrl}} are automatically replaced",
    "tip2": "• Extractor function runs in sandbox environment, supports ES2020+ syntax",
    "tip3": "• Entire config must be wrapped in () to form object literal expression"
  },
  "errors": {
    "usage_query_failed": "Usage query failed",
    "configLoadFailedTitle": "Configuration Load Failed",
    "configLoadFailedMessage": "Unable to read configuration file:\n{{path}}\n\nError details:\n{{detail}}\n\nPlease check if the JSON is valid, or restore from a backup file (e.g., config.json.bak) in the same directory.\n\nThe app will exit so you can fix this."
  },
  "presetSelector": {
    "title": "Select Configuration Type",
    "custom": "Custom",
    "customDescription": "Manually configure provider, requires complete configuration",
    "officialDescription": "Official login, no API Key required",
    "presetDescription": "Use preset configuration, only API Key required"
  },
  "mcp": {
    "title": "MCP Management",
    "claudeTitle": "Claude Code MCP Management",
    "codexTitle": "Codex MCP Management",
    "geminiTitle": "Gemini MCP Management",
    "unifiedPanel": {
      "title": "MCP Server Management",
      "addServer": "Add Server",
      "editServer": "Edit Server",
      "deleteServer": "Delete Server",
      "deleteConfirm": "Are you sure you want to delete server \"{{id}}\"? This action cannot be undone.",
      "noServers": "No servers yet",
      "enabledApps": "Enabled Apps",
      "apps": {
        "claude": "Claude",
        "codex": "Codex",
        "gemini": "Gemini"
      }
    },
    "userLevelPath": "User-level MCP path",
    "serverList": "Servers",
    "loading": "Loading...",
    "empty": "No MCP servers",
    "emptyDescription": "Click the button in the top right to add your first MCP server",
    "add": "Add MCP",
    "addServer": "Add MCP",
    "editServer": "Edit MCP",
    "addClaudeServer": "Add Claude Code MCP",
    "editClaudeServer": "Edit Claude Code MCP",
    "addCodexServer": "Add Codex MCP",
    "editCodexServer": "Edit Codex MCP",
    "configPath": "Config Path",
    "serverCount": "{{count}} MCP server(s) configured",
    "enabledCount": "{{count}} enabled",
    "template": {
      "fetch": "Quick Template: mcp-fetch"
    },
    "form": {
      "title": "MCP Title (Unique)",
      "titlePlaceholder": "my-mcp-server",
      "name": "Display Name",
      "namePlaceholder": "e.g. @modelcontextprotocol/server-time",
      "enabledApps": "Enable to Apps",
      "noAppsWarning": "At least one app must be selected",
      "description": "Description",
      "descriptionPlaceholder": "Optional description",
      "tags": "Tags (comma separated)",
      "tagsPlaceholder": "stdio, time, utility",
      "homepage": "Homepage",
      "homepagePlaceholder": "https://example.com",
      "docs": "Docs",
      "docsPlaceholder": "https://example.com/docs",
      "additionalInfo": "Additional Info",
      "jsonConfig": "Full JSON Configuration",
      "jsonConfigOrPrefix": "Full JSON configuration or use",
      "tomlConfigOrPrefix": "Full TOML configuration or use",
      "jsonPlaceholder": "{\n  \"type\": \"stdio\",\n  \"command\": \"uvx\",\n  \"args\": [\"mcp-server-fetch\"]\n}",
      "tomlConfig": "Full TOML Configuration",
      "tomlPlaceholder": "type = \"stdio\"\ncommand = \"uvx\"\nargs = [\"mcp-server-fetch\"]",
      "useWizard": "Config Wizard",
      "syncOtherSide": "Mirror to {{target}}",
      "syncOtherSideHint": "Apply the same settings to {{target}}; existing entries with the same id will be overwritten.",
      "willOverwriteWarning": "Will overwrite existing config in {{target}}"
    },
    "wizard": {
      "title": "MCP Configuration Wizard",
      "hint": "Quickly configure MCP server and auto-generate JSON configuration",
      "type": "Type",
      "typeStdio": "stdio",
      "typeHttp": "http",
      "typeSse": "sse",
      "command": "Command",
      "commandPlaceholder": "npx or uvx",
      "args": "Arguments",
      "argsPlaceholder": "arg1\narg2",
      "env": "Environment Variables",
      "envPlaceholder": "KEY1=value1\nKEY2=value2",
      "url": "URL",
      "urlPlaceholder": "https://api.example.com/mcp",
      "urlRequired": "Please enter URL",
      "headers": "Headers (optional)",
      "headersPlaceholder": "Authorization: Bearer your_token_here\nContent-Type: application/json",
      "preview": "Configuration Preview",
      "apply": "Apply Configuration"
    },
    "id": "Identifier (unique)",
    "type": "Type",
    "command": "Command",
    "validateCommand": "Validate Command",
    "args": "Args",
    "argsPlaceholder": "e.g., mcp-server-fetch --help",
    "env": "Environment (one per line, KEY=VALUE)",
    "envPlaceholder": "FOO=bar\nHELLO=world",
    "reset": "Reset",
    "msg": {
      "saved": "Saved",
      "deleted": "Deleted",
      "enabled": "Enabled",
      "disabled": "Disabled",
      "templateAdded": "Template added"
    },
    "error": {
      "idRequired": "Please enter identifier",
      "idExists": "Identifier already exists. Please choose another.",
      "jsonInvalid": "Invalid JSON format",
      "tomlInvalid": "Invalid TOML format",
      "commandRequired": "Please enter command",
      "singleServerObjectRequired": "Please paste a single MCP server object (do not include top-level mcpServers)",
      "saveFailed": "Save failed",
      "deleteFailed": "Delete failed"
    },
    "validation": {
      "ok": "Command available",
      "fail": "Command not found"
    },
    "confirm": {
      "deleteTitle": "Delete MCP Server",
      "deleteMessage": "Are you sure you want to delete MCP server \"{{id}}\"? This action cannot be undone."
    },
    "presets": {
      "title": "Select MCP Type",
      "enable": "Enable",
      "enabled": "Enabled",
      "installed": "Installed",
      "docs": "Docs",
      "requiresEnv": "Requires env",
      "fetch": {
        "name": "mcp-server-fetch",
        "description": "Universal HTTP request tool, supports GET/POST and other HTTP methods, suitable for quick API requests and web data scraping"
      },
      "time": {
        "name": "@modelcontextprotocol/server-time",
        "description": "Time query tool providing current time, timezone conversion, and date calculation features"
      },
      "memory": {
        "name": "@modelcontextprotocol/server-memory",
        "description": "Knowledge graph memory system supporting entities, relations, and observations to help AI remember important information from conversations"
      },
      "sequential-thinking": {
        "name": "@modelcontextprotocol/server-sequential-thinking",
        "description": "Sequential thinking tool helping AI break down complex problems into multiple steps for deeper thinking"
      },
      "context7": {
        "name": "@upstash/context7-mcp",
        "description": "Context7 documentation search tool providing latest library docs and code examples, with higher limits when configured with a key"
      }
    }
  },
  "prompts": {
    "manage": "Prompts",
    "title": "{{appName}} Prompt Management",
    "claudeTitle": "Claude Prompt Management",
    "codexTitle": "Codex Prompt Management",
    "add": "Add Prompt",
    "edit": "Edit Prompt",
    "addTitle": "Add {{appName}} Prompt",
    "editTitle": "Edit {{appName}} Prompt",
    "import": "Import Existing",
    "count": "{{count}} prompts",
    "enabled": "Enabled",
    "enable": "Enable",
    "enabledName": "Enabled: {{name}}",
    "noneEnabled": "No prompt enabled",
    "currentFile": "Current {{filename}} Content",
    "empty": "No prompts yet",
    "emptyDescription": "Click the button above to add or import prompts",
    "loading": "Loading...",
    "name": "Name",
    "namePlaceholder": "e.g., Default Project Prompt",
    "description": "Description",
    "descriptionPlaceholder": "Optional description",
    "content": "Content",
    "contentPlaceholder": "# {{filename}}\n\nEnter prompt content here...",
    "loadFailed": "Failed to load prompts",
    "saveSuccess": "Saved successfully",
    "saveFailed": "Failed to save",
    "deleteSuccess": "Deleted successfully",
    "deleteFailed": "Failed to delete",
    "enableSuccess": "Enabled successfully",
    "enableFailed": "Failed to enable",
    "disableSuccess": "Disabled successfully",
    "disableFailed": "Failed to disable",
    "importSuccess": "Imported successfully",
    "importFailed": "Failed to import",
    "confirm": {
      "deleteTitle": "Confirm Delete",
      "deleteMessage": "Are you sure you want to delete prompt \"{{name}}\"?"
    }
  },
  "env": {
    "warning": {
      "title": "Environment Variable Conflicts Detected",
      "description": "Found {{count}} environment variables that may override your configuration"
    },
    "actions": {
      "expand": "View Details",
      "collapse": "Collapse",
      "selectAll": "Select All",
      "clearSelection": "Clear Selection",
      "deleteSelected": "Delete Selected ({{count}})",
      "deleting": "Deleting..."
    },
    "field": {
      "value": "Value",
      "source": "Source"
    },
    "source": {
      "userRegistry": "User Environment Variable (Registry)",
      "systemRegistry": "System Environment Variable (Registry)",
      "systemEnv": "System Environment Variable"
    },
    "delete": {
      "success": "Environment variables deleted successfully",
      "error": "Failed to delete environment variables"
    },
    "backup": {
      "location": "Backup location: {{path}}"
    },
    "confirm": {
      "title": "Confirm Delete Environment Variables",
      "message": "Are you sure you want to delete {{count}} environment variable(s)?",
      "backupNotice": "A backup will be created automatically before deletion. You can restore it later. Changes take effect after restarting the application or terminal.",
      "confirm": "Confirm Delete"
    },
    "error": {
      "noSelection": "Please select environment variables to delete"
    }
  },
  "skills": {
    "manage": "Skills",
    "title": "Claude Skills Management",
    "description": "Discover and install Claude skills from popular repositories to extend Claude Code/Codex capabilities",
    "refresh": "Refresh",
    "refreshing": "Refreshing...",
    "repoManager": "Repository Management",
    "count": "{{count}} skills",
    "empty": "No skills available",
    "emptyDescription": "Add skill repositories to discover available skills",
    "addRepo": "Add Skill Repository",
    "loading": "Loading...",
    "installed": "Installed",
    "install": "Install",
    "installing": "Installing...",
    "uninstall": "Uninstall",
    "uninstalling": "Uninstalling...",
    "view": "View",
    "noDescription": "No description",
    "loadFailed": "Failed to load",
    "installSuccess": "Skill {{name}} installed",
    "installFailed": "Failed to install",
    "uninstallSuccess": "Skill {{name}} uninstalled",
    "uninstallFailed": "Failed to uninstall",
    "error": {
      "skillNotFound": "Skill not found: {{directory}}",
      "missingRepoInfo": "Missing repository info (owner or name)",
      "downloadTimeout": "Download repository {{owner}}/{{name}} timeout ({{timeout}}s)",
      "downloadTimeoutHint": "Please check network connection or retry later",
      "skillPathNotFound": "Skill path '{{path}}' not found in repository {{owner}}/{{name}}",
      "skillDirNotFound": "Skill directory not found: {{path}}",
      "emptyArchive": "Downloaded archive is empty",
      "downloadFailed": "Download failed: HTTP {{status}}",
      "allBranchesFailed": "All branches failed, tried: {{branches}}",
      "httpError": "HTTP error {{status}}",
      "http403": "GitHub access restricted, possibly rate limited",
      "http404": "Repository or branch not found, please check URL",
      "http429": "Too many requests, please wait and retry",
      "parseMetadataFailed": "Failed to parse skill metadata",
      "getHomeDirFailed": "Unable to get user home directory",
      "networkError": "Network error",
      "fsError": "File system error",
      "unknownError": "Unknown error",
      "suggestion": {
        "checkNetwork": "Please check network connection",
        "checkProxy": "Consider configuring HTTP proxy",
        "retryLater": "Please retry later",
        "checkRepoUrl": "Please check repository URL and branch name",
        "checkDiskSpace": "Please check disk space",
        "checkPermission": "Please check directory permissions"
      }
    },
    "repo": {
      "title": "Manage Skill Repositories",
      "description": "Add or remove GitHub skill repository sources",
      "url": "Repository URL",
      "urlPlaceholder": "owner/name or https://github.com/owner/name",
      "branch": "Branch",
      "branchPlaceholder": "main",
      "path": "Skills Path",
      "pathPlaceholder": "skills (optional, leave empty for root)",
      "add": "Add Repository",
      "list": "Added Repositories",
      "empty": "No repositories",
      "invalidUrl": "Invalid repository URL format",
      "addSuccess": "Repository {{owner}}/{{name}} added, detected {{count}} skills",
      "addFailed": "Failed to add",
      "removeSuccess": "Repository {{owner}}/{{name}} removed",
      "removeFailed": "Failed to remove",
      "skillCount": "{{count}} skills detected"
    },
    "search": "Search Skills",
    "searchPlaceholder": "Search skill name or description...",
    "filter": {
      "placeholder": "Filter by status",
      "all": "All",
      "installed": "Installed",
      "uninstalled": "Not installed"
    },
    "noResults": "No matching skills found"
  },
  "deeplink": {
    "confirmImport": "Confirm Import Provider",
    "confirmImportDescription": "The following configuration will be imported from deep link into CC Switch",
    "importPrompt": "Import Prompt",
    "importPromptDescription": "Please confirm whether to import this system prompt",
    "importMcp": "Import MCP Servers",
    "importMcpDescription": "Please confirm whether to import these MCP Servers",
    "importSkill": "Add Skill Repository",
    "importSkillDescription": "Please confirm whether to add this Skill repository",
    "promptImportSuccess": "Prompt imported successfully",
    "promptImportSuccessDescription": "Imported prompt: {{name}}",
    "mcpImportSuccess": "MCP Servers imported successfully",
    "mcpImportSuccessDescription": "Successfully imported {{count}} server(s)",
    "mcpPartialSuccess": "Partial import success",
    "mcpPartialSuccessDescription": "Success: {{success}}, Failed: {{failed}}",
    "skillImportSuccess": "Skill repository added successfully",
    "skillImportSuccessDescription": "Added repository: {{repo}}",
    "app": "App Type",
    "providerName": "Provider Name",
    "homepage": "Homepage",
    "endpoint": "API Endpoint",
    "apiKey": "API Key",
    "icon": "Icon",
    "model": "Model",
    "haikuModel": "Haiku Model",
    "sonnetModel": "Sonnet Model",
    "opusModel": "Opus Model",
    "multiModel": "Multi-Modal Model",
    "notes": "Notes",
    "import": "Import",
    "importing": "Importing...",
    "warning": "Please confirm the information above is correct before importing. You can edit or delete it later in the provider list.",
    "parseError": "Failed to parse deep link",
    "importSuccess": "Import successful",
    "importSuccessDescription": "Provider \"{{name}}\" has been successfully imported",
    "importError": "Failed to import",
    "configSource": "Config Source",
    "configEmbedded": "Embedded Config",
    "configRemote": "Remote Config",
    "configDetails": "Config Details",
    "configUrl": "Config File URL",
    "configMergeError": "Failed to merge configuration file",
    "mcp": {
      "title": "Batch Import MCP Servers",
      "targetApps": "Target Apps",
      "serverCount": "MCP Servers ({{count}})",
      "enabledWarning": "After import, configurations will be written to all specified apps immediately"
    },
    "prompt": {
      "title": "Import System Prompt",
      "app": "App",
      "name": "Name",
      "description": "Description",
      "contentPreview": "Content Preview",
      "enabledWarning": "After import, this prompt will be enabled immediately and other prompts will be disabled"
    },
    "skill": {
      "title": "Add Claude Skill Repository",
      "repo": "GitHub Repository",
      "directory": "Target Directory",
      "branch": "Branch",
      "skillsPath": "Skills Path",
      "hint": "This will add the Skill repository to the list.",
      "hintDetail": "After adding, you can install specific Skills from the Skills management page."
    }
  },
  "iconPicker": {
    "search": "Search Icons",
    "searchPlaceholder": "Enter icon name...",
    "noResults": "No matching icons found",
    "category": {
      "aiProvider": "AI Providers",
      "cloud": "Cloud Platforms",
      "tool": "Dev Tools",
      "other": "Other"
    }
  },
  "providerIcon": {
    "label": "Icon",
    "colorLabel": "Icon Color",
    "selectIcon": "Select Icon",
    "preview": "Preview",
    "clickToChange": "Click to change icon",
    "clickToSelect": "Click to select icon"
  },
  "migration": {
    "success": "Configuration migrated successfully"
  },
  "agents": {
    "title": "Agents"
  },
  "health": {
    "operational": "Operational",
    "degraded": "Degraded",
    "failed": "Failed",
    "circuitOpen": "Circuit Open",
    "consecutiveFailures": "{{count}} consecutive failures"
  },
  "proxy": {
    "panel": {
      "serviceAddress": "Service Address",
      "addressCopied": "Address copied",
      "currentProvider": "Current Provider:",
      "waitingFirstRequest": "Current Provider: Waiting for first request...",
      "stoppedTitle": "Proxy Service Stopped",
      "stoppedDescription": "Use the toggle in the top right to start the service",
      "openSettings": "Configure Proxy Service",
      "stats": {
        "activeConnections": "Active Connections",
        "totalRequests": "Total Requests",
        "successRate": "Success Rate",
        "uptime": "Uptime"
      }
    },
    "settings": {
      "toast": {
        "saved": "Proxy configuration saved",
        "saveFailed": "Save failed: {{error}}"
      }
    },
    "switchFailed": "Switch failed: {{error}}",
    "failoverQueue": {
      "title": "Failover Queue",
      "description": "Manage failover order for each app's providers",
      "info": "The current active provider always takes priority. When requests fail, the system will try other providers in queue order.",
      "selectProvider": "Select a provider to add to queue",
      "noAvailableProviders": "No providers available to add",
      "empty": "Failover queue is empty. Add providers to enable automatic failover.",
      "dragHint": "Drag providers to adjust failover order. Lower numbers have higher priority.",
      "toggleEnabled": "Enable/Disable",
      "addSuccess": "Added to failover queue",
      "addFailed": "Failed to add",
      "removeSuccess": "Removed from failover queue",
      "removeFailed": "Failed to remove",
      "reorderSuccess": "Queue order updated",
      "reorderFailed": "Failed to update order",
      "toggleFailed": "Failed to update status"
    },
    "autoFailover": {
      "info": "When the failover queue has multiple providers, the system will try them in priority order when requests fail. When a provider reaches the consecutive failure threshold, the circuit breaker will open and skip it temporarily.",
      "configSaved": "Auto failover config saved",
      "configSaveFailed": "Failed to save",
      "retrySettings": "Retry & Timeout Settings",
      "failureThreshold": "Failure Threshold",
      "failureThresholdHint": "Open circuit breaker after this many consecutive failures (recommended: 3-10)",
      "timeout": "Recovery Wait Time (seconds)",
      "timeoutHint": "Wait this long before trying to recover after circuit opens (recommended: 30-120)",
      "circuitBreakerSettings": "Circuit Breaker Advanced Settings",
      "successThreshold": "Recovery Success Threshold",
      "successThresholdHint": "Close circuit breaker after this many successes in half-open state",
      "errorRate": "Error Rate Threshold (%)",
      "errorRateHint": "Open circuit breaker when error rate exceeds this value",
      "minRequests": "Minimum Requests",
      "minRequestsHint": "Minimum requests before calculating error rate",
      "explanationTitle": "How It Works",
      "failureThresholdLabel": "Failure Threshold",
      "failureThresholdExplain": "Circuit breaker opens after this many consecutive failures, making the provider temporarily unavailable",
      "timeoutLabel": "Recovery Wait Time",
      "timeoutExplain": "After circuit opens, wait this long before trying half-open state",
      "successThresholdLabel": "Recovery Success Threshold",
      "successThresholdExplain": "In half-open state, close circuit breaker after this many successes, making provider available again",
      "errorRateLabel": "Error Rate Threshold",
      "errorRateExplain": "Open circuit breaker when error rate exceeds this value, even if failure threshold not reached"
    }
  },
  "streamCheck": {
    "configSaved": "Health check config saved",
    "configSaveFailed": "Save failed",
    "testModels": "Test Models",
    "claudeModel": "Claude Model",
    "codexModel": "Codex Model",
    "geminiModel": "Gemini Model",
    "checkParams": "Check Parameters",
    "timeout": "Timeout (seconds)",
    "maxRetries": "Max Retries",
    "degradedThreshold": "Degraded Threshold (ms)"
  }
}
</file>

<file path="src/i18n/locales/zh.json">
{
  "app": {
    "title": "CC Switch",
    "description": "Claude Code / Codex / Gemini CLI 全方位辅助工具"
  },
  "common": {
    "add": "添加",
    "edit": "编辑",
    "delete": "删除",
    "save": "保存",
    "saving": "保存中...",
    "cancel": "取消",
    "confirm": "确定",
    "close": "关闭",
    "done": "完成",
    "settings": "设置",
    "about": "关于",
    "version": "版本",
    "loading": "加载中...",
    "notInstalled": "未安装",
    "success": "成功",
    "error": "错误",
    "unknown": "未知",
    "enterValidValue": "请输入有效的内容",
    "clear": "清除",
    "toggleTheme": "切换主题",
    "format": "格式化",
    "formatSuccess": "格式化成功",
    "formatError": "格式化失败：{{error}}",
    "copy": "复制",
    "view": "查看",
    "back": "返回",
    "refresh": "刷新",
    "refreshing": "刷新中...",
    "all": "全部",
    "search": "查询",
    "reset": "重置",
    "actions": "操作",
    "deleting": "删除中..."
  },
  "apiKeyInput": {
    "placeholder": "请输入API Key",
    "show": "显示API Key",
    "hide": "隐藏API Key"
  },
  "jsonEditor": {
    "mustBeObject": "配置必须是JSON对象，不能是数组或其他类型",
    "invalidJson": "JSON格式错误"
  },
  "claudeConfig": {
    "configLabel": "Claude Code 配置 (JSON) *",
    "writeCommonConfig": "写入通用配置",
    "editCommonConfig": "编辑通用配置",
    "editCommonConfigTitle": "编辑通用配置片段",
    "commonConfigHint": "该片段会在勾选\"写入通用配置\"时合并到 settings.json 中",
    "fullSettingsHint": "完整的 Claude Code settings.json 配置内容"
  },
  "header": {
    "viewOnGithub": "在 GitHub 上查看",
    "toggleDarkMode": "切换到暗色模式",
    "toggleLightMode": "切换到亮色模式",
    "addProvider": "添加供应商",
    "switchToChinese": "切换到中文",
    "switchToEnglish": "切换到英文",
    "enterEditMode": "进入编辑模式",
    "exitEditMode": "退出编辑模式"
  },
  "provider": {
    "noProviders": "还没有添加任何供应商",
    "noProvidersDescription": "点击右上角的\"添加供应商\"按钮开始配置您的第一个API供应商",
    "currentlyUsing": "当前使用",
    "enable": "启用",
    "inUse": "使用中",
    "editProvider": "编辑供应商",
    "editProviderHint": "更新配置后将立即应用到当前供应商。",
    "deleteProvider": "删除供应商",
    "addNewProvider": "添加新供应商",
    "addClaudeProvider": "添加 Claude Code 供应商",
    "addCodexProvider": "添加 Codex 供应商",
    "addGeminiProvider": "添加 Gemini 供应商",
    "addProviderHint": "填写信息后即可在列表中快速切换供应商。",
    "editClaudeProvider": "编辑 Claude Code 供应商",
    "editCodexProvider": "编辑 Codex 供应商",
    "configError": "配置错误",
    "notConfigured": "未配置官网地址",
    "applyToClaudePlugin": "应用到 Claude 插件",
    "removeFromClaudePlugin": "从 Claude 插件移除",
    "dragToReorder": "拖拽以重新排序",
    "dragHandle": "拖拽排序",
    "searchPlaceholder": "按名称/备注/网址搜索供应商...",
    "searchAriaLabel": "搜索供应商",
    "searchScopeHint": "根据名称、备注和官网链接匹配结果。",
    "searchCloseHint": "按 Esc 关闭",
    "searchCloseAriaLabel": "关闭供应商搜索",
    "noSearchResults": "没有符合搜索条件的供应商。",
    "duplicate": "复制",
    "sortUpdateFailed": "排序更新失败",
    "configureUsage": "配置用量查询",
    "name": "供应商名称",
    "namePlaceholder": "例如：Claude 官方",
    "websiteUrl": "官网链接",
    "notes": "备注",
    "notesPlaceholder": "例如：公司专用账号",
    "configJson": "配置 JSON",
    "writeCommonConfig": "写入通用配置",
    "editCommonConfigButton": "编辑通用配置",
    "configJsonHint": "请填写完整的 Claude Code 配置",
    "editCommonConfigTitle": "编辑通用配置片段",
    "editCommonConfigHint": "通用配置片段将合并到所有启用它的供应商配置中",
    "addProvider": "添加供应商",
    "sortUpdated": "排序已更新",
    "usageSaved": "用量查询配置已保存",
    "usageSaveFailed": "用量查询配置保存失败",
    "geminiConfig": "Gemini 配置",
    "geminiConfigHint": "使用 .env 格式配置 Gemini",
    "form": {
      "gemini": {
        "model": "模型",
        "oauthTitle": "OAuth 认证模式",
        "oauthHint": "Google 官方使用 OAuth 个人认证，无需填写 API Key。首次使用时会自动打开浏览器进行登录。",
        "apiKeyPlaceholder": "请输入 Gemini API Key"
      }
    }
  },
  "notifications": {
    "providerAdded": "供应商已添加",
    "providerSaved": "供应商配置已保存",
    "providerDeleted": "供应商删除成功",
    "switchSuccess": "切换成功！",
    "switchFailedTitle": "切换失败",
    "switchFailed": "切换失败：{{error}}",
    "autoImported": "已从现有配置创建默认供应商",
    "addFailed": "添加供应商失败：{{error}}",
    "saveFailed": "保存失败：{{error}}",
    "saveFailedGeneric": "保存失败，请重试",
    "appliedToClaudePlugin": "已应用到 Claude 插件",
    "removedFromClaudePlugin": "已从 Claude 插件移除",
    "syncClaudePluginFailed": "同步 Claude 插件失败",
    "skipClaudeOnboardingFailed": "跳过 Claude Code 初次安装确认失败",
    "clearClaudeOnboardingSkipFailed": "恢复 Claude Code 初次安装确认失败",
    "updateSuccess": "供应商更新成功",
    "updateFailed": "更新供应商失败：{{error}}",
    "deleteSuccess": "供应商已删除",
    "deleteFailed": "删除供应商失败：{{error}}",
    "settingsSaved": "设置已保存",
    "settingsSaveFailed": "保存设置失败：{{error}}"
  },
  "confirm": {
    "deleteProvider": "删除供应商",
    "deleteProviderMessage": "确定要删除供应商 \"{{name}}\" 吗？此操作无法撤销。"
  },
  "settings": {
    "title": "设置",
    "general": "通用",
    "tabGeneral": "通用",
    "tabAdvanced": "高级",
    "advanced": {
      "configDir": {
        "title": "配置文件目录",
        "description": "管理 Claude、Codex 和 Gemini 的配置存储路径"
      },
      "proxy": {
        "title": "本地代理",
        "description": "控制代理服务开关、查看状态与端口信息",
        "running": "运行中",
        "stopped": "已停止"
      },
      "modelTest": {
        "title": "模型测试配置",
        "description": "配置模型测试使用的默认模型和提示词"
      },
      "failover": {
        "title": "自动故障转移",
        "description": "配置故障转移队列和熔断策略"
      },
      "pricing": {
        "title": "成本定价",
        "description": "管理各模型 Token 计费规则"
      },
      "data": {
        "title": "数据管理",
        "description": "导入导出配置与备份恢复"
      }
    },
    "language": "界面语言",
    "languageHint": "切换后立即预览界面语言，保存后永久生效。",
    "theme": "外观主题",
    "themeHint": "选择应用的外观主题，立即生效。",
    "themeLight": "浅色",
    "themeDark": "深色",
    "themeSystem": "跟随系统",
    "importExport": "SQL 导入导出",
    "importExportHint": "导入/导出数据库 SQL 备份（仅支持导入由 CC Switch 导出的备份），便于备份或迁移。",
    "exportConfig": "导出 SQL 备份",
    "selectConfigFile": "选择 SQL 文件",
    "noFileSelected": "尚未选择配置文件。",
    "import": "导入",
    "importing": "导入中...",
    "importSuccess": "导入成功！",
    "importFailed": "导入失败",
    "syncLiveFailed": "已导入，但同步到当前供应商失败，请手动重新选择一次供应商。",
    "importPartialSuccess": "配置已导入，但同步到当前供应商失败。",
    "importPartialHint": "请手动重新选择一次供应商以刷新对应配置。",
    "configExported": "配置已导出到：",
    "exportFailed": "导出失败",
    "selectFileFailed": "请选择有效的 SQL 备份文件",
    "configCorrupted": "SQL 文件可能已损坏或格式不正确",
    "backupId": "备份ID",
    "autoReload": "数据已刷新",
    "languageOptionChinese": "中文",
    "languageOptionEnglish": "English",
    "languageOptionJapanese": "日本語",
    "windowBehavior": "窗口行为",
    "windowBehaviorHint": "配置窗口最小化与 Claude 插件联动策略。",
    "launchOnStartup": "开机自启",
    "launchOnStartupDescription": "随系统启动自动运行 CC Switch",
    "autoLaunchFailed": "设置开机自启失败",
    "minimizeToTray": "关闭时最小化到托盘",
    "minimizeToTrayDescription": "勾选后点击关闭按钮会隐藏到系统托盘，取消则直接退出应用。",
    "enableClaudePluginIntegration": "应用到 Claude Code 插件",
    "enableClaudePluginIntegrationDescription": "开启后 Vscode Claude Code 插件的供应商将随本软件切换",
    "skipClaudeOnboarding": "跳过 Claude Code 初次安装确认",
    "skipClaudeOnboardingDescription": "开启后跳过 Claude Code 初次安装确认",
    "configDirectoryOverride": "配置目录覆盖（高级）",
    "configDirectoryDescription": "在 WSL 等环境使用 Claude Code 或 Codex 的时候，可手动指定为 WSL 里的配置目录，供应商数据与主环境保持一致。",
    "appConfigDir": "CC Switch 配置目录",
    "appConfigDirDescription": "自定义 CC Switch 的配置存储位置（指定到云同步文件夹即可云同步配置）",
    "browsePlaceholderApp": "例如：C:\\Users\\Administrator\\.cc-switch",
    "claudeConfigDir": "Claude Code 配置目录",
    "claudeConfigDirDescription": "覆盖 Claude 配置目录 (settings.json)，同时会在同级存放 Claude MCP 的 claude.json。",
    "codexConfigDir": "Codex 配置目录",
    "codexConfigDirDescription": "覆盖 Codex 配置目录。",
    "geminiConfigDir": "Gemini 配置目录",
    "geminiConfigDirDescription": "覆盖 Gemini 配置目录 (.env)。",
    "browsePlaceholderClaude": "例如：/home/<你的用户名>/.claude",
    "browsePlaceholderCodex": "例如：/home/<你的用户名>/.codex",
    "browsePlaceholderGemini": "例如：/home/<你的用户名>/.gemini",
    "browseDirectory": "浏览目录",
    "resetDefault": "恢复默认目录（需保存后生效）",
    "checkForUpdates": "检查更新",
    "updateTo": "更新到 v{{version}}",
    "updating": "更新中...",
    "checking": "检查中...",
    "upToDate": "已是最新",
    "aboutHint": "查看版本信息与更新状态。",
    "portableMode": "当前为便携版，更新需手动下载。",
    "updateAvailable": "检测到新版本：{{version}}",
    "updateFailed": "更新安装失败，已尝试打开下载页面。",
    "checkUpdateFailed": "检查更新失败，请稍后重试。",
    "openReleaseNotesFailed": "打开更新日志失败",
    "releaseNotes": "更新日志",
    "viewReleaseNotes": "查看该版本更新日志",
    "viewCurrentReleaseNotes": "查看当前版本更新日志",
    "oneClickInstall": "一键安装",
    "oneClickInstallHint": "安装 Claude Code / Codex / Gemini CLI",
    "localEnvCheck": "本地环境检查",
    "installCommandsCopied": "安装命令已复制",
    "installCommandsCopyFailed": "复制失败，请手动复制。",
    "importFailedError": "导入配置失败：{{message}}",
    "exportFailedError": "导出配置失败:",
    "restartRequired": "需要重启应用",
    "restartRequiredMessage": "修改 CC Switch 配置目录后需要重启应用才能生效，是否立即重启？",
    "restartNow": "立即重启",
    "restartLater": "稍后重启",
    "restartFailed": "应用重启失败，请手动关闭后重新打开。",
    "devModeRestartHint": "开发模式下不支持自动重启，请手动重新启动应用。",
    "saving": "正在保存..."
  },
  "apps": {
    "claude": "Claude Code",
    "codex": "Codex",
    "gemini": "Gemini"
  },
  "console": {
    "providerSwitchReceived": "收到供应商切换事件:",
    "setupListenerFailed": "设置供应商切换监听器失败:",
    "updateProviderFailed": "更新供应商失败:",
    "autoImportFailed": "自动导入默认配置失败:",
    "openLinkFailed": "打开链接失败:",
    "getVersionFailed": "获取版本信息失败:",
    "loadSettingsFailed": "加载设置失败:",
    "getConfigPathFailed": "获取配置路径失败:",
    "getConfigDirFailed": "获取配置目录失败:",
    "detectPortableFailed": "检测便携模式失败:",
    "saveSettingsFailed": "保存设置失败:",
    "updateFailed": "更新失败:",
    "checkUpdateFailed": "检查更新失败:",
    "openConfigFolderFailed": "打开配置文件夹失败:",
    "selectConfigDirFailed": "选择配置目录失败:",
    "getDefaultConfigDirFailed": "获取默认配置目录失败:",
    "openReleaseNotesFailed": "打开更新日志失败:"
  },
  "providerForm": {
    "supplierName": "供应商名称",
    "supplierNameRequired": "供应商名称 *",
    "supplierNamePlaceholder": "例如：Anthropic 官方",
    "websiteUrl": "官网地址",
    "websiteUrlPlaceholder": "https://example.com（可选）",
    "apiEndpoint": "请求地址",
    "apiEndpointPlaceholder": "https://your-api-endpoint.com",
    "codexApiEndpointPlaceholder": "https://your-api-endpoint.com/v1",
    "manageAndTest": "管理与测速",
    "configContent": "配置内容",
    "officialNoApiKey": "官方登录无需填写 API Key，直接保存即可",
    "codexOfficialNoApiKey": "官方无需填写 API Key，直接保存即可",
    "codexApiKeyAutoFill": "只需要填这里，下方 auth.json 会自动填充",
    "apiKeyAutoFill": "只需要填这里，下方配置会自动填充",
    "cnOfficialApiKeyHint": "💡 只需填写 API Key，请求地址已预设",
    "aggregatorApiKeyHint": "💡 只需填写 API Key，请求地址已预设",
    "thirdPartyApiKeyHint": "💡 只需填写 API Key，请求地址已预设",
    "customApiKeyHint": "💡 自定义配置需手动填写所有必要字段",
    "officialHint": "💡 官方供应商使用浏览器登录，无需配置 API Key",
    "getApiKey": "获取 API Key",
    "partnerPromotion": {
      "zhipu": "智谱 GLM 是 CC Switch 的官方合作伙伴，使用此链接充值可以获得9折优惠",
      "packycode": "PackyCode 是 CC Switch 的官方合作伙伴，使用此链接注册并在充值时填写 \"cc-switch\" 优惠码，可以享受9折优惠",
      "minimax_cn": "MiniMax Coding Plan 特惠，Starter 套餐 9.9 元起",
      "minimax_en": "MiniMax Coding Plan 黑五特惠，Starter 套餐现仅 $2/月（2折优惠！）",
      "dmxapi": "Claude Code 专属模型 3.4 折优惠进行中！"
    },
    "parameterConfig": "参数配置 - {{name}} *",
    "mainModel": "主模型 (可选)",
    "mainModelPlaceholder": "例如: GLM-4.6",
    "fastModel": "快速模型 (可选)",
    "fastModelPlaceholder": "例如: GLM-4.5-Air",
    "modelHint": "💡 留空将使用供应商的默认模型",
    "apiHint": "💡 填写兼容 Claude API 的服务端点地址，不要以斜杠结尾",
    "codexApiHint": "💡 填写兼容 OpenAI Response 格式的服务端点地址",
    "fillSupplierName": "请填写供应商名称",
    "fillConfigContent": "请填写配置内容",
    "fillParameter": "请填写 {{label}}",
    "fillTemplateValue": "请填写 {{label}}",
    "endpointRequired": "非官方供应商请填写 API 端点",
    "apiKeyRequired": "非官方供应商请填写 API Key",
    "configJsonError": "配置JSON格式错误，请检查语法",
    "authJsonRequired": "auth.json 必须是 JSON 对象",
    "authJsonError": "auth.json 格式错误，请检查JSON语法",
    "fillAuthJson": "请填写 auth.json 配置",
    "fillApiKey": "请填写 OPENAI_API_KEY",
    "visitWebsite": "访问 {{url}}",
    "anthropicModel": "主模型",
    "anthropicSmallFastModel": "快速模型",
    "anthropicDefaultHaikuModel": "Haiku 默认模型",
    "anthropicDefaultSonnetModel": "Sonnet 默认模型",
    "anthropicDefaultOpusModel": "Opus 默认模型",
    "modelPlaceholder": "",
    "smallModelPlaceholder": "",
    "haikuModelPlaceholder": "",
    "modelHelper": "可选：指定默认使用的 Claude 模型，留空则使用系统默认。",
    "categoryOfficial": "官方",
    "categoryCnOfficial": "开源官方",
    "categoryAggregation": "聚合服务",
    "categoryThirdParty": "第三方"
  },
  "endpointTest": {
    "title": "请求地址管理",
    "endpoints": "个端点",
    "autoSelect": "自动选择",
    "testSpeed": "测速",
    "testing": "测速中",
    "addEndpointPlaceholder": "https://api.example.com",
    "done": "完成",
    "noEndpoints": "暂无端点",
    "failed": "失败",
    "enterValidUrl": "请输入有效的 URL",
    "invalidUrlFormat": "URL 格式不正确",
    "onlyHttps": "仅支持 HTTP/HTTPS",
    "urlExists": "该地址已存在",
    "saveFailed": "保存失败，请重试",
    "loadEndpointsFailed": "加载自定义端点失败:",
    "addEndpointFailed": "添加自定义端点失败:",
    "removeEndpointFailed": "删除自定义端点失败:",
    "removeFailed": "删除失败: {{error}}",
    "updateLastUsedFailed": "更新端点使用时间失败",
    "pleaseAddEndpoint": "请先添加端点",
    "testUnavailable": "测速功能不可用",
    "noResult": "未返回结果",
    "testFailed": "测速失败: {{error}}",
    "status": "状态码：{{code}}"
  },
  "codexConfig": {
    "authJson": "auth.json (JSON) *",
    "authJsonPlaceholder": "{\n  \"OPENAI_API_KEY\": \"sk-your-api-key-here\"\n}",
    "authJsonHint": "Codex auth.json 配置内容",
    "configToml": "config.toml (TOML)",
    "configTomlHint": "Codex config.toml 配置内容",
    "writeCommonConfig": "写入通用配置",
    "editCommonConfig": "编辑通用配置",
    "editCommonConfigTitle": "编辑 Codex 通用配置片段",
    "commonConfigHint": "该片段会在勾选'写入通用配置'时追加到 config.toml 末尾",
    "apiUrlLabel": "API 请求地址"
  },
  "geminiConfig": {
    "envFile": "环境变量 (.env)",
    "envFileHint": "使用 .env 格式配置 Gemini 环境变量",
    "configJson": "配置文件 (config.json)",
    "configJsonHint": "使用 JSON 格式配置 Gemini 扩展参数（可选）",
    "writeCommonConfig": "写入通用配置",
    "editCommonConfig": "编辑通用配置",
    "editCommonConfigTitle": "编辑 Gemini 通用配置片段",
    "commonConfigHint": "通用配置片段将合并到所有启用它的 Gemini 供应商配置中"
  },
  "providerPreset": {
    "label": "预设供应商",
    "custom": "自定义配置",
    "other": "其他",
    "hint": "选择预设后可继续调整下方字段。"
  },
  "usage": {
    "title": "使用统计",
    "subtitle": "查看 AI 模型的使用情况和成本统计",
    "today": "24小时",
    "last7days": "7天",
    "last30days": "30天",
    "totalRequests": "总请求数",
    "totalCost": "总成本",
    "cost": "成本",
    "perMillion": "(每百万)",
    "trends": "使用趋势",
    "rangeToday": "今天 (按小时)",
    "rangeLast7Days": "过去 7 天",
    "rangeLast30Days": "过去 30 天",
    "totalTokens": "总 Token 数",
    "cacheTokens": "缓存 Token",
    "requestLogs": "请求日志",
    "providerStats": "Provider 统计",
    "modelStats": "模型统计",
    "time": "时间",
    "provider": "供应商",
    "billingModel": "计费模型",
    "inputTokens": "输入",
    "outputTokens": "输出",
    "cacheReadTokens": "缓存读取",
    "cacheCreationTokens": "缓存写入",
    "timingInfo": "用时/首字",
    "status": "状态",
    "noData": "暂无数据",
    "unknownProvider": "未知供应商",
    "stream": "流",
    "nonStream": "非流",
    "totalRecords": "共 {{total}} 条记录",
    "modelPricing": "模型定价",
    "loadPricingError": "加载定价数据失败",
    "modelPricingDesc": "配置各模型的 Token 成本",
    "noPricingData": "暂无定价数据。点击\"新增\"添加模型定价配置。",
    "model": "模型",
    "displayName": "显示名称",
    "inputCost": "输入成本",
    "outputCost": "输出成本",
    "cacheReadCost": "缓存读取",
    "cacheWriteCost": "缓存写入",
    "deleteConfirmTitle": "确认删除",
    "deleteConfirmDesc": "确定要删除此模型定价配置吗？此操作无法撤销。",
    "queryFailed": "查询失败",
    "refreshUsage": "刷新用量",
    "planUsage": "套餐用量",
    "invalid": "已失效",
    "total": "总：",
    "used": "已使用：",
    "remaining": "剩余：",
    "justNow": "刚刚",
    "minutesAgo": "{{count}} 分钟前",
    "hoursAgo": "{{count}} 小时前",
    "daysAgo": "{{count}} 天前",
    "multiplePlans": "{{count}} 个套餐",
    "expand": "展开",
    "collapse": "收起",
    "modelIdPlaceholder": "例如: claude-3-5-sonnet-20241022",
    "displayNamePlaceholder": "例如: Claude 3.5 Sonnet",
    "appType": "应用类型",
    "allApps": "全部应用",
    "statusCode": "状态码",
    "searchProviderPlaceholder": "搜索供应商...",
    "searchModelPlaceholder": "搜索模型...",
    "timeRange": "时间范围",
    "input": "Input",
    "output": "Output",
    "cacheWrite": "Write",
    "cacheRead": "Read"
  },
  "usageScript": {
    "title": "配置用量查询",
    "enableUsageQuery": "启用用量查询",
    "presetTemplate": "预设模板",
    "requestUrl": "请求地址",
    "requestUrlPlaceholder": "例如：https://api.example.com",
    "method": "HTTP 方法",
    "templateCustom": "自定义",
    "templateGeneral": "通用模板",
    "templateNewAPI": "NewAPI",
    "credentialsConfig": "凭证配置",
    "credentialsHint": "留空则自动使用供应商配置",
    "optional": "可选",
    "apiKeyPlaceholder": "留空则使用供应商的 API Key",
    "baseUrlPlaceholder": "留空则使用供应商的请求地址",
    "baseUrl": "请求地址",
    "accessToken": "访问令牌（在个人安全设置里获取）",
    "accessTokenPlaceholder": "在'安全设置'里生成",
    "userId": "用户 ID",
    "userIdPlaceholder": "例如：114514",
    "defaultPlan": "默认套餐",
    "queryFailedMessage": "查询失败",
    "queryScript": "查询脚本（JavaScript）",
    "timeoutSeconds": "超时时间（秒）",
    "headers": "请求头",
    "body": "请求 Body",
    "timeoutHint": "范围: 2-30 秒",
    "timeoutMustBeInteger": "超时时间必须为整数，小数部分已忽略",
    "timeoutCannotBeNegative": "超时时间不能为负数",
    "autoIntervalMinutes": "自动查询间隔（分钟，0 表示不自动查询）",
    "autoQueryInterval": "自动查询间隔（分钟）",
    "autoQueryIntervalHint": "0 表示不自动查询，建议 5-60 分钟",
    "intervalMustBeInteger": "自动查询间隔必须为整数，小数部分已忽略",
    "intervalCannotBeNegative": "自动查询间隔不能为负数",
    "intervalAdjusted": "自动查询间隔已调整为 {{value}} 分钟",
    "scriptHelp": "脚本编写说明：",
    "configFormat": "配置格式：",
    "commentOptional": "可选",
    "commentResponseIsJson": "response 是 API 返回的 JSON 数据",
    "extractorFormat": "extractor 返回格式（所有字段均为可选）：",
    "tips": "💡 提示：",
    "testing": "测试中...",
    "testScript": "测试脚本",
    "format": "格式化",
    "saveConfig": "保存配置",
    "scriptEmpty": "脚本配置不能为空",
    "mustHaveReturn": "脚本必须包含 return 语句",
    "testSuccess": "测试成功！",
    "testFailed": "测试失败",
    "formatSuccess": "格式化成功",
    "formatFailed": "格式化失败",
    "variablesHint": "支持变量: {{apiKey}}, {{baseUrl}} | extractor 函数接收 API 响应的 JSON 对象",
    "scriptConfig": "请求配置",
    "extractorCode": "提取器代码",
    "extractorHint": "返回对象需包含剩余额度等字段",
    "fieldIsValid": "• isValid: 布尔值，套餐是否有效",
    "fieldInvalidMessage": "• invalidMessage: 字符串，失效原因说明（当 isValid 为 false 时显示）",
    "fieldRemaining": "• remaining: 数字，剩余额度",
    "fieldUnit": "• unit: 字符串，单位（如 \"USD\"）",
    "fieldPlanName": "• planName: 字符串，套餐名称",
    "fieldTotal": "• total: 数字，总额度",
    "fieldUsed": "• used: 数字，已用额度",
    "fieldExtra": "• extra: 字符串，扩展字段，可自由补充需要展示的文本",
    "tip1": "• 变量 {{apiKey}} 和 {{baseUrl}} 会自动替换",
    "tip2": "• extractor 函数在沙箱环境中执行，支持 ES2020+ 语法",
    "tip3": "• 整个配置必须用 () 包裹，形成对象字面量表达式"
  },
  "errors": {
    "usage_query_failed": "用量查询失败",
    "configLoadFailedTitle": "配置加载失败",
    "configLoadFailedMessage": "无法读取配置文件：\n{{path}}\n\n错误详情：\n{{detail}}\n\n请手动检查 JSON 是否有效，或从同目录的备份文件（如 config.json.bak）恢复。\n\n应用将退出以便您进行修复。"
  },
  "presetSelector": {
    "title": "选择配置类型",
    "custom": "自定义",
    "customDescription": "手动配置供应商，需要填写完整的配置信息",
    "officialDescription": "官方登录，不需要填写 API Key",
    "presetDescription": "使用预设配置，只需填写 API Key"
  },
  "mcp": {
    "title": "MCP 管理",
    "claudeTitle": "Claude Code MCP 管理",
    "codexTitle": "Codex MCP 管理",
    "geminiTitle": "Gemini MCP 管理",
    "unifiedPanel": {
      "title": "MCP 服务器管理",
      "addServer": "添加服务器",
      "editServer": "编辑服务器",
      "deleteServer": "删除服务器",
      "deleteConfirm": "确定要删除服务器 \"{{id}}\" 吗？此操作无法撤销。",
      "noServers": "暂无服务器",
      "enabledApps": "启用的应用",
      "apps": {
        "claude": "Claude",
        "codex": "Codex",
        "gemini": "Gemini"
      }
    },
    "userLevelPath": "用户级 MCP 配置路径",
    "serverList": "服务器列表",
    "loading": "加载中...",
    "empty": "暂无 MCP 服务器",
    "emptyDescription": "点击右上角按钮添加第一个 MCP 服务器",
    "add": "添加 MCP",
    "addServer": "新增 MCP",
    "editServer": "编辑 MCP",
    "addClaudeServer": "新增 Claude Code MCP",
    "editClaudeServer": "编辑 Claude Code MCP",
    "addCodexServer": "新增 Codex MCP",
    "editCodexServer": "编辑 Codex MCP",
    "configPath": "配置路径",
    "serverCount": "已配置 {{count}} 个 MCP 服务器",
    "enabledCount": "已启用 {{count}} 个",
    "template": {
      "fetch": "快速模板：mcp-fetch"
    },
    "form": {
      "title": "MCP 标题（唯一）",
      "titlePlaceholder": "my-mcp-server",
      "name": "显示名称",
      "namePlaceholder": "例如 @modelcontextprotocol/server-time",
      "enabledApps": "启用到应用",
      "noAppsWarning": "至少选择一个应用",
      "description": "描述",
      "descriptionPlaceholder": "可选的描述信息",
      "tags": "标签（逗号分隔）",
      "tagsPlaceholder": "stdio, time, utility",
      "homepage": "主页链接",
      "homepagePlaceholder": "https://example.com",
      "docs": "文档链接",
      "docsPlaceholder": "https://example.com/docs",
      "additionalInfo": "附加信息",
      "jsonConfig": "完整的 JSON 配置",
      "jsonConfigOrPrefix": "完整的 JSON 配置或者使用",
      "tomlConfigOrPrefix": "完整的 TOML 配置或者使用",
      "jsonPlaceholder": "{\n  \"type\": \"stdio\",\n  \"command\": \"uvx\",\n  \"args\": [\"mcp-server-fetch\"]\n}",
      "tomlConfig": "完整的 TOML 配置",
      "tomlPlaceholder": "type = \"stdio\"\ncommand = \"uvx\"\nargs = [\"mcp-server-fetch\"]",
      "useWizard": "配置向导",
      "syncOtherSide": "同步到 {{target}}",
      "syncOtherSideHint": "勾选后会把当前配置同时写入 {{target}}，若存在同名配置将被覆盖",
      "willOverwriteWarning": "将覆盖 {{target}} 中的同名配置"
    },
    "wizard": {
      "title": "MCP 配置向导",
      "hint": "快速配置 MCP 服务器，自动生成 JSON 配置",
      "type": "类型",
      "typeStdio": "stdio",
      "typeHttp": "http",
      "typeSse": "sse",
      "command": "命令",
      "commandPlaceholder": "npx 或 uvx",
      "args": "参数",
      "argsPlaceholder": "arg1\narg2",
      "env": "环境变量",
      "envPlaceholder": "KEY1=value1\nKEY2=value2",
      "url": "URL",
      "urlPlaceholder": "https://api.example.com/mcp",
      "urlRequired": "请输入 URL",
      "headers": "请求头（可选）",
      "headersPlaceholder": "Authorization: Bearer your_token_here\nContent-Type: application/json",
      "preview": "配置预览",
      "apply": "应用配置"
    },
    "id": "标识 (唯一)",
    "type": "类型",
    "command": "命令",
    "validateCommand": "校验命令",
    "args": "参数",
    "argsPlaceholder": "例如：mcp-server-fetch --help",
    "env": "环境变量 (一行一个，KEY=VALUE)",
    "envPlaceholder": "FOO=bar\nHELLO=world",
    "reset": "重置",
    "msg": {
      "saved": "已保存",
      "deleted": "已删除",
      "enabled": "已启用",
      "disabled": "已禁用",
      "templateAdded": "已添加模板"
    },
    "error": {
      "idRequired": "请填写标识",
      "idExists": "该标识已存在，请更换",
      "jsonInvalid": "JSON 格式错误，请检查",
      "tomlInvalid": "TOML 格式错误，请检查",
      "commandRequired": "请填写命令",
      "singleServerObjectRequired": "此处只需单个服务器对象，请不要粘贴包含 mcpServers 的整份配置",
      "saveFailed": "保存失败",
      "deleteFailed": "删除失败"
    },
    "validation": {
      "ok": "命令可用",
      "fail": "命令不可用"
    },
    "confirm": {
      "deleteTitle": "删除 MCP 服务器",
      "deleteMessage": "确定要删除 MCP 服务器 \"{{id}}\" 吗？此操作无法撤销。"
    },
    "presets": {
      "title": "选择 MCP 类型",
      "enable": "启用",
      "enabled": "已启用",
      "installed": "已安装",
      "docs": "文档",
      "requiresEnv": "需要环境变量",
      "fetch": {
        "name": "mcp-server-fetch",
        "description": "通用 HTTP 请求工具，支持 GET/POST 等 HTTP 方法，适合快速请求接口/抓取网页数据"
      },
      "time": {
        "name": "@modelcontextprotocol/server-time",
        "description": "时间查询工具，提供当前时间、时区转换、日期计算等功能"
      },
      "memory": {
        "name": "@modelcontextprotocol/server-memory",
        "description": "知识图谱记忆系统，支持存储实体、关系和观察，让 AI 记住对话中的重要信息"
      },
      "sequential-thinking": {
        "name": "@modelcontextprotocol/server-sequential-thinking",
        "description": "顺序思考工具，帮助 AI 将复杂问题分解为多个步骤，逐步深入思考"
      },
      "context7": {
        "name": "@upstash/context7-mcp",
        "description": "Context7 文档搜索工具，提供最新的库文档和代码示例，配置 key 会有更高限额"
      }
    }
  },
  "prompts": {
    "manage": "提示词",
    "title": "{{appName}} 提示词管理",
    "claudeTitle": "Claude 提示词管理",
    "codexTitle": "Codex 提示词管理",
    "add": "添加提示词",
    "edit": "编辑提示词",
    "addTitle": "添加 {{appName}} 提示词",
    "editTitle": "编辑 {{appName}} 提示词",
    "import": "导入现有",
    "count": "共 {{count}} 个提示词",
    "enabled": "已启用",
    "enable": "启用",
    "enabledName": "已启用: {{name}}",
    "noneEnabled": "未启用任何提示词",
    "currentFile": "当前 {{filename}} 内容",
    "empty": "暂无提示词",
    "emptyDescription": "点击右上角按钮添加或导入提示词",
    "loading": "加载中...",
    "name": "名称",
    "namePlaceholder": "例如：项目默认提示词",
    "description": "描述",
    "descriptionPlaceholder": "可选的描述信息",
    "content": "内容",
    "contentPlaceholder": "# {{filename}}\n\n在此输入提示词内容...",
    "loadFailed": "加载提示词失败",
    "saveSuccess": "保存成功",
    "saveFailed": "保存失败",
    "deleteSuccess": "删除成功",
    "deleteFailed": "删除失败",
    "enableSuccess": "启用成功",
    "enableFailed": "启用失败",
    "disableSuccess": "禁用成功",
    "disableFailed": "禁用失败",
    "importSuccess": "导入成功",
    "importFailed": "导入失败",
    "confirm": {
      "deleteTitle": "确认删除",
      "deleteMessage": "确定要删除提示词 \"{{name}}\" 吗？"
    }
  },
  "env": {
    "warning": {
      "title": "检测到系统环境变量冲突",
      "description": "发现 {{count}} 个环境变量可能会覆盖您的配置"
    },
    "actions": {
      "expand": "查看详情",
      "collapse": "收起",
      "selectAll": "全选",
      "clearSelection": "取消选择",
      "deleteSelected": "删除选中 ({{count}})",
      "deleting": "删除中..."
    },
    "field": {
      "value": "值",
      "source": "来源"
    },
    "source": {
      "userRegistry": "用户环境变量 (注册表)",
      "systemRegistry": "系统环境变量 (注册表)",
      "systemEnv": "系统环境变量"
    },
    "delete": {
      "success": "环境变量已成功删除",
      "error": "删除环境变量失败"
    },
    "backup": {
      "location": "备份位置: {{path}}"
    },
    "confirm": {
      "title": "确认删除环境变量",
      "message": "确定要删除 {{count}} 个环境变量吗？",
      "backupNotice": "删除前将自动备份,您可以稍后恢复。删除后需要重启应用或终端才能生效。",
      "confirm": "确认删除"
    },
    "error": {
      "noSelection": "请选择要删除的环境变量"
    }
  },
  "skills": {
    "manage": "Skills",
    "title": "Claude Skills 管理",
    "description": "从流行的仓库发现并安装 Claude 技能，扩展 Claude Code/Codex 的能力",
    "refresh": "刷新",
    "refreshing": "刷新中...",
    "repoManager": "仓库管理",
    "count": "共 {{count}} 个技能",
    "empty": "暂无可用技能",
    "emptyDescription": "添加技能仓库以发现可用的技能",
    "addRepo": "添加技能仓库",
    "loading": "加载中...",
    "installed": "已安装",
    "install": "安装",
    "installing": "安装中...",
    "uninstall": "卸载",
    "uninstalling": "卸载中...",
    "view": "查看",
    "noDescription": "暂无描述",
    "loadFailed": "加载失败",
    "installSuccess": "技能 {{name}} 已安装",
    "installFailed": "安装失败",
    "uninstallSuccess": "技能 {{name}} 已卸载",
    "uninstallFailed": "卸载失败",
    "error": {
      "skillNotFound": "技能不存在：{{directory}}",
      "missingRepoInfo": "缺少仓库信息（owner 或 name）",
      "downloadTimeout": "下载仓库 {{owner}}/{{name}} 超时（{{timeout}}秒）",
      "downloadTimeoutHint": "请检查网络连接或稍后重试",
      "skillPathNotFound": "仓库 {{owner}}/{{name}} 中未找到技能路径 '{{path}}'",
      "skillDirNotFound": "技能目录不存在：{{path}}",
      "emptyArchive": "下载的压缩包为空",
      "downloadFailed": "下载失败：HTTP {{status}}",
      "allBranchesFailed": "所有分支下载失败，尝试了：{{branches}}",
      "httpError": "HTTP 错误 {{status}}",
      "http403": "GitHub 访问受限，可能是请求频率过高",
      "http404": "仓库或分支不存在，请检查地址",
      "http429": "请求过于频繁，请等待后重试",
      "parseMetadataFailed": "解析技能元数据失败",
      "getHomeDirFailed": "无法获取用户主目录",
      "networkError": "网络错误",
      "fsError": "文件系统错误",
      "unknownError": "未知错误",
      "suggestion": {
        "checkNetwork": "请检查网络连接",
        "checkProxy": "建议配置 HTTP 代理",
        "retryLater": "请稍后重试",
        "checkRepoUrl": "请检查仓库地址和分支名称",
        "checkDiskSpace": "请检查磁盘空间",
        "checkPermission": "请检查目录权限"
      }
    },
    "repo": {
      "title": "管理技能仓库",
      "description": "添加或删除 GitHub 技能仓库源",
      "url": "仓库 URL",
      "urlPlaceholder": "owner/name 或 https://github.com/owner/name",
      "branch": "分支",
      "branchPlaceholder": "main",
      "path": "技能路径",
      "pathPlaceholder": "skills (可选，留空扫描根目录)",
      "add": "添加仓库",
      "list": "已添加的仓库",
      "empty": "暂无仓库",
      "invalidUrl": "无效的仓库 URL 格式",
      "addSuccess": "仓库 {{owner}}/{{name}} 已添加，识别到 {{count}} 个技能",
      "addFailed": "添加失败",
      "removeSuccess": "仓库 {{owner}}/{{name}} 已删除",
      "removeFailed": "删除失败",
      "skillCount": "识别到 {{count}} 个技能"
    },
    "search": "搜索技能",
    "searchPlaceholder": "搜索技能名称或描述...",
    "filter": {
      "placeholder": "状态筛选",
      "all": "全部",
      "installed": "已安装",
      "uninstalled": "未安装"
    },
    "noResults": "未找到匹配的技能"
  },
  "deeplink": {
    "confirmImport": "确认导入供应商配置",
    "confirmImportDescription": "以下配置将导入到 CC Switch",
    "importPrompt": "导入提示词",
    "importPromptDescription": "请确认是否导入此系统提示词",
    "importMcp": "导入 MCP Servers",
    "importMcpDescription": "请确认是否导入这些 MCP Servers",
    "importSkill": "添加 Skill 仓库",
    "importSkillDescription": "请确认是否添加此 Skill 仓库",
    "promptImportSuccess": "提示词导入成功",
    "promptImportSuccessDescription": "已导入提示词: {{name}}",
    "mcpImportSuccess": "MCP Servers 导入成功",
    "mcpImportSuccessDescription": "成功导入 {{count}} 个服务器",
    "mcpPartialSuccess": "部分导入成功",
    "mcpPartialSuccessDescription": "成功: {{success}}, 失败: {{failed}}",
    "skillImportSuccess": "Skill 仓库添加成功",
    "skillImportSuccessDescription": "已添加仓库: {{repo}}",
    "app": "应用类型",
    "providerName": "供应商名称",
    "homepage": "官网地址",
    "endpoint": "API 端点",
    "apiKey": "API 密钥",
    "icon": "图标",
    "model": "模型",
    "haikuModel": "Haiku 模型",
    "sonnetModel": "Sonnet 模型",
    "opusModel": "Opus 模型",
    "multiModel": "多模态模型",
    "notes": "备注",
    "import": "导入",
    "importing": "导入中...",
    "warning": "请确认以上信息准确无误后再导入。导入后可在供应商列表中编辑或删除。",
    "parseError": "深链接解析失败",
    "importSuccess": "导入成功",
    "importSuccessDescription": "供应商 \"{{name}}\" 已成功导入",
    "importError": "导入失败",
    "configSource": "配置来源",
    "configEmbedded": "内嵌配置",
    "configRemote": "远程配置",
    "configDetails": "配置详情",
    "configUrl": "配置文件 URL",
    "configMergeError": "合并配置文件失败",
    "mcp": {
      "title": "批量导入 MCP Servers",
      "targetApps": "目标应用",
      "serverCount": "MCP Servers ({{count}} 个)",
      "enabledWarning": "导入后将立即写入所有指定应用的配置文件"
    },
    "prompt": {
      "title": "导入系统提示词",
      "app": "应用",
      "name": "名称",
      "description": "描述",
      "contentPreview": "内容预览",
      "enabledWarning": "导入后将立即启用此提示词，其他提示词将被禁用"
    },
    "skill": {
      "title": "添加 Claude Skill 仓库",
      "repo": "GitHub 仓库",
      "directory": "目标目录",
      "branch": "分支",
      "skillsPath": "Skills 路径",
      "hint": "此操作将添加 Skill 仓库到列表。",
      "hintDetail": "添加后，您可以在 Skills 管理界面中选择安装具体的 Skill。"
    }
  },
  "iconPicker": {
    "search": "搜索图标",
    "searchPlaceholder": "输入图标名称...",
    "noResults": "未找到匹配的图标",
    "category": {
      "aiProvider": "AI 服务商",
      "cloud": "云平台",
      "tool": "开发工具",
      "other": "其他"
    }
  },
  "providerIcon": {
    "label": "图标",
    "colorLabel": "图标颜色",
    "selectIcon": "选择图标",
    "preview": "预览",
    "clickToChange": "点击更换图标",
    "clickToSelect": "点击选择图标"
  },
  "migration": {
    "success": "配置迁移成功"
  },
  "agents": {
    "title": "智能体"
  },
  "health": {
    "operational": "正常",
    "degraded": "降级",
    "failed": "失败",
    "circuitOpen": "熔断",
    "consecutiveFailures": "连续失败 {{count}} 次"
  },
  "proxy": {
    "panel": {
      "serviceAddress": "服务地址",
      "addressCopied": "地址已复制",
      "currentProvider": "当前 Provider：",
      "waitingFirstRequest": "当前 Provider：等待首次请求…",
      "stoppedTitle": "代理服务已停止",
      "stoppedDescription": "使用右上角开关即可启动服务",
      "openSettings": "配置代理服务",
      "stats": {
        "activeConnections": "活跃连接",
        "totalRequests": "总请求数",
        "successRate": "成功率",
        "uptime": "运行时间"
      }
    },
    "settings": {
      "toast": {
        "saved": "代理配置已保存",
        "saveFailed": "保存失败: {{error}}"
      }
    },
    "switchFailed": "切换失败: {{error}}",
    "failoverQueue": {
      "title": "故障转移队列",
      "description": "管理各应用的供应商故障转移顺序",
      "info": "当前激活的供应商始终优先。当请求失败时，系统会按队列顺序依次尝试其他供应商。",
      "selectProvider": "选择供应商添加到队列",
      "noAvailableProviders": "没有可添加的供应商",
      "empty": "故障转移队列为空。添加供应商以启用自动故障转移。",
      "dragHint": "拖拽供应商可调整故障转移顺序，序号越小优先级越高。",
      "toggleEnabled": "启用/禁用",
      "addSuccess": "已添加到故障转移队列",
      "addFailed": "添加失败",
      "removeSuccess": "已从故障转移队列移除",
      "removeFailed": "移除失败",
      "reorderSuccess": "队列顺序已更新",
      "reorderFailed": "更新顺序失败",
      "toggleFailed": "状态更新失败"
    },
    "autoFailover": {
      "info": "当故障转移队列中配置了多个供应商时，系统会在请求失败时按优先级顺序依次尝试。当某个供应商连续失败达到阈值时，熔断器会打开并在一段时间内跳过该供应商。",
      "configSaved": "自动故障转移配置已保存",
      "configSaveFailed": "保存失败",
      "retrySettings": "重试与超时设置",
      "failureThreshold": "失败阈值",
      "failureThresholdHint": "连续失败多少次后打开熔断器（建议: 3-10）",
      "timeout": "恢复等待时间（秒）",
      "timeoutHint": "熔断器打开后，等待多久后尝试恢复（建议: 30-120）",
      "circuitBreakerSettings": "熔断器高级设置",
      "successThreshold": "恢复成功阈值",
      "successThresholdHint": "半开状态下成功多少次后关闭熔断器",
      "errorRate": "错误率阈值 (%)",
      "errorRateHint": "错误率超过此值时打开熔断器",
      "minRequests": "最小请求数",
      "minRequestsHint": "计算错误率前的最小请求数",
      "explanationTitle": "工作原理",
      "failureThresholdLabel": "失败阈值",
      "failureThresholdExplain": "连续失败达到此次数时，熔断器打开，该供应商暂时不可用",
      "timeoutLabel": "恢复等待时间",
      "timeoutExplain": "熔断器打开后，等待此时间后尝试半开状态",
      "successThresholdLabel": "恢复成功阈值",
      "successThresholdExplain": "半开状态下，成功达到此次数时关闭熔断器，供应商恢复可用",
      "errorRateLabel": "错误率阈值",
      "errorRateExplain": "错误率超过此值时，即使未达到失败阈值也会打开熔断器"
    }
  },
  "streamCheck": {
    "configSaved": "健康检查配置已保存",
    "configSaveFailed": "保存失败",
    "testModels": "测试模型",
    "claudeModel": "Claude 模型",
    "codexModel": "Codex 模型",
    "geminiModel": "Gemini 模型",
    "checkParams": "检查参数",
    "timeout": "超时时间（秒）",
    "maxRetries": "最大重试次数",
    "degradedThreshold": "降级阈值（毫秒）"
  }
}
</file>

<file path="src/App.tsx">
import { useEffect, useMemo, useState, useRef } from "react";
import { useTranslation } from "react-i18next";
import { motion, AnimatePresence } from "framer-motion";
import { toast } from "sonner";
import { invoke } from "@tauri-apps/api/core";
import { useQueryClient } from "@tanstack/react-query";
import {
  Plus,
  Settings,
  ArrowLeft,
  // Bot, // TODO: Agents 功能开发中，暂时不需要
  Book,
  Wrench,
  Server,
  RefreshCw,
} from "lucide-react";
import type { Provider } from "@/types";
import type { EnvConflict } from "@/types/env";
import { useProvidersQuery } from "@/lib/query";
import {
  providersApi,
  settingsApi,
  type AppId,
  type ProviderSwitchEvent,
} from "@/lib/api";
import { checkAllEnvConflicts, checkEnvConflicts } from "@/lib/api/env";
import { useProviderActions } from "@/hooks/useProviderActions";
import { useProxyStatus } from "@/hooks/useProxyStatus";
import { extractErrorMessage } from "@/utils/errorUtils";
import { cn } from "@/lib/utils";
import { AppSwitcher } from "@/components/AppSwitcher";
import { ProviderList } from "@/components/providers/ProviderList";
import { AddProviderDialog } from "@/components/providers/AddProviderDialog";
import { EditProviderDialog } from "@/components/providers/EditProviderDialog";
import { ConfirmDialog } from "@/components/ConfirmDialog";
import { SettingsPage } from "@/components/settings/SettingsPage";
import { UpdateBadge } from "@/components/UpdateBadge";
import { EnvWarningBanner } from "@/components/env/EnvWarningBanner";
import { ProxyToggle } from "@/components/proxy/ProxyToggle";
import UsageScriptModal from "@/components/UsageScriptModal";
import UnifiedMcpPanel from "@/components/mcp/UnifiedMcpPanel";
import PromptPanel from "@/components/prompts/PromptPanel";
import { SkillsPage } from "@/components/skills/SkillsPage";
import { DeepLinkImportDialog } from "@/components/DeepLinkImportDialog";
import { AgentsPanel } from "@/components/agents/AgentsPanel";
import { Button } from "@/components/ui/button";

type View = "providers" | "settings" | "prompts" | "skills" | "mcp" | "agents";

const DRAG_BAR_HEIGHT = 28; // px
const HEADER_HEIGHT = 64; // px
const CONTENT_TOP_OFFSET = DRAG_BAR_HEIGHT + HEADER_HEIGHT;

function App() {
  const { t } = useTranslation();
  const queryClient = useQueryClient();

  const [activeApp, setActiveApp] = useState<AppId>("claude");
  const [currentView, setCurrentView] = useState<View>("providers");
  const [isAddOpen, setIsAddOpen] = useState(false);

  const [editingProvider, setEditingProvider] = useState<Provider | null>(null);
  const [usageProvider, setUsageProvider] = useState<Provider | null>(null);
  const [confirmDelete, setConfirmDelete] = useState<Provider | null>(null);
  const [envConflicts, setEnvConflicts] = useState<EnvConflict[]>([]);
  const [showEnvBanner, setShowEnvBanner] = useState(false);

  // 保存最后一个有效的 provider，用于动画退出期间显示内容
  const lastUsageProviderRef = useRef<Provider | null>(null);
  const lastEditingProviderRef = useRef<Provider | null>(null);

  useEffect(() => {
    if (usageProvider) {
      lastUsageProviderRef.current = usageProvider;
    }
  }, [usageProvider]);

  useEffect(() => {
    if (editingProvider) {
      lastEditingProviderRef.current = editingProvider;
    }
  }, [editingProvider]);

  const promptPanelRef = useRef<any>(null);
  const mcpPanelRef = useRef<any>(null);
  const skillsPageRef = useRef<any>(null);
  const addActionButtonClass =
    "bg-orange-500 hover:bg-orange-600 dark:bg-orange-500 dark:hover:bg-orange-600 text-white shadow-lg shadow-orange-500/30 dark:shadow-orange-500/40 rounded-full w-8 h-8";

  // 获取代理服务状态
  const {
    isRunning: isProxyRunning,
    takeoverStatus,
    status: proxyStatus,
  } = useProxyStatus();
  // 当前应用的代理是否开启
  const isCurrentAppTakeoverActive = takeoverStatus?.[activeApp] || false;
  // 当前应用代理实际使用的供应商 ID（从 active_targets 中获取）
  const activeProviderId = useMemo(() => {
    const target = proxyStatus?.active_targets?.find(
      (t) => t.app_type === activeApp,
    );
    return target?.provider_id;
  }, [proxyStatus?.active_targets, activeApp]);

  // 获取供应商列表，当代理服务运行时自动刷新
  const { data, isLoading, refetch } = useProvidersQuery(activeApp, {
    isProxyRunning,
  });
  const providers = useMemo(() => data?.providers ?? {}, [data]);
  const currentProviderId = data?.currentProviderId ?? "";
  // Skills 功能仅支持 Claude 和 Codex
  const hasSkillsSupport = activeApp === "claude" || activeApp === "codex";

  // 🎯 使用 useProviderActions Hook 统一管理所有 Provider 操作
  const {
    addProvider,
    updateProvider,
    switchProvider,
    deleteProvider,
    saveUsageScript,
  } = useProviderActions(activeApp);

  // 监听来自托盘菜单的切换事件
  useEffect(() => {
    let unsubscribe: (() => void) | undefined;

    const setupListener = async () => {
      try {
        unsubscribe = await providersApi.onSwitched(
          async (event: ProviderSwitchEvent) => {
            if (event.appType === activeApp) {
              await refetch();
            }
          },
        );
      } catch (error) {
        console.error("[App] Failed to subscribe provider switch event", error);
      }
    };

    setupListener();
    return () => {
      unsubscribe?.();
    };
  }, [activeApp, refetch]);

  // 应用启动时检测所有应用的环境变量冲突
  useEffect(() => {
    const checkEnvOnStartup = async () => {
      try {
        const allConflicts = await checkAllEnvConflicts();
        const flatConflicts = Object.values(allConflicts).flat();

        if (flatConflicts.length > 0) {
          setEnvConflicts(flatConflicts);
          const dismissed = sessionStorage.getItem("env_banner_dismissed");
          if (!dismissed) {
            setShowEnvBanner(true);
          }
        }
      } catch (error) {
        console.error(
          "[App] Failed to check environment conflicts on startup:",
          error,
        );
      }
    };

    checkEnvOnStartup();
  }, []);

  // 应用启动时检查是否刚完成了配置迁移
  useEffect(() => {
    const checkMigration = async () => {
      try {
        const migrated = await invoke<boolean>("get_migration_result");
        if (migrated) {
          toast.success(
            t("migration.success", { defaultValue: "配置迁移成功" }),
            { closeButton: true },
          );
        }
      } catch (error) {
        console.error("[App] Failed to check migration result:", error);
      }
    };

    checkMigration();
  }, [t]);

  // 切换应用时检测当前应用的环境变量冲突
  useEffect(() => {
    const checkEnvOnSwitch = async () => {
      try {
        const conflicts = await checkEnvConflicts(activeApp);

        if (conflicts.length > 0) {
          // 合并新检测到的冲突
          setEnvConflicts((prev) => {
            const existingKeys = new Set(
              prev.map((c) => `${c.varName}:${c.sourcePath}`),
            );
            const newConflicts = conflicts.filter(
              (c) => !existingKeys.has(`${c.varName}:${c.sourcePath}`),
            );
            return [...prev, ...newConflicts];
          });
          const dismissed = sessionStorage.getItem("env_banner_dismissed");
          if (!dismissed) {
            setShowEnvBanner(true);
          }
        }
      } catch (error) {
        console.error(
          "[App] Failed to check environment conflicts on app switch:",
          error,
        );
      }
    };

    checkEnvOnSwitch();
  }, [activeApp]);

  // 打开网站链接
  const handleOpenWebsite = async (url: string) => {
    try {
      await settingsApi.openExternal(url);
    } catch (error) {
      const detail =
        extractErrorMessage(error) ||
        t("notifications.openLinkFailed", {
          defaultValue: "链接打开失败",
        });
      toast.error(detail);
    }
  };

  // 编辑供应商
  const handleEditProvider = async (provider: Provider) => {
    await updateProvider(provider);
    setEditingProvider(null);
  };

  // 确认删除供应商
  const handleConfirmDelete = async () => {
    if (!confirmDelete) return;
    await deleteProvider(confirmDelete.id);
    setConfirmDelete(null);
  };

  // 复制供应商
  const handleDuplicateProvider = async (provider: Provider) => {
    // 1️⃣ 计算新的 sortIndex：如果原供应商有 sortIndex，则复制它
    const newSortIndex =
      provider.sortIndex !== undefined ? provider.sortIndex + 1 : undefined;

    const duplicatedProvider: Omit<Provider, "id" | "createdAt"> = {
      name: `${provider.name} copy`,
      settingsConfig: JSON.parse(JSON.stringify(provider.settingsConfig)), // 深拷贝
      websiteUrl: provider.websiteUrl,
      category: provider.category,
      sortIndex: newSortIndex, // 复制原 sortIndex + 1
      meta: provider.meta
        ? JSON.parse(JSON.stringify(provider.meta))
        : undefined, // 深拷贝
      icon: provider.icon,
      iconColor: provider.iconColor,
    };

    // 2️⃣ 如果原供应商有 sortIndex，需要将后续所有供应商的 sortIndex +1
    if (provider.sortIndex !== undefined) {
      const updates = Object.values(providers)
        .filter(
          (p) =>
            p.sortIndex !== undefined &&
            p.sortIndex >= newSortIndex! &&
            p.id !== provider.id,
        )
        .map((p) => ({
          id: p.id,
          sortIndex: p.sortIndex! + 1,
        }));

      // 先更新现有供应商的 sortIndex，为新供应商腾出位置
      if (updates.length > 0) {
        try {
          await providersApi.updateSortOrder(updates, activeApp);
        } catch (error) {
          console.error("[App] Failed to update sort order", error);
          toast.error(
            t("provider.sortUpdateFailed", {
              defaultValue: "排序更新失败",
            }),
          );
          return; // 如果排序更新失败，不继续添加
        }
      }
    }

    // 3️⃣ 添加复制的供应商
    await addProvider(duplicatedProvider);
  };

  // 导入配置成功后刷新
  const handleImportSuccess = async () => {
    try {
      // 导入会影响所有应用的供应商数据：刷新所有 providers 缓存
      await queryClient.invalidateQueries({
        queryKey: ["providers"],
        refetchType: "all",
      });
      await queryClient.refetchQueries({
        queryKey: ["providers"],
        type: "all",
      });
    } catch (error) {
      console.error("[App] Failed to refresh providers after import", error);
      await refetch();
    }
    try {
      await providersApi.updateTrayMenu();
    } catch (error) {
      console.error("[App] Failed to refresh tray menu", error);
    }
  };

  const renderContent = () => {
    const content = (() => {
      switch (currentView) {
        case "settings":
          return (
            <SettingsPage
              open={true}
              onOpenChange={() => setCurrentView("providers")}
              onImportSuccess={handleImportSuccess}
            />
          );
        case "prompts":
          return (
            <PromptPanel
              ref={promptPanelRef}
              open={true}
              onOpenChange={() => setCurrentView("providers")}
              appId={activeApp}
            />
          );
        case "skills":
          return (
            <SkillsPage
              ref={skillsPageRef}
              onClose={() => setCurrentView("providers")}
              initialApp={activeApp}
            />
          );
        case "mcp":
          return (
            <UnifiedMcpPanel
              ref={mcpPanelRef}
              onOpenChange={() => setCurrentView("providers")}
            />
          );
        case "agents":
          return (
            <AgentsPanel onOpenChange={() => setCurrentView("providers")} />
          );
        default:
          return (
            <div className="mx-auto max-w-[56rem] px-5 flex flex-col h-[calc(100vh-8rem)] overflow-hidden">
              {/* 独立滚动容器 - 解决 Linux/Ubuntu 下 DndContext 与滚轮事件冲突 */}
              <div className="flex-1 overflow-y-auto overflow-x-hidden pb-12 px-1">
                <AnimatePresence mode="wait">
                  <motion.div
                    key={activeApp}
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    transition={{ duration: 0.15 }}
                    className="space-y-4"
                  >
                    <ProviderList
                      providers={providers}
                      currentProviderId={currentProviderId}
                      appId={activeApp}
                      isLoading={isLoading}
                      isProxyRunning={isProxyRunning}
                      isProxyTakeover={
                        isProxyRunning && isCurrentAppTakeoverActive
                      }
                      activeProviderId={activeProviderId}
                      onSwitch={switchProvider}
                      onEdit={setEditingProvider}
                      onDelete={setConfirmDelete}
                      onDuplicate={handleDuplicateProvider}
                      onConfigureUsage={setUsageProvider}
                      onOpenWebsite={handleOpenWebsite}
                      onCreate={() => setIsAddOpen(true)}
                    />
                  </motion.div>
                </AnimatePresence>
              </div>
            </div>
          );
      }
    })();

    return (
      <AnimatePresence mode="wait">
        <motion.div
          key={currentView}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.2 }}
        >
          {content}
        </motion.div>
      </AnimatePresence>
    );
  };

  return (
    <div
      className="flex flex-col h-screen overflow-hidden bg-background text-foreground selection:bg-primary/30"
      style={{ overflowX: "hidden", paddingTop: CONTENT_TOP_OFFSET }}
    >
      {/* 全局拖拽区域（顶部 28px），避免上边框无法拖动 */}
      <div
        className="fixed top-0 left-0 right-0 z-[60]"
        data-tauri-drag-region
        style={{ WebkitAppRegion: "drag", height: DRAG_BAR_HEIGHT } as any}
      />
      {/* 环境变量警告横幅 */}
      {showEnvBanner && envConflicts.length > 0 && (
        <EnvWarningBanner
          conflicts={envConflicts}
          onDismiss={() => {
            setShowEnvBanner(false);
            sessionStorage.setItem("env_banner_dismissed", "true");
          }}
          onDeleted={async () => {
            // 删除后重新检测
            try {
              const allConflicts = await checkAllEnvConflicts();
              const flatConflicts = Object.values(allConflicts).flat();
              setEnvConflicts(flatConflicts);
              if (flatConflicts.length === 0) {
                setShowEnvBanner(false);
              }
            } catch (error) {
              console.error(
                "[App] Failed to re-check conflicts after deletion:",
                error,
              );
            }
          }}
        />
      )}

      <header
        className="fixed z-50 w-full transition-all duration-300 bg-background/80 backdrop-blur-md"
        data-tauri-drag-region
        style={
          {
            WebkitAppRegion: "drag",
            top: DRAG_BAR_HEIGHT,
            height: HEADER_HEIGHT,
          } as any
        }
      >
        <div
          className="mx-auto flex h-full max-w-[56rem] flex-wrap items-center justify-between gap-2 px-6"
          data-tauri-drag-region
          style={{ WebkitAppRegion: "drag" } as any}
        >
          <div
            className="flex items-center gap-1"
            style={{ WebkitAppRegion: "no-drag" } as any}
          >
            {currentView !== "providers" ? (
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="icon"
                  onClick={() => setCurrentView("providers")}
                  className="mr-2 rounded-lg"
                >
                  <ArrowLeft className="w-4 h-4" />
                </Button>
                <h1 className="text-lg font-semibold">
                  {currentView === "settings" && t("settings.title")}
                  {currentView === "prompts" &&
                    t("prompts.title", { appName: t(`apps.${activeApp}`) })}
                  {currentView === "skills" && t("skills.title")}
                  {currentView === "mcp" && t("mcp.unifiedPanel.title")}
                  {currentView === "agents" && t("agents.title")}
                </h1>
              </div>
            ) : (
              <>
                <div className="flex items-center gap-2">
                  <a
                    href="https://github.com/farion1231/cc-switch"
                    target="_blank"
                    rel="noreferrer"
                    className={cn(
                      "text-xl font-semibold transition-colors",
                      isProxyRunning && isCurrentAppTakeoverActive
                        ? "text-emerald-500 hover:text-emerald-600 dark:text-emerald-400 dark:hover:text-emerald-300"
                        : "text-blue-500 hover:text-blue-600 dark:text-blue-400 dark:hover:text-blue-300",
                    )}
                  >
                    CC Switch
                  </a>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={() => setCurrentView("settings")}
                    title={t("common.settings")}
                    className="hover:bg-black/5 dark:hover:bg-white/5"
                  >
                    <Settings className="w-4 h-4" />
                  </Button>
                </div>
                <UpdateBadge onClick={() => setCurrentView("settings")} />
              </>
            )}
          </div>

          <div
            className="flex items-center gap-2 h-[32px]"
            style={{ WebkitAppRegion: "no-drag" } as any}
          >
            {currentView === "prompts" && (
              <Button
                size="icon"
                onClick={() => promptPanelRef.current?.openAdd()}
                className={`ml-auto ${addActionButtonClass}`}
                title={t("prompts.add")}
              >
                <Plus className="w-5 h-5" />
              </Button>
            )}
            {currentView === "mcp" && (
              <Button
                size="icon"
                onClick={() => mcpPanelRef.current?.openAdd()}
                className={`ml-auto ${addActionButtonClass}`}
                title={t("mcp.unifiedPanel.addServer")}
              >
                <Plus className="w-5 h-5" />
              </Button>
            )}
            {currentView === "skills" && (
              <>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => skillsPageRef.current?.refresh()}
                  className="hover:bg-black/5 dark:hover:bg-white/5"
                >
                  <RefreshCw className="w-4 h-4 mr-2" />
                  {t("skills.refresh")}
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => skillsPageRef.current?.openRepoManager()}
                  className="hover:bg-black/5 dark:hover:bg-white/5"
                >
                  <Settings className="w-4 h-4 mr-2" />
                  {t("skills.repoManager")}
                </Button>
              </>
            )}
            {currentView === "providers" && (
              <>
                <ProxyToggle activeApp={activeApp} />

                <AppSwitcher activeApp={activeApp} onSwitch={setActiveApp} />

                <div className="flex items-center gap-1 p-1 bg-muted rounded-xl">
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setCurrentView("skills")}
                    className={cn(
                      "text-muted-foreground hover:text-foreground hover:bg-black/5 dark:hover:bg-white/5",
                      "transition-all duration-200 ease-in-out overflow-hidden",
                      hasSkillsSupport
                        ? "opacity-100 w-8 scale-100 px-2"
                        : "opacity-0 w-0 scale-75 pointer-events-none px-0 -ml-1",
                    )}
                    title={t("skills.manage")}
                  >
                    <Wrench className="flex-shrink-0 w-4 h-4" />
                  </Button>
                  {/* TODO: Agents 功能开发中，暂时隐藏入口 */}
                  {/* {isClaudeApp && (
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => setCurrentView("agents")}
                        className="text-muted-foreground hover:text-foreground hover:bg-black/5 dark:hover:bg-white/5"
                        title="Agents"
                      >
                        <Bot className="w-4 h-4" />
                      </Button>
                    )} */}
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setCurrentView("prompts")}
                    className="text-muted-foreground hover:text-foreground hover:bg-black/5 dark:hover:bg-white/5"
                    title={t("prompts.manage")}
                  >
                    <Book className="w-4 h-4" />
                  </Button>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setCurrentView("mcp")}
                    className="text-muted-foreground hover:text-foreground hover:bg-black/5 dark:hover:bg-white/5"
                    title={t("mcp.title")}
                  >
                    <Server className="w-4 h-4" />
                  </Button>
                </div>

                <Button
                  onClick={() => setIsAddOpen(true)}
                  size="icon"
                  className={`ml-2 ${addActionButtonClass}`}
                >
                  <Plus className="w-5 h-5" />
                </Button>
              </>
            )}
          </div>
        </div>
      </header>

      <main className="flex-1 pb-12 animate-fade-in ">
        <div className="pb-12">
          {renderContent()}
        </div>
      </main>

      <AddProviderDialog
        open={isAddOpen}
        onOpenChange={setIsAddOpen}
        appId={activeApp}
        onSubmit={addProvider}
      />

      <EditProviderDialog
        open={Boolean(editingProvider)}
        provider={lastEditingProviderRef.current}
        onOpenChange={(open) => {
          if (!open) {
            setEditingProvider(null);
          }
        }}
        onSubmit={handleEditProvider}
        appId={activeApp}
        isProxyTakeover={isProxyRunning && isCurrentAppTakeoverActive}
      />

      {lastUsageProviderRef.current && (
        <UsageScriptModal
          provider={lastUsageProviderRef.current}
          appId={activeApp}
          isOpen={Boolean(usageProvider)}
          onClose={() => setUsageProvider(null)}
          onSave={(script) => {
            if (usageProvider) {
              void saveUsageScript(usageProvider, script);
            }
          }}
        />
      )}

      <ConfirmDialog
        isOpen={Boolean(confirmDelete)}
        title={t("confirm.deleteProvider")}
        message={
          confirmDelete
            ? t("confirm.deleteProviderMessage", {
                name: confirmDelete.name,
              })
            : ""
        }
        onConfirm={() => void handleConfirmDelete()}
        onCancel={() => setConfirmDelete(null)}
      />

      <DeepLinkImportDialog />
    </div>
  );
}

export default App;
</file>

</files>
